
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "OrderRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "IconRecord.h"

CTPDatabase<OrderRecord> *g_theOrderDB = NULL;

OrderRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_Gold = 0;
    m_Move = 0;
    m_EventName = NULL;
    m_LocalizedName = 0;
    m_StatusText = 0;
    m_TargetPretest = 0;
    m_RangeValue = 0;
    m_CPIcon = NULL;
    m_DefaultIcon = 0x7fffffff;
    m_ButtonLocation = 0;
    m_Cursor = 0;
    m_InvalidCursor = 0;
    m_FailSoundValue = 0;
    m_SoundValue = 0;
}

OrderRecord::~OrderRecord()
{
	int index = 0;
	// free string attribute EventName
	if (m_EventName) 
		delete m_EventName; 
	m_EventName = NULL; 

	// free string attribute CPIcon
	if (m_CPIcon) 
		delete m_CPIcon; 
	m_CPIcon = NULL; 

}

void OrderRecord::operator=(const OrderRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_Gold = rval.m_Gold; 

	m_Move = rval.m_Move; 

	if (m_EventName) 
	{ 
	delete m_EventName; 

	}

	if (rval.m_EventName) 
	{ 
		m_EventName = new char [strlen(rval.m_EventName)+1]; 
		strcpy(m_EventName, rval.m_EventName);
	}

	m_LocalizedName = rval.m_LocalizedName; 

	m_StatusText = rval.m_StatusText; 

	m_TargetPretest = rval.m_TargetPretest; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
		m_RangeValue = rval.m_RangeValue; 

	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	if (m_CPIcon) 
	{ 
	delete m_CPIcon; 

	}

	if (rval.m_CPIcon) 
	{ 
		m_CPIcon = new char [strlen(rval.m_CPIcon)+1]; 
		strcpy(m_CPIcon, rval.m_CPIcon);
	}

	m_DefaultIcon = rval.m_DefaultIcon; 

	m_ButtonLocation = rval.m_ButtonLocation; 

	m_Cursor = rval.m_Cursor; 

	m_InvalidCursor = rval.m_InvalidCursor; 

	m_flags1 = rval.m_flags1; 
		m_FailSoundValue = rval.m_FailSoundValue; 

	m_flags1 = rval.m_flags1; 
		m_SoundValue = rval.m_SoundValue; 

}

char *g_Order_Tokens[] =
{
    "Gold",
    "Move",
    "EventName",
    "LocalizedName",
    "StatusText",
    "TargetPretest",
    "UnitPretest_None",
    "UnitPretest_CanAttack",
    "UnitPretest_CanEntrench",
    "UnitPretest_CanSueFranchise",
    "UnitPretest_CanSue",
    "UnitPretest_CanCreateFranchise",
    "UnitPretest_CanInvestigateCity",
    "UnitPretest_CanBombard",
    "UnitPretest_CanSettle",
    "UnitPretest_CanStealTechnology",
    "UnitPretest_CanInciteRevolution",
    "UnitPretest_CanAssassinateRuler",
    "UnitPretest_CanExpel",
    "UnitPretest_EstablishEmbassy",
    "UnitPretest_ThrowParty",
    "UnitPretest_CanCauseUnhappiness",
    "UnitPretest_CanPlantNuke",
    "UnitPretest_CanSlaveRaid",
    "UnitPretest_CanEnslaveSettler",
    "UnitPretest_CanUndergroundRailway",
    "UnitPretest_CanInciteUprising",
    "UnitPretest_CanBioTerror",
    "UnitPretest_CanPlague",
    "UnitPretest_CanNanoInfect",
    "UnitPretest_CanConvertCity",
    "UnitPretest_CanReformCity",
    "UnitPretest_CanSellIndulgences",
    "UnitPretest_CanFaithHeal",
    "UnitPretest_CanSoothsay",
    "UnitPretest_CanCreatePark",
    "UnitPretest_CanPillage",
    "UnitPretest_CanInjoin",
    "UnitPretest_CanInterceptTrade",
    "UnitPretest_CanAdvertise",
    "UnitPretest_CanNukeCity",
    "UnitPretest_CanTransport",
    "UnitPretest_CanBeTransported",
    "UnitPretest_CanLaunch",
    "UnitPretest_CanTarget",
    "UnitPretest_Invalid",
    "Range",
    "RangeValue",
    "IsTeleport",
    "IsTarget",
    "GLHidden",
    "CPIcon",
    "DefaultIcon",
    "ButtonLocation",
    "Cursor",
    "InvalidCursor",
    "FailSound",
    "FailSoundValue",
    "Sound",
    "SoundValue",
};

OrderRecordAccessorInfo g_OrderRecord_Accessors[] = 
{
    { OrderRecord::GetGold, NULL, NULL, NULL, NULL },
    { OrderRecord::GetMove, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EventName */
    { NULL, NULL, NULL, NULL, NULL}, /* LocalizedName */
    { NULL, NULL, NULL, NULL, NULL}, /* StatusText */
    { NULL, NULL, NULL, NULL, NULL}, /* TargetPretest */
    { NULL, OrderRecord::GetUnitPretest_None, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanAttack, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanEntrench, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSueFranchise, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSue, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanCreateFranchise, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanInvestigateCity, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanBombard, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSettle, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanStealTechnology, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanInciteRevolution, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanAssassinateRuler, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanExpel, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_EstablishEmbassy, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_ThrowParty, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanCauseUnhappiness, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanPlantNuke, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSlaveRaid, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanEnslaveSettler, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanUndergroundRailway, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanInciteUprising, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanBioTerror, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanPlague, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanNanoInfect, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanConvertCity, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanReformCity, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSellIndulgences, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanFaithHeal, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanSoothsay, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanCreatePark, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanPillage, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanInjoin, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanInterceptTrade, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanAdvertise, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanNukeCity, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanTransport, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanBeTransported, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanLaunch, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_CanTarget, NULL, NULL, NULL },
    { NULL, OrderRecord::GetUnitPretest_Invalid, NULL, NULL, NULL },
    { NULL, NULL, NULL, OrderRecord::GetRange, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Range */
    { NULL, OrderRecord::GetIsTeleport, NULL, NULL, NULL },
    { NULL, OrderRecord::GetIsTarget, NULL, NULL, NULL },
    { NULL, OrderRecord::GetGLHidden, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CPIcon */
    {OrderRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL },
    { OrderRecord::GetButtonLocation, NULL, NULL, NULL, NULL },
    { OrderRecord::GetCursor, NULL, NULL, NULL, NULL },
    { OrderRecord::GetInvalidCursor, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, OrderRecord::GetFailSound, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FailSound */
    { NULL, NULL, NULL, OrderRecord::GetSound, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Sound */
};

#define k_Token_Order_Gold                       ((k_Token_Custom_Base) + 0)
#define k_Token_Order_Move                       ((k_Token_Custom_Base) + 1)
#define k_Token_Order_EventName                  ((k_Token_Custom_Base) + 2)
#define k_Token_Order_LocalizedName              ((k_Token_Custom_Base) + 3)
#define k_Token_Order_StatusText                 ((k_Token_Custom_Base) + 4)
#define k_Token_Order_TargetPretest              ((k_Token_Custom_Base) + 5)
#define k_Token_Order_UnitPretest_None           ((k_Token_Custom_Base) + 6)
#define k_Token_Order_UnitPretest_CanAttack      ((k_Token_Custom_Base) + 7)
#define k_Token_Order_UnitPretest_CanEntrench    ((k_Token_Custom_Base) + 8)
#define k_Token_Order_UnitPretest_CanSueFranchise ((k_Token_Custom_Base) + 9)
#define k_Token_Order_UnitPretest_CanSue         ((k_Token_Custom_Base) + 10)
#define k_Token_Order_UnitPretest_CanCreateFranchise ((k_Token_Custom_Base) + 11)
#define k_Token_Order_UnitPretest_CanInvestigateCity ((k_Token_Custom_Base) + 12)
#define k_Token_Order_UnitPretest_CanBombard     ((k_Token_Custom_Base) + 13)
#define k_Token_Order_UnitPretest_CanSettle      ((k_Token_Custom_Base) + 14)
#define k_Token_Order_UnitPretest_CanStealTechnology ((k_Token_Custom_Base) + 15)
#define k_Token_Order_UnitPretest_CanInciteRevolution ((k_Token_Custom_Base) + 16)
#define k_Token_Order_UnitPretest_CanAssassinateRuler ((k_Token_Custom_Base) + 17)
#define k_Token_Order_UnitPretest_CanExpel       ((k_Token_Custom_Base) + 18)
#define k_Token_Order_UnitPretest_EstablishEmbassy ((k_Token_Custom_Base) + 19)
#define k_Token_Order_UnitPretest_ThrowParty     ((k_Token_Custom_Base) + 20)
#define k_Token_Order_UnitPretest_CanCauseUnhappiness ((k_Token_Custom_Base) + 21)
#define k_Token_Order_UnitPretest_CanPlantNuke   ((k_Token_Custom_Base) + 22)
#define k_Token_Order_UnitPretest_CanSlaveRaid   ((k_Token_Custom_Base) + 23)
#define k_Token_Order_UnitPretest_CanEnslaveSettler ((k_Token_Custom_Base) + 24)
#define k_Token_Order_UnitPretest_CanUndergroundRailway ((k_Token_Custom_Base) + 25)
#define k_Token_Order_UnitPretest_CanInciteUprising ((k_Token_Custom_Base) + 26)
#define k_Token_Order_UnitPretest_CanBioTerror   ((k_Token_Custom_Base) + 27)
#define k_Token_Order_UnitPretest_CanPlague      ((k_Token_Custom_Base) + 28)
#define k_Token_Order_UnitPretest_CanNanoInfect  ((k_Token_Custom_Base) + 29)
#define k_Token_Order_UnitPretest_CanConvertCity ((k_Token_Custom_Base) + 30)
#define k_Token_Order_UnitPretest_CanReformCity  ((k_Token_Custom_Base) + 31)
#define k_Token_Order_UnitPretest_CanSellIndulgences ((k_Token_Custom_Base) + 32)
#define k_Token_Order_UnitPretest_CanFaithHeal   ((k_Token_Custom_Base) + 33)
#define k_Token_Order_UnitPretest_CanSoothsay    ((k_Token_Custom_Base) + 34)
#define k_Token_Order_UnitPretest_CanCreatePark  ((k_Token_Custom_Base) + 35)
#define k_Token_Order_UnitPretest_CanPillage     ((k_Token_Custom_Base) + 36)
#define k_Token_Order_UnitPretest_CanInjoin      ((k_Token_Custom_Base) + 37)
#define k_Token_Order_UnitPretest_CanInterceptTrade ((k_Token_Custom_Base) + 38)
#define k_Token_Order_UnitPretest_CanAdvertise   ((k_Token_Custom_Base) + 39)
#define k_Token_Order_UnitPretest_CanNukeCity    ((k_Token_Custom_Base) + 40)
#define k_Token_Order_UnitPretest_CanTransport   ((k_Token_Custom_Base) + 41)
#define k_Token_Order_UnitPretest_CanBeTransported ((k_Token_Custom_Base) + 42)
#define k_Token_Order_UnitPretest_CanLaunch      ((k_Token_Custom_Base) + 43)
#define k_Token_Order_UnitPretest_CanTarget      ((k_Token_Custom_Base) + 44)
#define k_Token_Order_UnitPretest_Invalid        ((k_Token_Custom_Base) + 45)
#define k_Token_Order_Range                      ((k_Token_Custom_Base) + 46)
#define k_Token_Order_Range_Value                ((k_Token_Custom_Base) + 47)
#define k_Token_Order_IsTeleport                 ((k_Token_Custom_Base) + 48)
#define k_Token_Order_IsTarget                   ((k_Token_Custom_Base) + 49)
#define k_Token_Order_GLHidden                   ((k_Token_Custom_Base) + 50)
#define k_Token_Order_CPIcon                     ((k_Token_Custom_Base) + 51)
#define k_Token_Order_DefaultIcon                ((k_Token_Custom_Base) + 52)
#define k_Token_Order_ButtonLocation             ((k_Token_Custom_Base) + 53)
#define k_Token_Order_Cursor                     ((k_Token_Custom_Base) + 54)
#define k_Token_Order_InvalidCursor              ((k_Token_Custom_Base) + 55)
#define k_Token_Order_FailSound                  ((k_Token_Custom_Base) + 56)
#define k_Token_Order_FailSound_Value            ((k_Token_Custom_Base) + 57)
#define k_Token_Order_Sound                      ((k_Token_Custom_Base) + 58)
#define k_Token_Order_Sound_Value                ((k_Token_Custom_Base) + 59)
#define k_Token_Order_Max                        ((k_Token_Custom_Base) + 60)


static BitArray s_ParsedTokens(60);
void OrderRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Order_Gold - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Gold missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_Move - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Move missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_EventName - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field EventName missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_LocalizedName - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field LocalizedName missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_StatusText - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StatusText missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_CPIcon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field CPIcon missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_ButtonLocation - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ButtonLocation missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_Cursor - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Cursor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Order_InvalidCursor - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field InvalidCursor missing"));
    }
}
    
sint32 OrderRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Order_Tokens, k_Token_Order_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Order_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Order_Gold:
                if(!lex->GetIntAssignment(m_Gold)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_Move:
                if(!lex->GetIntAssignment(m_Move)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_EventName:
                if(!lex->GetFileAssignment(m_EventName)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Order_LocalizedName:
                if(!lex->GetStringIdAssignment(m_LocalizedName)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Order_StatusText:
                if(!lex->GetStringIdAssignment(m_StatusText)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Order_TargetPretest:
                if(!ParseTargetPretestBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Order_UnitPretest_None:
                m_flags0 |= k_Order_UnitPretest_None_Bit;
                break;
            case k_Token_Order_UnitPretest_CanAttack:
                m_flags0 |= k_Order_UnitPretest_CanAttack_Bit;
                break;
            case k_Token_Order_UnitPretest_CanEntrench:
                m_flags0 |= k_Order_UnitPretest_CanEntrench_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSueFranchise:
                m_flags0 |= k_Order_UnitPretest_CanSueFranchise_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSue:
                m_flags0 |= k_Order_UnitPretest_CanSue_Bit;
                break;
            case k_Token_Order_UnitPretest_CanCreateFranchise:
                m_flags0 |= k_Order_UnitPretest_CanCreateFranchise_Bit;
                break;
            case k_Token_Order_UnitPretest_CanInvestigateCity:
                m_flags0 |= k_Order_UnitPretest_CanInvestigateCity_Bit;
                break;
            case k_Token_Order_UnitPretest_CanBombard:
                m_flags0 |= k_Order_UnitPretest_CanBombard_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSettle:
                m_flags0 |= k_Order_UnitPretest_CanSettle_Bit;
                break;
            case k_Token_Order_UnitPretest_CanStealTechnology:
                m_flags0 |= k_Order_UnitPretest_CanStealTechnology_Bit;
                break;
            case k_Token_Order_UnitPretest_CanInciteRevolution:
                m_flags0 |= k_Order_UnitPretest_CanInciteRevolution_Bit;
                break;
            case k_Token_Order_UnitPretest_CanAssassinateRuler:
                m_flags0 |= k_Order_UnitPretest_CanAssassinateRuler_Bit;
                break;
            case k_Token_Order_UnitPretest_CanExpel:
                m_flags0 |= k_Order_UnitPretest_CanExpel_Bit;
                break;
            case k_Token_Order_UnitPretest_EstablishEmbassy:
                m_flags0 |= k_Order_UnitPretest_EstablishEmbassy_Bit;
                break;
            case k_Token_Order_UnitPretest_ThrowParty:
                m_flags0 |= k_Order_UnitPretest_ThrowParty_Bit;
                break;
            case k_Token_Order_UnitPretest_CanCauseUnhappiness:
                m_flags0 |= k_Order_UnitPretest_CanCauseUnhappiness_Bit;
                break;
            case k_Token_Order_UnitPretest_CanPlantNuke:
                m_flags0 |= k_Order_UnitPretest_CanPlantNuke_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSlaveRaid:
                m_flags0 |= k_Order_UnitPretest_CanSlaveRaid_Bit;
                break;
            case k_Token_Order_UnitPretest_CanEnslaveSettler:
                m_flags0 |= k_Order_UnitPretest_CanEnslaveSettler_Bit;
                break;
            case k_Token_Order_UnitPretest_CanUndergroundRailway:
                m_flags0 |= k_Order_UnitPretest_CanUndergroundRailway_Bit;
                break;
            case k_Token_Order_UnitPretest_CanInciteUprising:
                m_flags0 |= k_Order_UnitPretest_CanInciteUprising_Bit;
                break;
            case k_Token_Order_UnitPretest_CanBioTerror:
                m_flags0 |= k_Order_UnitPretest_CanBioTerror_Bit;
                break;
            case k_Token_Order_UnitPretest_CanPlague:
                m_flags0 |= k_Order_UnitPretest_CanPlague_Bit;
                break;
            case k_Token_Order_UnitPretest_CanNanoInfect:
                m_flags0 |= k_Order_UnitPretest_CanNanoInfect_Bit;
                break;
            case k_Token_Order_UnitPretest_CanConvertCity:
                m_flags0 |= k_Order_UnitPretest_CanConvertCity_Bit;
                break;
            case k_Token_Order_UnitPretest_CanReformCity:
                m_flags0 |= k_Order_UnitPretest_CanReformCity_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSellIndulgences:
                m_flags0 |= k_Order_UnitPretest_CanSellIndulgences_Bit;
                break;
            case k_Token_Order_UnitPretest_CanFaithHeal:
                m_flags0 |= k_Order_UnitPretest_CanFaithHeal_Bit;
                break;
            case k_Token_Order_UnitPretest_CanSoothsay:
                m_flags0 |= k_Order_UnitPretest_CanSoothsay_Bit;
                break;
            case k_Token_Order_UnitPretest_CanCreatePark:
                m_flags0 |= k_Order_UnitPretest_CanCreatePark_Bit;
                break;
            case k_Token_Order_UnitPretest_CanPillage:
                m_flags0 |= k_Order_UnitPretest_CanPillage_Bit;
                break;
            case k_Token_Order_UnitPretest_CanInjoin:
                m_flags0 |= k_Order_UnitPretest_CanInjoin_Bit;
                break;
            case k_Token_Order_UnitPretest_CanInterceptTrade:
                m_flags1 |= k_Order_UnitPretest_CanInterceptTrade_Bit;
                break;
            case k_Token_Order_UnitPretest_CanAdvertise:
                m_flags1 |= k_Order_UnitPretest_CanAdvertise_Bit;
                break;
            case k_Token_Order_UnitPretest_CanNukeCity:
                m_flags1 |= k_Order_UnitPretest_CanNukeCity_Bit;
                break;
            case k_Token_Order_UnitPretest_CanTransport:
                m_flags1 |= k_Order_UnitPretest_CanTransport_Bit;
                break;
            case k_Token_Order_UnitPretest_CanBeTransported:
                m_flags1 |= k_Order_UnitPretest_CanBeTransported_Bit;
                break;
            case k_Token_Order_UnitPretest_CanLaunch:
                m_flags1 |= k_Order_UnitPretest_CanLaunch_Bit;
                break;
            case k_Token_Order_UnitPretest_CanTarget:
                m_flags1 |= k_Order_UnitPretest_CanTarget_Bit;
                break;
            case k_Token_Order_UnitPretest_Invalid:
                m_flags1 |= k_Order_UnitPretest_Invalid_Bit;
                break;
            case k_Token_Order_Range:
                m_flags1 |= k_Order_Range_Bit;
                if(!lex->GetIntAssignment(m_RangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_IsTeleport:
                m_flags1 |= k_Order_IsTeleport_Bit;
                break;
            case k_Token_Order_IsTarget:
                m_flags1 |= k_Order_IsTarget_Bit;
                break;
            case k_Token_Order_GLHidden:
                m_flags1 |= k_Order_GLHidden_Bit;
                break;
            case k_Token_Order_CPIcon:
                if(!lex->GetFileAssignment(m_CPIcon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Order_DefaultIcon:
                if(!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Order_ButtonLocation:
                if(!lex->GetIntAssignment(m_ButtonLocation)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_Cursor:
                if(!lex->GetIntAssignment(m_Cursor)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_InvalidCursor:
                if(!lex->GetIntAssignment(m_InvalidCursor)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_FailSound:
                m_flags1 |= k_Order_FailSound_Bit;
                if(!lex->GetIntAssignment(m_FailSoundValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Order_Sound:
                m_flags1 |= k_Order_Sound_Bit;
                if(!lex->GetIntAssignment(m_SoundValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void OrderRecord::ResolveDBReferences()
{
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
static char *s_Order_TargetPretest_BitNames[] = {
    "None",
    "EnemyCity",
    "OwnCity",
    "EnemyArmy",
    "EnemySpecialUnit",
    "EnemySettler",
    "EnemyTradeUnit",
    "TradeRoute",
    "TerrainImprovement",
    "MovePosition",
    "AttackPosition",
    "Transport",
    "AdjacentPosition",
};
#define k_Order_TargetPretest_Num_BitNames 13

sint32 OrderRecord::ParseTargetPretestBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Order_TargetPretest_BitNames, k_Order_TargetPretest_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of TargetPretest", lex->GetTokenText()));
        return 0;
    }
    m_TargetPretest |= (1 << bitindex);
    return 1;
}

void OrderRecord::Merge(const OrderRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if(rval.m_TargetPretest != 0x0) 
		m_TargetPretest = rval.m_TargetPretest; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Order_Range_Bit) != 0) 
		m_RangeValue = rval.m_RangeValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Order_FailSound_Bit) != 0) 
		m_FailSoundValue = rval.m_FailSoundValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Order_Sound_Bit) != 0) 
		m_SoundValue = rval.m_SoundValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const IconRecord *OrderRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

