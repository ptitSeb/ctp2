
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "StrategyRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "StrategyRecord.h"
#include "GovernmentRecord.h"
#include "ImprovementListRecord.h"
#include "ImprovementListRecord.h"
#include "ImprovementListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "UnitBuildListRecord.h"
#include "AdvanceListRecord.h"
#include "AdvanceListRecord.h"
#include "GoalRecord.h"
#include "BuildListSequenceRecord.h"

CTPDatabase<StrategyRecord> *g_theStrategyDB = NULL;

StrategyRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    memset(m_Inherit, 0, sizeof(m_Inherit));
    m_numInherit = 0;
    m_PopAssignmentElement = NULL;
    m_numPopAssignmentElement = 0;
    m_Government = NULL;
    m_numGovernment = 0;
    m_MinimumHappinessValue = 0;
    m_DeficitSpendingValue = 0.0;
    m_MaximumWagePercentValue = 0.0;
    m_SliderElement = NULL;
    m_numSliderElement = 0;
    m_SciencePercentValue = 0;
    m_MaxSupportCostPercentValue = 0;
    m_ReadinessLevelValue = 0;
    m_PublicWorksPercentValue = 0;
    m_PublicWorksReserveValue = 0;
    m_MaxEvalTileImprovementsValue = 0;
    m_TimeToFixRoadsValue = 0;
    m_TimeToFixPollutionValue = 0;
    m_FixPollutionThresholdValue = 0;
    m_RoadUtilityBonusValue = 0.0;
    m_ImproveProductionBonusValue = 0.0;
    m_ImproveGrowthBonusValue = 0.0;
    m_ImproveGoodBonusValue = 0.0;
    m_ImproveSmallCityGrowthBonusValue = 0.0;
    m_ImproveLargeCityProductionBonusValue = 0.0;
    m_ImproveGrowthList = 0x7fffffff;
    m_ImproveProductionList = 0x7fffffff;
    m_ImproveRandomList = 0x7fffffff;
    m_GoalElement = NULL;
    m_numGoalElement = 0;
    m_DistanceModifierFactorValue = 0;
    m_DisbandArmyCountValue = 0;
    m_MinSettleDistanceValue = 0;
    m_MinSettleScoreValue = 0;
    m_RushBuyThreatBonusValue = 0;
    m_RushBuyReservePercentValue = 0.0;
    m_UnitSupportPercentValue = 0.0;
    m_MaxSettlerBuildTurnsValue = 0;
    m_MaxUnitBuildTurnsValue = 0;
    m_MaxWonderBuildTurnsValue = 0;
    m_BuildTransportProductionLevelValue = 0.0;
    m_BuildSettlerProductionLevelValue = 0.0;
    m_OffensiveUnitsPercentValue = 0.0;
    m_DefensiveUnitsPercentValue = 0.0;
    m_RangedUnitsPercentValue = 0.0;
    m_SeaUnitsPercentValue = 0.0;
    m_AirUnitsPercentValue = 0.0;
    m_SettlerUnitsCountValue = 0;
    m_SpecialUnitsCountValue = 0;
    m_SeaTransportUnitsCountValue = 0;
    m_AirTransportUnitsCountValue = 0;
    m_OffensiveUnitListValue = 0;
    m_DefensiveUnitListValue = 0;
    m_RangedUnitListValue = 0;
    m_SeaUnitListValue = 0;
    m_AirUnitListValue = 0;
    m_SettlerUnitListValue = 0;
    m_SpecialUnitListValue = 0;
    m_SeaTransportUnitListValue = 0;
    m_AirTransportUnitListValue = 0;
    m_FreightUnitListValue = 0;
    m_OffensiveGarrisonCountValue = 0;
    m_DefensiveGarrisonCountValue = 0;
    m_RangedGarrisonCountValue = 0;
    m_BuildListSequenceElement = NULL;
    m_numBuildListSequenceElement = 0;
    m_ResearchValue = 0;
    m_StopResearchValue = 0;
    m_FearInvasionValue = 0;
    m_FearCityDefenseValue = 0;
    m_FearPiracyValue = 0;
    m_FearScienceRankValue = 0;
    m_FearMilitaryRankValue = 0;
    m_FearTradeRankValue = 0;
    m_FearPollutionValue = 0;
    m_DesireAttackValue = 0;
    m_DesireGoldValue = 0;
    m_DesireScienceValue = 0;
    m_DesireMakeFriendValue = 0;
    m_DesireEnlistFriendValue = 0;
    m_PiracyMemoryTurnsValue = 0;
    m_MaxPiracyEventsValue = 0;
    memset(&m_OffensiveValue, 0, sizeof(m_OffensiveValue));
    memset(&m_DefensiveValue, 0, sizeof(m_DefensiveValue));
    memset(&m_StealthAttackValue, 0, sizeof(m_StealthAttackValue));
    memset(&m_BombardValue, 0, sizeof(m_BombardValue));
    memset(&m_SpecialValue, 0, sizeof(m_SpecialValue));
    memset(&m_HarassValue, 0, sizeof(m_HarassValue));
    m_NuclearFirstStrike = 0;
    m_NuclearTargeting = 0;
    m_PreemptiveStrikeRegardValue = 0;
    m_PreemptiveStrikeRiskRatioValue = 0.0;
    m_PreemptiveStrikeSuperiorityRatioValue = 0.0;
}

StrategyRecord::~StrategyRecord()
{
	int index = 0;
	// free array PopAssignmentElement 
 			// free struct elements
	if (m_numPopAssignmentElement > 0) 
		delete [m_numPopAssignmentElement] m_PopAssignmentElement; 
	m_PopAssignmentElement = NULL; 
	m_numPopAssignmentElement = 0; 

	// free array Government 
 	if (m_numGovernment > 0) 
		delete [m_numGovernment] m_Government; 
	m_Government = NULL; 
	m_numGovernment = 0; 

	// free array SliderElement 
 			// free struct elements
	if (m_numSliderElement > 0) 
		delete [m_numSliderElement] m_SliderElement; 
	m_SliderElement = NULL; 
	m_numSliderElement = 0; 

	// free array GoalElement 
 			// free struct elements
	if (m_numGoalElement > 0) 
		delete [m_numGoalElement] m_GoalElement; 
	m_GoalElement = NULL; 
	m_numGoalElement = 0; 

	// free array BuildListSequenceElement 
 			// free struct elements
	if (m_numBuildListSequenceElement > 0) 
		delete [m_numBuildListSequenceElement] m_BuildListSequenceElement; 
	m_BuildListSequenceElement = NULL; 
	m_numBuildListSequenceElement = 0; 

}

void StrategyRecord::operator=(const StrategyRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	// copy fixed sized array Inherit[] 
 		memcpy(m_Inherit, rval.m_Inherit, sizeof(sint32)*rval.m_numInherit); 

	// free array PopAssignmentElement 
 	// free struct elements of PopAssignmentElement[]
	if (m_numPopAssignmentElement > 0) 
	{
		delete [m_numPopAssignmentElement] m_PopAssignmentElement; 
		m_PopAssignmentElement = NULL; 
	}

	if (rval.m_numPopAssignmentElement > 0) 
	{
		m_PopAssignmentElement = new PopAssignmentElement [rval.m_numPopAssignmentElement];
	}

	// copy struct elements of PopAssignmentElement[]
	for (index = 0; index < rval.m_numPopAssignmentElement; index++) 
		{ 
			m_PopAssignmentElement[index] = rval.m_PopAssignmentElement[index]; 
	} 
	m_numPopAssignmentElement = rval.m_numPopAssignmentElement;

	// free array Government 
 	if (m_numGovernment > 0) 
	{
		delete [m_numGovernment] m_Government; 
		m_Government = NULL; 
		m_numGovernment = 0; 
	}
	if (rval.m_numGovernment > 0) 
	{
		m_Government = new sint32 [rval.m_numGovernment]; 
		memcpy(m_Government, rval.m_Government, sizeof(sint32)*rval.m_numGovernment); 

	} 
	m_numGovernment = rval.m_numGovernment;

	m_flags0 = rval.m_flags0; 
		m_MinimumHappinessValue = rval.m_MinimumHappinessValue; 

	m_flags0 = rval.m_flags0; 
		m_DeficitSpendingValue = rval.m_DeficitSpendingValue; 

	m_flags0 = rval.m_flags0; 
		m_MaximumWagePercentValue = rval.m_MaximumWagePercentValue; 

	// free array SliderElement 
 	// free struct elements of SliderElement[]
	if (m_numSliderElement > 0) 
	{
		delete [m_numSliderElement] m_SliderElement; 
		m_SliderElement = NULL; 
	}

	if (rval.m_numSliderElement > 0) 
	{
		m_SliderElement = new SliderElement [rval.m_numSliderElement];
	}

	// copy struct elements of SliderElement[]
	for (index = 0; index < rval.m_numSliderElement; index++) 
		{ 
			m_SliderElement[index] = rval.m_SliderElement[index]; 
	} 
	m_numSliderElement = rval.m_numSliderElement;

	m_flags0 = rval.m_flags0; 
		m_SciencePercentValue = rval.m_SciencePercentValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxSupportCostPercentValue = rval.m_MaxSupportCostPercentValue; 

	m_flags0 = rval.m_flags0; 
		m_ReadinessLevelValue = rval.m_ReadinessLevelValue; 

	m_flags0 = rval.m_flags0; 
		m_PublicWorksPercentValue = rval.m_PublicWorksPercentValue; 

	m_flags0 = rval.m_flags0; 
		m_PublicWorksReserveValue = rval.m_PublicWorksReserveValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxEvalTileImprovementsValue = rval.m_MaxEvalTileImprovementsValue; 

	m_flags0 = rval.m_flags0; 
		m_TimeToFixRoadsValue = rval.m_TimeToFixRoadsValue; 

	m_flags0 = rval.m_flags0; 
		m_TimeToFixPollutionValue = rval.m_TimeToFixPollutionValue; 

	m_flags0 = rval.m_flags0; 
		m_FixPollutionThresholdValue = rval.m_FixPollutionThresholdValue; 

	m_flags0 = rval.m_flags0; 
		m_RoadUtilityBonusValue = rval.m_RoadUtilityBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_ImproveProductionBonusValue = rval.m_ImproveProductionBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_ImproveGrowthBonusValue = rval.m_ImproveGrowthBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_ImproveGoodBonusValue = rval.m_ImproveGoodBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_ImproveSmallCityGrowthBonusValue = rval.m_ImproveSmallCityGrowthBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_ImproveLargeCityProductionBonusValue = rval.m_ImproveLargeCityProductionBonusValue; 

	m_ImproveGrowthList = rval.m_ImproveGrowthList; 

	m_ImproveProductionList = rval.m_ImproveProductionList; 

	m_ImproveRandomList = rval.m_ImproveRandomList; 

	// free array GoalElement 
 	// free struct elements of GoalElement[]
	if (m_numGoalElement > 0) 
	{
		delete [m_numGoalElement] m_GoalElement; 
		m_GoalElement = NULL; 
	}

	if (rval.m_numGoalElement > 0) 
	{
		m_GoalElement = new GoalElement [rval.m_numGoalElement];
	}

	// copy struct elements of GoalElement[]
	for (index = 0; index < rval.m_numGoalElement; index++) 
		{ 
			m_GoalElement[index] = rval.m_GoalElement[index]; 
	} 
	m_numGoalElement = rval.m_numGoalElement;

	m_flags0 = rval.m_flags0; 
		m_DistanceModifierFactorValue = rval.m_DistanceModifierFactorValue; 

	m_flags0 = rval.m_flags0; 
		m_DisbandArmyCountValue = rval.m_DisbandArmyCountValue; 

	m_flags0 = rval.m_flags0; 
		m_MinSettleDistanceValue = rval.m_MinSettleDistanceValue; 

	m_flags0 = rval.m_flags0; 
		m_MinSettleScoreValue = rval.m_MinSettleScoreValue; 

	m_flags0 = rval.m_flags0; 
		m_RushBuyThreatBonusValue = rval.m_RushBuyThreatBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_RushBuyReservePercentValue = rval.m_RushBuyReservePercentValue; 

	m_flags0 = rval.m_flags0; 
		m_UnitSupportPercentValue = rval.m_UnitSupportPercentValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxSettlerBuildTurnsValue = rval.m_MaxSettlerBuildTurnsValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxUnitBuildTurnsValue = rval.m_MaxUnitBuildTurnsValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxWonderBuildTurnsValue = rval.m_MaxWonderBuildTurnsValue; 

	m_flags0 = rval.m_flags0; 
		m_BuildTransportProductionLevelValue = rval.m_BuildTransportProductionLevelValue; 

	m_flags0 = rval.m_flags0; 
		m_BuildSettlerProductionLevelValue = rval.m_BuildSettlerProductionLevelValue; 

	m_flags0 = rval.m_flags0; 
		m_OffensiveUnitsPercentValue = rval.m_OffensiveUnitsPercentValue; 

	m_flags0 = rval.m_flags0; 
		m_DefensiveUnitsPercentValue = rval.m_DefensiveUnitsPercentValue; 

	m_flags1 = rval.m_flags1; 
		m_RangedUnitsPercentValue = rval.m_RangedUnitsPercentValue; 

	m_flags1 = rval.m_flags1; 
		m_SeaUnitsPercentValue = rval.m_SeaUnitsPercentValue; 

	m_flags1 = rval.m_flags1; 
		m_AirUnitsPercentValue = rval.m_AirUnitsPercentValue; 

	m_flags1 = rval.m_flags1; 
		m_SettlerUnitsCountValue = rval.m_SettlerUnitsCountValue; 

	m_flags1 = rval.m_flags1; 
		m_SpecialUnitsCountValue = rval.m_SpecialUnitsCountValue; 

	m_flags1 = rval.m_flags1; 
		m_SeaTransportUnitsCountValue = rval.m_SeaTransportUnitsCountValue; 

	m_flags1 = rval.m_flags1; 
		m_AirTransportUnitsCountValue = rval.m_AirTransportUnitsCountValue; 

	m_flags1 = rval.m_flags1; 
		m_OffensiveUnitListValue = rval.m_OffensiveUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_DefensiveUnitListValue = rval.m_DefensiveUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_RangedUnitListValue = rval.m_RangedUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_SeaUnitListValue = rval.m_SeaUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_AirUnitListValue = rval.m_AirUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_SettlerUnitListValue = rval.m_SettlerUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_SpecialUnitListValue = rval.m_SpecialUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_SeaTransportUnitListValue = rval.m_SeaTransportUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_AirTransportUnitListValue = rval.m_AirTransportUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_FreightUnitListValue = rval.m_FreightUnitListValue; 

	m_flags1 = rval.m_flags1; 
		m_OffensiveGarrisonCountValue = rval.m_OffensiveGarrisonCountValue; 

	m_flags1 = rval.m_flags1; 
		m_DefensiveGarrisonCountValue = rval.m_DefensiveGarrisonCountValue; 

	m_flags1 = rval.m_flags1; 
		m_RangedGarrisonCountValue = rval.m_RangedGarrisonCountValue; 

	// free array BuildListSequenceElement 
 	// free struct elements of BuildListSequenceElement[]
	if (m_numBuildListSequenceElement > 0) 
	{
		delete [m_numBuildListSequenceElement] m_BuildListSequenceElement; 
		m_BuildListSequenceElement = NULL; 
	}

	if (rval.m_numBuildListSequenceElement > 0) 
	{
		m_BuildListSequenceElement = new BuildListSequenceElement [rval.m_numBuildListSequenceElement];
	}

	// copy struct elements of BuildListSequenceElement[]
	for (index = 0; index < rval.m_numBuildListSequenceElement; index++) 
		{ 
			m_BuildListSequenceElement[index] = rval.m_BuildListSequenceElement[index]; 
	} 
	m_numBuildListSequenceElement = rval.m_numBuildListSequenceElement;

	m_flags1 = rval.m_flags1; 
		m_ResearchValue = rval.m_ResearchValue; 

	m_flags1 = rval.m_flags1; 
		m_StopResearchValue = rval.m_StopResearchValue; 

	m_flags1 = rval.m_flags1; 
		m_FearInvasionValue = rval.m_FearInvasionValue; 

	m_flags1 = rval.m_flags1; 
		m_FearCityDefenseValue = rval.m_FearCityDefenseValue; 

	m_flags1 = rval.m_flags1; 
		m_FearPiracyValue = rval.m_FearPiracyValue; 

	m_flags1 = rval.m_flags1; 
		m_FearScienceRankValue = rval.m_FearScienceRankValue; 

	m_flags1 = rval.m_flags1; 
		m_FearMilitaryRankValue = rval.m_FearMilitaryRankValue; 

	m_flags1 = rval.m_flags1; 
		m_FearTradeRankValue = rval.m_FearTradeRankValue; 

	m_flags1 = rval.m_flags1; 
		m_FearPollutionValue = rval.m_FearPollutionValue; 

	m_flags1 = rval.m_flags1; 
		m_DesireAttackValue = rval.m_DesireAttackValue; 

	m_flags1 = rval.m_flags1; 
		m_DesireGoldValue = rval.m_DesireGoldValue; 

	m_flags1 = rval.m_flags1; 
		m_DesireScienceValue = rval.m_DesireScienceValue; 

	m_flags2 = rval.m_flags2; 
		m_DesireMakeFriendValue = rval.m_DesireMakeFriendValue; 

	m_flags2 = rval.m_flags2; 
		m_DesireEnlistFriendValue = rval.m_DesireEnlistFriendValue; 

	m_flags2 = rval.m_flags2; 
		m_PiracyMemoryTurnsValue = rval.m_PiracyMemoryTurnsValue; 

	m_flags2 = rval.m_flags2; 
		m_MaxPiracyEventsValue = rval.m_MaxPiracyEventsValue; 

	m_flags2 = rval.m_flags2; 
		m_OffensiveValue = rval.m_OffensiveValue; 

	m_flags2 = rval.m_flags2; 
		m_DefensiveValue = rval.m_DefensiveValue; 

	m_flags2 = rval.m_flags2; 
		m_StealthAttackValue = rval.m_StealthAttackValue; 

	m_flags2 = rval.m_flags2; 
		m_BombardValue = rval.m_BombardValue; 

	m_flags2 = rval.m_flags2; 
		m_SpecialValue = rval.m_SpecialValue; 

	m_flags2 = rval.m_flags2; 
		m_HarassValue = rval.m_HarassValue; 

	m_NuclearFirstStrike = rval.m_NuclearFirstStrike; 

	m_NuclearTargeting = rval.m_NuclearTargeting; 

	m_flags2 = rval.m_flags2; 
		m_PreemptiveStrikeRegardValue = rval.m_PreemptiveStrikeRegardValue; 

	m_flags2 = rval.m_flags2; 
		m_PreemptiveStrikeRiskRatioValue = rval.m_PreemptiveStrikeRiskRatioValue; 

	m_flags2 = rval.m_flags2; 
		m_PreemptiveStrikeSuperiorityRatioValue = rval.m_PreemptiveStrikeSuperiorityRatioValue; 

}

char *g_Strategy_Tokens[] =
{
    "Inherit",
    "PopAssignmentElement",
    "Government",
    "MinimumHappiness",
    "MinimumHappinessValue",
    "DeficitSpending",
    "DeficitSpendingValue",
    "MaximumWagePercent",
    "MaximumWagePercentValue",
    "SliderElement",
    "SciencePercent",
    "SciencePercentValue",
    "MaxSupportCostPercent",
    "MaxSupportCostPercentValue",
    "ReadinessLevel",
    "ReadinessLevelValue",
    "PublicWorksPercent",
    "PublicWorksPercentValue",
    "PublicWorksReserve",
    "PublicWorksReserveValue",
    "MaxEvalTileImprovements",
    "MaxEvalTileImprovementsValue",
    "TimeToFixRoads",
    "TimeToFixRoadsValue",
    "TimeToFixPollution",
    "TimeToFixPollutionValue",
    "FixPollutionThreshold",
    "FixPollutionThresholdValue",
    "RoadUtilityBonus",
    "RoadUtilityBonusValue",
    "ImproveProductionBonus",
    "ImproveProductionBonusValue",
    "ImproveGrowthBonus",
    "ImproveGrowthBonusValue",
    "ImproveGoodBonus",
    "ImproveGoodBonusValue",
    "ImproveSmallCityGrowthBonus",
    "ImproveSmallCityGrowthBonusValue",
    "ImproveLargeCityProductionBonus",
    "ImproveLargeCityProductionBonusValue",
    "ImproveGrowthList",
    "ImproveProductionList",
    "ImproveRandomList",
    "GoalElement",
    "DistanceModifierFactor",
    "DistanceModifierFactorValue",
    "DisbandArmyCount",
    "DisbandArmyCountValue",
    "MinSettleDistance",
    "MinSettleDistanceValue",
    "MinSettleScore",
    "MinSettleScoreValue",
    "RushBuyThreatBonus",
    "RushBuyThreatBonusValue",
    "RushBuyReservePercent",
    "RushBuyReservePercentValue",
    "UnitSupportPercent",
    "UnitSupportPercentValue",
    "MaxSettlerBuildTurns",
    "MaxSettlerBuildTurnsValue",
    "MaxUnitBuildTurns",
    "MaxUnitBuildTurnsValue",
    "MaxWonderBuildTurns",
    "MaxWonderBuildTurnsValue",
    "BuildTransportProductionLevel",
    "BuildTransportProductionLevelValue",
    "BuildSettlerProductionLevel",
    "BuildSettlerProductionLevelValue",
    "OffensiveUnitsPercent",
    "OffensiveUnitsPercentValue",
    "DefensiveUnitsPercent",
    "DefensiveUnitsPercentValue",
    "RangedUnitsPercent",
    "RangedUnitsPercentValue",
    "SeaUnitsPercent",
    "SeaUnitsPercentValue",
    "AirUnitsPercent",
    "AirUnitsPercentValue",
    "SettlerUnitsCount",
    "SettlerUnitsCountValue",
    "SpecialUnitsCount",
    "SpecialUnitsCountValue",
    "SeaTransportUnitsCount",
    "SeaTransportUnitsCountValue",
    "AirTransportUnitsCount",
    "AirTransportUnitsCountValue",
    "OffensiveUnitList",
    "OffensiveUnitListValue",
    "DefensiveUnitList",
    "DefensiveUnitListValue",
    "RangedUnitList",
    "RangedUnitListValue",
    "SeaUnitList",
    "SeaUnitListValue",
    "AirUnitList",
    "AirUnitListValue",
    "SettlerUnitList",
    "SettlerUnitListValue",
    "SpecialUnitList",
    "SpecialUnitListValue",
    "SeaTransportUnitList",
    "SeaTransportUnitListValue",
    "AirTransportUnitList",
    "AirTransportUnitListValue",
    "FreightUnitList",
    "FreightUnitListValue",
    "OffensiveGarrisonCount",
    "OffensiveGarrisonCountValue",
    "DefensiveGarrisonCount",
    "DefensiveGarrisonCountValue",
    "RangedGarrisonCount",
    "RangedGarrisonCountValue",
    "BuildListSequenceElement",
    "Research",
    "ResearchValue",
    "StopResearch",
    "StopResearchValue",
    "FearInvasion",
    "FearInvasionValue",
    "FearCityDefense",
    "FearCityDefenseValue",
    "FearPiracy",
    "FearPiracyValue",
    "FearScienceRank",
    "FearScienceRankValue",
    "FearMilitaryRank",
    "FearMilitaryRankValue",
    "FearTradeRank",
    "FearTradeRankValue",
    "FearPollution",
    "FearPollutionValue",
    "DesireAttack",
    "DesireAttackValue",
    "DesireGold",
    "DesireGoldValue",
    "DesireScience",
    "DesireScienceValue",
    "DesireMakeFriend",
    "DesireMakeFriendValue",
    "DesireEnlistFriend",
    "DesireEnlistFriendValue",
    "PiracyMemoryTurns",
    "PiracyMemoryTurnsValue",
    "MaxPiracyEvents",
    "MaxPiracyEventsValue",
    "Offensive",
    "OffensiveValue",
    "Defensive",
    "DefensiveValue",
    "StealthAttack",
    "StealthAttackValue",
    "Bombard",
    "BombardValue",
    "Special",
    "SpecialValue",
    "Harass",
    "HarassValue",
    "NuclearFirstStrike",
    "NuclearTargeting",
    "PreemptiveStrikeRegard",
    "PreemptiveStrikeRegardValue",
    "PreemptiveStrikeRiskRatio",
    "PreemptiveStrikeRiskRatioValue",
    "PreemptiveStrikeSuperiorityRatio",
    "PreemptiveStrikeSuperiorityRatioValue",
};

StrategyRecordAccessorInfo g_StrategyRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Inherit (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* PopAssignmentElement */
    { NULL, NULL, NULL, NULL, NULL}, /* Government (array) */
    { NULL, NULL, NULL, StrategyRecord::GetMinimumHappiness, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinimumHappiness */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetDeficitSpending},
    { NULL, NULL, NULL, NULL, NULL}, /* DeficitSpending */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetMaximumWagePercent},
    { NULL, NULL, NULL, NULL, NULL}, /* MaximumWagePercent */
    { NULL, NULL, NULL, NULL, NULL}, /* SliderElement */
    { NULL, NULL, NULL, StrategyRecord::GetSciencePercent, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SciencePercent */
    { NULL, NULL, NULL, StrategyRecord::GetMaxSupportCostPercent, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxSupportCostPercent */
    { NULL, NULL, NULL, StrategyRecord::GetReadinessLevel, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ReadinessLevel */
    { NULL, NULL, NULL, StrategyRecord::GetPublicWorksPercent, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PublicWorksPercent */
    { NULL, NULL, NULL, StrategyRecord::GetPublicWorksReserve, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PublicWorksReserve */
    { NULL, NULL, NULL, StrategyRecord::GetMaxEvalTileImprovements, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxEvalTileImprovements */
    { NULL, NULL, NULL, StrategyRecord::GetTimeToFixRoads, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* TimeToFixRoads */
    { NULL, NULL, NULL, StrategyRecord::GetTimeToFixPollution, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* TimeToFixPollution */
    { NULL, NULL, NULL, StrategyRecord::GetFixPollutionThreshold, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FixPollutionThreshold */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetRoadUtilityBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* RoadUtilityBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetImproveProductionBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* ImproveProductionBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetImproveGrowthBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* ImproveGrowthBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetImproveGoodBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* ImproveGoodBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetImproveSmallCityGrowthBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* ImproveSmallCityGrowthBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetImproveLargeCityProductionBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* ImproveLargeCityProductionBonus */
    {StrategyRecord::GetImproveGrowthListIndex, NULL, NULL, NULL, NULL },
    {StrategyRecord::GetImproveProductionListIndex, NULL, NULL, NULL, NULL },
    {StrategyRecord::GetImproveRandomListIndex, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* GoalElement */
    { NULL, NULL, NULL, StrategyRecord::GetDistanceModifierFactor, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DistanceModifierFactor */
    { NULL, NULL, NULL, StrategyRecord::GetDisbandArmyCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DisbandArmyCount */
    { NULL, NULL, NULL, StrategyRecord::GetMinSettleDistance, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinSettleDistance */
    { NULL, NULL, NULL, StrategyRecord::GetMinSettleScore, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinSettleScore */
    { NULL, NULL, NULL, StrategyRecord::GetRushBuyThreatBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* RushBuyThreatBonus */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetRushBuyReservePercent},
    { NULL, NULL, NULL, NULL, NULL}, /* RushBuyReservePercent */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetUnitSupportPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* UnitSupportPercent */
    { NULL, NULL, NULL, StrategyRecord::GetMaxSettlerBuildTurns, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxSettlerBuildTurns */
    { NULL, NULL, NULL, StrategyRecord::GetMaxUnitBuildTurns, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxUnitBuildTurns */
    { NULL, NULL, NULL, StrategyRecord::GetMaxWonderBuildTurns, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxWonderBuildTurns */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetBuildTransportProductionLevel},
    { NULL, NULL, NULL, NULL, NULL}, /* BuildTransportProductionLevel */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetBuildSettlerProductionLevel},
    { NULL, NULL, NULL, NULL, NULL}, /* BuildSettlerProductionLevel */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetOffensiveUnitsPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* OffensiveUnitsPercent */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetDefensiveUnitsPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* DefensiveUnitsPercent */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetRangedUnitsPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* RangedUnitsPercent */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetSeaUnitsPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* SeaUnitsPercent */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetAirUnitsPercent},
    { NULL, NULL, NULL, NULL, NULL}, /* AirUnitsPercent */
    { NULL, NULL, NULL, StrategyRecord::GetSettlerUnitsCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SettlerUnitsCount */
    { NULL, NULL, NULL, StrategyRecord::GetSpecialUnitsCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SpecialUnitsCount */
    { NULL, NULL, NULL, StrategyRecord::GetSeaTransportUnitsCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SeaTransportUnitsCount */
    { NULL, NULL, NULL, StrategyRecord::GetAirTransportUnitsCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* AirTransportUnitsCount */
    { NULL, NULL, NULL, NULL, NULL}, /* OffensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* OffensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* DefensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* DefensiveUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* RangedUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* RangedUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SeaUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SeaUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* AirUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* AirUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SettlerUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SpecialUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SpecialUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SeaTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* SeaTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* AirTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* AirTransportUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* FreightUnitList */
    { NULL, NULL, NULL, NULL, NULL}, /* FreightUnitList */
    { NULL, NULL, NULL, StrategyRecord::GetOffensiveGarrisonCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* OffensiveGarrisonCount */
    { NULL, NULL, NULL, StrategyRecord::GetDefensiveGarrisonCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DefensiveGarrisonCount */
    { NULL, NULL, NULL, StrategyRecord::GetRangedGarrisonCount, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* RangedGarrisonCount */
    { NULL, NULL, NULL, NULL, NULL}, /* BuildListSequenceElement */
    { NULL, NULL, NULL, NULL, NULL}, /* Research */
    { NULL, NULL, NULL, NULL, NULL}, /* Research */
    { NULL, NULL, NULL, NULL, NULL}, /* StopResearch */
    { NULL, NULL, NULL, NULL, NULL}, /* StopResearch */
    { NULL, NULL, NULL, StrategyRecord::GetFearInvasion, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearInvasion */
    { NULL, NULL, NULL, StrategyRecord::GetFearCityDefense, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearCityDefense */
    { NULL, NULL, NULL, StrategyRecord::GetFearPiracy, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearPiracy */
    { NULL, NULL, NULL, StrategyRecord::GetFearScienceRank, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearScienceRank */
    { NULL, NULL, NULL, StrategyRecord::GetFearMilitaryRank, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearMilitaryRank */
    { NULL, NULL, NULL, StrategyRecord::GetFearTradeRank, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearTradeRank */
    { NULL, NULL, NULL, StrategyRecord::GetFearPollution, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FearPollution */
    { NULL, NULL, NULL, StrategyRecord::GetDesireAttack, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DesireAttack */
    { NULL, NULL, NULL, StrategyRecord::GetDesireGold, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DesireGold */
    { NULL, NULL, NULL, StrategyRecord::GetDesireScience, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DesireScience */
    { NULL, NULL, NULL, StrategyRecord::GetDesireMakeFriend, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DesireMakeFriend */
    { NULL, NULL, NULL, StrategyRecord::GetDesireEnlistFriend, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DesireEnlistFriend */
    { NULL, NULL, NULL, StrategyRecord::GetPiracyMemoryTurns, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PiracyMemoryTurns */
    { NULL, NULL, NULL, StrategyRecord::GetMaxPiracyEvents, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxPiracyEvents */
    { NULL, NULL, NULL, NULL, NULL}, /* Offensive */
    { NULL, NULL, NULL, NULL, NULL}, /* Offensive */
    { NULL, NULL, NULL, NULL, NULL}, /* Defensive */
    { NULL, NULL, NULL, NULL, NULL}, /* Defensive */
    { NULL, NULL, NULL, NULL, NULL}, /* StealthAttack */
    { NULL, NULL, NULL, NULL, NULL}, /* StealthAttack */
    { NULL, NULL, NULL, NULL, NULL}, /* Bombard */
    { NULL, NULL, NULL, NULL, NULL}, /* Bombard */
    { NULL, NULL, NULL, NULL, NULL}, /* Special */
    { NULL, NULL, NULL, NULL, NULL}, /* Special */
    { NULL, NULL, NULL, NULL, NULL}, /* Harass */
    { NULL, NULL, NULL, NULL, NULL}, /* Harass */
    { NULL, NULL, NULL, NULL, NULL}, /* NuclearFirstStrike */
    { NULL, NULL, NULL, NULL, NULL}, /* NuclearTargeting */
    { NULL, NULL, NULL, StrategyRecord::GetPreemptiveStrikeRegard, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PreemptiveStrikeRegard */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetPreemptiveStrikeRiskRatio},
    { NULL, NULL, NULL, NULL, NULL}, /* PreemptiveStrikeRiskRatio */
    { NULL, NULL, NULL, NULL, StrategyRecord::GetPreemptiveStrikeSuperiorityRatio},
    { NULL, NULL, NULL, NULL, NULL}, /* PreemptiveStrikeSuperiorityRatio */
};

#define k_Token_Strategy_Inherit                 ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_PopAssignmentElement    ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_Government              ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_MinimumHappiness        ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_MinimumHappiness_Value  ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_DeficitSpending         ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_DeficitSpending_Value   ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_MaximumWagePercent      ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_MaximumWagePercent_Value ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_SliderElement           ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_SciencePercent          ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_SciencePercent_Value    ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_MaxSupportCostPercent   ((k_Token_Custom_Base) + 12)
#define k_Token_Strategy_MaxSupportCostPercent_Value ((k_Token_Custom_Base) + 13)
#define k_Token_Strategy_ReadinessLevel          ((k_Token_Custom_Base) + 14)
#define k_Token_Strategy_ReadinessLevel_Value    ((k_Token_Custom_Base) + 15)
#define k_Token_Strategy_PublicWorksPercent      ((k_Token_Custom_Base) + 16)
#define k_Token_Strategy_PublicWorksPercent_Value ((k_Token_Custom_Base) + 17)
#define k_Token_Strategy_PublicWorksReserve      ((k_Token_Custom_Base) + 18)
#define k_Token_Strategy_PublicWorksReserve_Value ((k_Token_Custom_Base) + 19)
#define k_Token_Strategy_MaxEvalTileImprovements ((k_Token_Custom_Base) + 20)
#define k_Token_Strategy_MaxEvalTileImprovements_Value ((k_Token_Custom_Base) + 21)
#define k_Token_Strategy_TimeToFixRoads          ((k_Token_Custom_Base) + 22)
#define k_Token_Strategy_TimeToFixRoads_Value    ((k_Token_Custom_Base) + 23)
#define k_Token_Strategy_TimeToFixPollution      ((k_Token_Custom_Base) + 24)
#define k_Token_Strategy_TimeToFixPollution_Value ((k_Token_Custom_Base) + 25)
#define k_Token_Strategy_FixPollutionThreshold   ((k_Token_Custom_Base) + 26)
#define k_Token_Strategy_FixPollutionThreshold_Value ((k_Token_Custom_Base) + 27)
#define k_Token_Strategy_RoadUtilityBonus        ((k_Token_Custom_Base) + 28)
#define k_Token_Strategy_RoadUtilityBonus_Value  ((k_Token_Custom_Base) + 29)
#define k_Token_Strategy_ImproveProductionBonus  ((k_Token_Custom_Base) + 30)
#define k_Token_Strategy_ImproveProductionBonus_Value ((k_Token_Custom_Base) + 31)
#define k_Token_Strategy_ImproveGrowthBonus      ((k_Token_Custom_Base) + 32)
#define k_Token_Strategy_ImproveGrowthBonus_Value ((k_Token_Custom_Base) + 33)
#define k_Token_Strategy_ImproveGoodBonus        ((k_Token_Custom_Base) + 34)
#define k_Token_Strategy_ImproveGoodBonus_Value  ((k_Token_Custom_Base) + 35)
#define k_Token_Strategy_ImproveSmallCityGrowthBonus ((k_Token_Custom_Base) + 36)
#define k_Token_Strategy_ImproveSmallCityGrowthBonus_Value ((k_Token_Custom_Base) + 37)
#define k_Token_Strategy_ImproveLargeCityProductionBonus ((k_Token_Custom_Base) + 38)
#define k_Token_Strategy_ImproveLargeCityProductionBonus_Value ((k_Token_Custom_Base) + 39)
#define k_Token_Strategy_ImproveGrowthList       ((k_Token_Custom_Base) + 40)
#define k_Token_Strategy_ImproveProductionList   ((k_Token_Custom_Base) + 41)
#define k_Token_Strategy_ImproveRandomList       ((k_Token_Custom_Base) + 42)
#define k_Token_Strategy_GoalElement             ((k_Token_Custom_Base) + 43)
#define k_Token_Strategy_DistanceModifierFactor  ((k_Token_Custom_Base) + 44)
#define k_Token_Strategy_DistanceModifierFactor_Value ((k_Token_Custom_Base) + 45)
#define k_Token_Strategy_DisbandArmyCount        ((k_Token_Custom_Base) + 46)
#define k_Token_Strategy_DisbandArmyCount_Value  ((k_Token_Custom_Base) + 47)
#define k_Token_Strategy_MinSettleDistance       ((k_Token_Custom_Base) + 48)
#define k_Token_Strategy_MinSettleDistance_Value ((k_Token_Custom_Base) + 49)
#define k_Token_Strategy_MinSettleScore          ((k_Token_Custom_Base) + 50)
#define k_Token_Strategy_MinSettleScore_Value    ((k_Token_Custom_Base) + 51)
#define k_Token_Strategy_RushBuyThreatBonus      ((k_Token_Custom_Base) + 52)
#define k_Token_Strategy_RushBuyThreatBonus_Value ((k_Token_Custom_Base) + 53)
#define k_Token_Strategy_RushBuyReservePercent   ((k_Token_Custom_Base) + 54)
#define k_Token_Strategy_RushBuyReservePercent_Value ((k_Token_Custom_Base) + 55)
#define k_Token_Strategy_UnitSupportPercent      ((k_Token_Custom_Base) + 56)
#define k_Token_Strategy_UnitSupportPercent_Value ((k_Token_Custom_Base) + 57)
#define k_Token_Strategy_MaxSettlerBuildTurns    ((k_Token_Custom_Base) + 58)
#define k_Token_Strategy_MaxSettlerBuildTurns_Value ((k_Token_Custom_Base) + 59)
#define k_Token_Strategy_MaxUnitBuildTurns       ((k_Token_Custom_Base) + 60)
#define k_Token_Strategy_MaxUnitBuildTurns_Value ((k_Token_Custom_Base) + 61)
#define k_Token_Strategy_MaxWonderBuildTurns     ((k_Token_Custom_Base) + 62)
#define k_Token_Strategy_MaxWonderBuildTurns_Value ((k_Token_Custom_Base) + 63)
#define k_Token_Strategy_BuildTransportProductionLevel ((k_Token_Custom_Base) + 64)
#define k_Token_Strategy_BuildTransportProductionLevel_Value ((k_Token_Custom_Base) + 65)
#define k_Token_Strategy_BuildSettlerProductionLevel ((k_Token_Custom_Base) + 66)
#define k_Token_Strategy_BuildSettlerProductionLevel_Value ((k_Token_Custom_Base) + 67)
#define k_Token_Strategy_OffensiveUnitsPercent   ((k_Token_Custom_Base) + 68)
#define k_Token_Strategy_OffensiveUnitsPercent_Value ((k_Token_Custom_Base) + 69)
#define k_Token_Strategy_DefensiveUnitsPercent   ((k_Token_Custom_Base) + 70)
#define k_Token_Strategy_DefensiveUnitsPercent_Value ((k_Token_Custom_Base) + 71)
#define k_Token_Strategy_RangedUnitsPercent      ((k_Token_Custom_Base) + 72)
#define k_Token_Strategy_RangedUnitsPercent_Value ((k_Token_Custom_Base) + 73)
#define k_Token_Strategy_SeaUnitsPercent         ((k_Token_Custom_Base) + 74)
#define k_Token_Strategy_SeaUnitsPercent_Value   ((k_Token_Custom_Base) + 75)
#define k_Token_Strategy_AirUnitsPercent         ((k_Token_Custom_Base) + 76)
#define k_Token_Strategy_AirUnitsPercent_Value   ((k_Token_Custom_Base) + 77)
#define k_Token_Strategy_SettlerUnitsCount       ((k_Token_Custom_Base) + 78)
#define k_Token_Strategy_SettlerUnitsCount_Value ((k_Token_Custom_Base) + 79)
#define k_Token_Strategy_SpecialUnitsCount       ((k_Token_Custom_Base) + 80)
#define k_Token_Strategy_SpecialUnitsCount_Value ((k_Token_Custom_Base) + 81)
#define k_Token_Strategy_SeaTransportUnitsCount  ((k_Token_Custom_Base) + 82)
#define k_Token_Strategy_SeaTransportUnitsCount_Value ((k_Token_Custom_Base) + 83)
#define k_Token_Strategy_AirTransportUnitsCount  ((k_Token_Custom_Base) + 84)
#define k_Token_Strategy_AirTransportUnitsCount_Value ((k_Token_Custom_Base) + 85)
#define k_Token_Strategy_OffensiveUnitList       ((k_Token_Custom_Base) + 86)
#define k_Token_Strategy_OffensiveUnitList_Value ((k_Token_Custom_Base) + 87)
#define k_Token_Strategy_DefensiveUnitList       ((k_Token_Custom_Base) + 88)
#define k_Token_Strategy_DefensiveUnitList_Value ((k_Token_Custom_Base) + 89)
#define k_Token_Strategy_RangedUnitList          ((k_Token_Custom_Base) + 90)
#define k_Token_Strategy_RangedUnitList_Value    ((k_Token_Custom_Base) + 91)
#define k_Token_Strategy_SeaUnitList             ((k_Token_Custom_Base) + 92)
#define k_Token_Strategy_SeaUnitList_Value       ((k_Token_Custom_Base) + 93)
#define k_Token_Strategy_AirUnitList             ((k_Token_Custom_Base) + 94)
#define k_Token_Strategy_AirUnitList_Value       ((k_Token_Custom_Base) + 95)
#define k_Token_Strategy_SettlerUnitList         ((k_Token_Custom_Base) + 96)
#define k_Token_Strategy_SettlerUnitList_Value   ((k_Token_Custom_Base) + 97)
#define k_Token_Strategy_SpecialUnitList         ((k_Token_Custom_Base) + 98)
#define k_Token_Strategy_SpecialUnitList_Value   ((k_Token_Custom_Base) + 99)
#define k_Token_Strategy_SeaTransportUnitList    ((k_Token_Custom_Base) + 100)
#define k_Token_Strategy_SeaTransportUnitList_Value ((k_Token_Custom_Base) + 101)
#define k_Token_Strategy_AirTransportUnitList    ((k_Token_Custom_Base) + 102)
#define k_Token_Strategy_AirTransportUnitList_Value ((k_Token_Custom_Base) + 103)
#define k_Token_Strategy_FreightUnitList         ((k_Token_Custom_Base) + 104)
#define k_Token_Strategy_FreightUnitList_Value   ((k_Token_Custom_Base) + 105)
#define k_Token_Strategy_OffensiveGarrisonCount  ((k_Token_Custom_Base) + 106)
#define k_Token_Strategy_OffensiveGarrisonCount_Value ((k_Token_Custom_Base) + 107)
#define k_Token_Strategy_DefensiveGarrisonCount  ((k_Token_Custom_Base) + 108)
#define k_Token_Strategy_DefensiveGarrisonCount_Value ((k_Token_Custom_Base) + 109)
#define k_Token_Strategy_RangedGarrisonCount     ((k_Token_Custom_Base) + 110)
#define k_Token_Strategy_RangedGarrisonCount_Value ((k_Token_Custom_Base) + 111)
#define k_Token_Strategy_BuildListSequenceElement ((k_Token_Custom_Base) + 112)
#define k_Token_Strategy_Research                ((k_Token_Custom_Base) + 113)
#define k_Token_Strategy_Research_Value          ((k_Token_Custom_Base) + 114)
#define k_Token_Strategy_StopResearch            ((k_Token_Custom_Base) + 115)
#define k_Token_Strategy_StopResearch_Value      ((k_Token_Custom_Base) + 116)
#define k_Token_Strategy_FearInvasion            ((k_Token_Custom_Base) + 117)
#define k_Token_Strategy_FearInvasion_Value      ((k_Token_Custom_Base) + 118)
#define k_Token_Strategy_FearCityDefense         ((k_Token_Custom_Base) + 119)
#define k_Token_Strategy_FearCityDefense_Value   ((k_Token_Custom_Base) + 120)
#define k_Token_Strategy_FearPiracy              ((k_Token_Custom_Base) + 121)
#define k_Token_Strategy_FearPiracy_Value        ((k_Token_Custom_Base) + 122)
#define k_Token_Strategy_FearScienceRank         ((k_Token_Custom_Base) + 123)
#define k_Token_Strategy_FearScienceRank_Value   ((k_Token_Custom_Base) + 124)
#define k_Token_Strategy_FearMilitaryRank        ((k_Token_Custom_Base) + 125)
#define k_Token_Strategy_FearMilitaryRank_Value  ((k_Token_Custom_Base) + 126)
#define k_Token_Strategy_FearTradeRank           ((k_Token_Custom_Base) + 127)
#define k_Token_Strategy_FearTradeRank_Value     ((k_Token_Custom_Base) + 128)
#define k_Token_Strategy_FearPollution           ((k_Token_Custom_Base) + 129)
#define k_Token_Strategy_FearPollution_Value     ((k_Token_Custom_Base) + 130)
#define k_Token_Strategy_DesireAttack            ((k_Token_Custom_Base) + 131)
#define k_Token_Strategy_DesireAttack_Value      ((k_Token_Custom_Base) + 132)
#define k_Token_Strategy_DesireGold              ((k_Token_Custom_Base) + 133)
#define k_Token_Strategy_DesireGold_Value        ((k_Token_Custom_Base) + 134)
#define k_Token_Strategy_DesireScience           ((k_Token_Custom_Base) + 135)
#define k_Token_Strategy_DesireScience_Value     ((k_Token_Custom_Base) + 136)
#define k_Token_Strategy_DesireMakeFriend        ((k_Token_Custom_Base) + 137)
#define k_Token_Strategy_DesireMakeFriend_Value  ((k_Token_Custom_Base) + 138)
#define k_Token_Strategy_DesireEnlistFriend      ((k_Token_Custom_Base) + 139)
#define k_Token_Strategy_DesireEnlistFriend_Value ((k_Token_Custom_Base) + 140)
#define k_Token_Strategy_PiracyMemoryTurns       ((k_Token_Custom_Base) + 141)
#define k_Token_Strategy_PiracyMemoryTurns_Value ((k_Token_Custom_Base) + 142)
#define k_Token_Strategy_MaxPiracyEvents         ((k_Token_Custom_Base) + 143)
#define k_Token_Strategy_MaxPiracyEvents_Value   ((k_Token_Custom_Base) + 144)
#define k_Token_Strategy_Offensive               ((k_Token_Custom_Base) + 145)
#define k_Token_Strategy_Offensive_Value         ((k_Token_Custom_Base) + 146)
#define k_Token_Strategy_Defensive               ((k_Token_Custom_Base) + 147)
#define k_Token_Strategy_Defensive_Value         ((k_Token_Custom_Base) + 148)
#define k_Token_Strategy_StealthAttack           ((k_Token_Custom_Base) + 149)
#define k_Token_Strategy_StealthAttack_Value     ((k_Token_Custom_Base) + 150)
#define k_Token_Strategy_Bombard                 ((k_Token_Custom_Base) + 151)
#define k_Token_Strategy_Bombard_Value           ((k_Token_Custom_Base) + 152)
#define k_Token_Strategy_Special                 ((k_Token_Custom_Base) + 153)
#define k_Token_Strategy_Special_Value           ((k_Token_Custom_Base) + 154)
#define k_Token_Strategy_Harass                  ((k_Token_Custom_Base) + 155)
#define k_Token_Strategy_Harass_Value            ((k_Token_Custom_Base) + 156)
#define k_Token_Strategy_NuclearFirstStrike      ((k_Token_Custom_Base) + 157)
#define k_Token_Strategy_NuclearTargeting        ((k_Token_Custom_Base) + 158)
#define k_Token_Strategy_PreemptiveStrikeRegard  ((k_Token_Custom_Base) + 159)
#define k_Token_Strategy_PreemptiveStrikeRegard_Value ((k_Token_Custom_Base) + 160)
#define k_Token_Strategy_PreemptiveStrikeRiskRatio ((k_Token_Custom_Base) + 161)
#define k_Token_Strategy_PreemptiveStrikeRiskRatio_Value ((k_Token_Custom_Base) + 162)
#define k_Token_Strategy_PreemptiveStrikeSuperiorityRatio ((k_Token_Custom_Base) + 163)
#define k_Token_Strategy_PreemptiveStrikeSuperiorityRatio_Value ((k_Token_Custom_Base) + 164)
#define k_Token_Strategy_Max                     ((k_Token_Custom_Base) + 165)


static BitArray s_ParsedTokens(165);
void StrategyRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 StrategyRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Strategy_Tokens, k_Token_Strategy_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Strategy_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Strategy_Inherit:
                if(!g_theStrategyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement:
                if(!StrategyRecord::PopAssignmentElement::ParseInArray(lex, &m_PopAssignmentElement, &m_numPopAssignmentElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Government:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_Government, &m_numGovernment, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinimumHappiness:
                m_flags0 |= k_Strategy_MinimumHappiness_Bit;
                if(!lex->GetIntAssignment(m_MinimumHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DeficitSpending:
                m_flags0 |= k_Strategy_DeficitSpending_Bit;
                if(!lex->GetFloatAssignment(m_DeficitSpendingValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaximumWagePercent:
                m_flags0 |= k_Strategy_MaximumWagePercent_Bit;
                if(!lex->GetFloatAssignment(m_MaximumWagePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SliderElement:
                if(!StrategyRecord::SliderElement::ParseInArray(lex, &m_SliderElement, &m_numSliderElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SciencePercent:
                m_flags0 |= k_Strategy_SciencePercent_Bit;
                if(!lex->GetIntAssignment(m_SciencePercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxSupportCostPercent:
                m_flags0 |= k_Strategy_MaxSupportCostPercent_Bit;
                if(!lex->GetIntAssignment(m_MaxSupportCostPercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ReadinessLevel:
                m_flags0 |= k_Strategy_ReadinessLevel_Bit;
                if(!lex->GetIntAssignment(m_ReadinessLevelValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PublicWorksPercent:
                m_flags0 |= k_Strategy_PublicWorksPercent_Bit;
                if(!lex->GetIntAssignment(m_PublicWorksPercentValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PublicWorksReserve:
                m_flags0 |= k_Strategy_PublicWorksReserve_Bit;
                if(!lex->GetIntAssignment(m_PublicWorksReserveValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxEvalTileImprovements:
                m_flags0 |= k_Strategy_MaxEvalTileImprovements_Bit;
                if(!lex->GetIntAssignment(m_MaxEvalTileImprovementsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_TimeToFixRoads:
                m_flags0 |= k_Strategy_TimeToFixRoads_Bit;
                if(!lex->GetIntAssignment(m_TimeToFixRoadsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_TimeToFixPollution:
                m_flags0 |= k_Strategy_TimeToFixPollution_Bit;
                if(!lex->GetIntAssignment(m_TimeToFixPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FixPollutionThreshold:
                m_flags0 |= k_Strategy_FixPollutionThreshold_Bit;
                if(!lex->GetIntAssignment(m_FixPollutionThresholdValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RoadUtilityBonus:
                m_flags0 |= k_Strategy_RoadUtilityBonus_Bit;
                if(!lex->GetFloatAssignment(m_RoadUtilityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveProductionBonus:
                m_flags0 |= k_Strategy_ImproveProductionBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveProductionBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGrowthBonus:
                m_flags0 |= k_Strategy_ImproveGrowthBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveGrowthBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGoodBonus:
                m_flags0 |= k_Strategy_ImproveGoodBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveGoodBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveSmallCityGrowthBonus:
                m_flags0 |= k_Strategy_ImproveSmallCityGrowthBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveSmallCityGrowthBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveLargeCityProductionBonus:
                m_flags0 |= k_Strategy_ImproveLargeCityProductionBonus_Bit;
                if(!lex->GetFloatAssignment(m_ImproveLargeCityProductionBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveGrowthList:
                if(!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveGrowthList, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveProductionList:
                if(!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveProductionList, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ImproveRandomList:
                if(!g_theImprovementListDB->GetRecordFromLexer(lex, m_ImproveRandomList, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement:
                if(!StrategyRecord::GoalElement::ParseInArray(lex, &m_GoalElement, &m_numGoalElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DistanceModifierFactor:
                m_flags0 |= k_Strategy_DistanceModifierFactor_Bit;
                if(!lex->GetIntAssignment(m_DistanceModifierFactorValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DisbandArmyCount:
                m_flags0 |= k_Strategy_DisbandArmyCount_Bit;
                if(!lex->GetIntAssignment(m_DisbandArmyCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinSettleDistance:
                m_flags0 |= k_Strategy_MinSettleDistance_Bit;
                if(!lex->GetIntAssignment(m_MinSettleDistanceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MinSettleScore:
                m_flags0 |= k_Strategy_MinSettleScore_Bit;
                if(!lex->GetIntAssignment(m_MinSettleScoreValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RushBuyThreatBonus:
                m_flags0 |= k_Strategy_RushBuyThreatBonus_Bit;
                if(!lex->GetIntAssignment(m_RushBuyThreatBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RushBuyReservePercent:
                m_flags0 |= k_Strategy_RushBuyReservePercent_Bit;
                if(!lex->GetFloatAssignment(m_RushBuyReservePercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_UnitSupportPercent:
                m_flags0 |= k_Strategy_UnitSupportPercent_Bit;
                if(!lex->GetFloatAssignment(m_UnitSupportPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxSettlerBuildTurns:
                m_flags0 |= k_Strategy_MaxSettlerBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxSettlerBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxUnitBuildTurns:
                m_flags0 |= k_Strategy_MaxUnitBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxUnitBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxWonderBuildTurns:
                m_flags0 |= k_Strategy_MaxWonderBuildTurns_Bit;
                if(!lex->GetIntAssignment(m_MaxWonderBuildTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildTransportProductionLevel:
                m_flags0 |= k_Strategy_BuildTransportProductionLevel_Bit;
                if(!lex->GetFloatAssignment(m_BuildTransportProductionLevelValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildSettlerProductionLevel:
                m_flags0 |= k_Strategy_BuildSettlerProductionLevel_Bit;
                if(!lex->GetFloatAssignment(m_BuildSettlerProductionLevelValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveUnitsPercent:
                m_flags0 |= k_Strategy_OffensiveUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_OffensiveUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveUnitsPercent:
                m_flags0 |= k_Strategy_DefensiveUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_DefensiveUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedUnitsPercent:
                m_flags1 |= k_Strategy_RangedUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_RangedUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaUnitsPercent:
                m_flags1 |= k_Strategy_SeaUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_SeaUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirUnitsPercent:
                m_flags1 |= k_Strategy_AirUnitsPercent_Bit;
                if(!lex->GetFloatAssignment(m_AirUnitsPercentValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SettlerUnitsCount:
                m_flags1 |= k_Strategy_SettlerUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SettlerUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpecialUnitsCount:
                m_flags1 |= k_Strategy_SpecialUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SpecialUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaTransportUnitsCount:
                m_flags1 |= k_Strategy_SeaTransportUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_SeaTransportUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirTransportUnitsCount:
                m_flags1 |= k_Strategy_AirTransportUnitsCount_Bit;
                if(!lex->GetIntAssignment(m_AirTransportUnitsCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveUnitList:
                m_flags1 |= k_Strategy_OffensiveUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_OffensiveUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveUnitList:
                m_flags1 |= k_Strategy_DefensiveUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_DefensiveUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedUnitList:
                m_flags1 |= k_Strategy_RangedUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_RangedUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaUnitList:
                m_flags1 |= k_Strategy_SeaUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SeaUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirUnitList:
                m_flags1 |= k_Strategy_AirUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_AirUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SettlerUnitList:
                m_flags1 |= k_Strategy_SettlerUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SettlerUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SpecialUnitList:
                m_flags1 |= k_Strategy_SpecialUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SpecialUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SeaTransportUnitList:
                m_flags1 |= k_Strategy_SeaTransportUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_SeaTransportUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_AirTransportUnitList:
                m_flags1 |= k_Strategy_AirTransportUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_AirTransportUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FreightUnitList:
                m_flags1 |= k_Strategy_FreightUnitList_Bit;
                if(!g_theUnitBuildListDB->GetRecordFromLexer(lex, m_FreightUnitListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_OffensiveGarrisonCount:
                m_flags1 |= k_Strategy_OffensiveGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_OffensiveGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DefensiveGarrisonCount:
                m_flags1 |= k_Strategy_DefensiveGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_DefensiveGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_RangedGarrisonCount:
                m_flags1 |= k_Strategy_RangedGarrisonCount_Bit;
                if(!lex->GetIntAssignment(m_RangedGarrisonCountValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement:
                if(!StrategyRecord::BuildListSequenceElement::ParseInArray(lex, &m_BuildListSequenceElement, &m_numBuildListSequenceElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Research:
                m_flags1 |= k_Strategy_Research_Bit;
                if(!g_theAdvanceListDB->GetRecordFromLexer(lex, m_ResearchValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_StopResearch:
                m_flags1 |= k_Strategy_StopResearch_Bit;
                if(!g_theAdvanceListDB->GetRecordFromLexer(lex, m_StopResearchValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearInvasion:
                m_flags1 |= k_Strategy_FearInvasion_Bit;
                if(!lex->GetIntAssignment(m_FearInvasionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearCityDefense:
                m_flags1 |= k_Strategy_FearCityDefense_Bit;
                if(!lex->GetIntAssignment(m_FearCityDefenseValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearPiracy:
                m_flags1 |= k_Strategy_FearPiracy_Bit;
                if(!lex->GetIntAssignment(m_FearPiracyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearScienceRank:
                m_flags1 |= k_Strategy_FearScienceRank_Bit;
                if(!lex->GetIntAssignment(m_FearScienceRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearMilitaryRank:
                m_flags1 |= k_Strategy_FearMilitaryRank_Bit;
                if(!lex->GetIntAssignment(m_FearMilitaryRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearTradeRank:
                m_flags1 |= k_Strategy_FearTradeRank_Bit;
                if(!lex->GetIntAssignment(m_FearTradeRankValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_FearPollution:
                m_flags1 |= k_Strategy_FearPollution_Bit;
                if(!lex->GetIntAssignment(m_FearPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireAttack:
                m_flags1 |= k_Strategy_DesireAttack_Bit;
                if(!lex->GetIntAssignment(m_DesireAttackValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireGold:
                m_flags1 |= k_Strategy_DesireGold_Bit;
                if(!lex->GetIntAssignment(m_DesireGoldValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireScience:
                m_flags1 |= k_Strategy_DesireScience_Bit;
                if(!lex->GetIntAssignment(m_DesireScienceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireMakeFriend:
                m_flags2 |= k_Strategy_DesireMakeFriend_Bit;
                if(!lex->GetIntAssignment(m_DesireMakeFriendValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_DesireEnlistFriend:
                m_flags2 |= k_Strategy_DesireEnlistFriend_Bit;
                if(!lex->GetIntAssignment(m_DesireEnlistFriendValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PiracyMemoryTurns:
                m_flags2 |= k_Strategy_PiracyMemoryTurns_Bit;
                if(!lex->GetIntAssignment(m_PiracyMemoryTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_MaxPiracyEvents:
                m_flags2 |= k_Strategy_MaxPiracyEvents_Bit;
                if(!lex->GetIntAssignment(m_MaxPiracyEventsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Offensive:
                m_flags2 |= k_Strategy_Offensive_Bit;
                if(!m_OffensiveValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Defensive:
                m_flags2 |= k_Strategy_Defensive_Bit;
                if(!m_DefensiveValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_StealthAttack:
                m_flags2 |= k_Strategy_StealthAttack_Bit;
                if(!m_StealthAttackValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Bombard:
                m_flags2 |= k_Strategy_Bombard_Bit;
                if(!m_BombardValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Special:
                m_flags2 |= k_Strategy_Special_Bit;
                if(!m_SpecialValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_Harass:
                m_flags2 |= k_Strategy_Harass_Bit;
                if(!m_HarassValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_NuclearFirstStrike:
                if(!ParseNuclearFirstStrikeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_NuclearTargeting:
                if(!ParseNuclearTargetingBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeRegard:
                m_flags2 |= k_Strategy_PreemptiveStrikeRegard_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveStrikeRegardValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeRiskRatio:
                m_flags2 |= k_Strategy_PreemptiveStrikeRiskRatio_Bit;
                if(!lex->GetFloatAssignment(m_PreemptiveStrikeRiskRatioValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PreemptiveStrikeSuperiorityRatio:
                m_flags2 |= k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit;
                if(!lex->GetFloatAssignment(m_PreemptiveStrikeSuperiorityRatioValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void StrategyRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numInherit; i++) {
            if(m_Inherit[i] & 0x80000000) {
                sint32 id = m_Inherit[i] & 0x7fffffff;
                if(!g_theStrategyDB->GetNamedItem(id, m_Inherit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Strategy database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Inherit[i] == 0x7fffffff){
                m_Inherit[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numPopAssignmentElement; i++) {
            m_PopAssignmentElement[i].ResolveDBReferences();
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numGovernment; i++) {
            if(m_Government[i] & 0x80000000) {
                sint32 id = m_Government[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_Government[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Government[i] == 0x7fffffff){
                m_Government[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numSliderElement; i++) {
            m_SliderElement[i].ResolveDBReferences();
        }
    }
    if(m_ImproveGrowthList & 0x80000000) {
        sint32 id = m_ImproveGrowthList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveGrowthList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveGrowthList == 0x7fffffff) {
        m_ImproveGrowthList = -1;
    }
    if(m_ImproveProductionList & 0x80000000) {
        sint32 id = m_ImproveProductionList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveProductionList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveProductionList == 0x7fffffff) {
        m_ImproveProductionList = -1;
    }
    if(m_ImproveRandomList & 0x80000000) {
        sint32 id = m_ImproveRandomList & 0x7fffffff;
        if(!g_theImprovementListDB->GetNamedItem(id, m_ImproveRandomList)) {
            c3errors_ErrorDialog("DB", "%s not found in ImprovementList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ImproveRandomList == 0x7fffffff) {
        m_ImproveRandomList = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numGoalElement; i++) {
            m_GoalElement[i].ResolveDBReferences();
        }
    }
    if(m_OffensiveUnitListValue & 0x80000000) {
        sint32 id = m_OffensiveUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_OffensiveUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_OffensiveUnitListValue == 0x7fffffff) {
        m_OffensiveUnitListValue = -1;
    }
    if(m_DefensiveUnitListValue & 0x80000000) {
        sint32 id = m_DefensiveUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_DefensiveUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefensiveUnitListValue == 0x7fffffff) {
        m_DefensiveUnitListValue = -1;
    }
    if(m_RangedUnitListValue & 0x80000000) {
        sint32 id = m_RangedUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_RangedUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_RangedUnitListValue == 0x7fffffff) {
        m_RangedUnitListValue = -1;
    }
    if(m_SeaUnitListValue & 0x80000000) {
        sint32 id = m_SeaUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SeaUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SeaUnitListValue == 0x7fffffff) {
        m_SeaUnitListValue = -1;
    }
    if(m_AirUnitListValue & 0x80000000) {
        sint32 id = m_AirUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_AirUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AirUnitListValue == 0x7fffffff) {
        m_AirUnitListValue = -1;
    }
    if(m_SettlerUnitListValue & 0x80000000) {
        sint32 id = m_SettlerUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SettlerUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SettlerUnitListValue == 0x7fffffff) {
        m_SettlerUnitListValue = -1;
    }
    if(m_SpecialUnitListValue & 0x80000000) {
        sint32 id = m_SpecialUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SpecialUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SpecialUnitListValue == 0x7fffffff) {
        m_SpecialUnitListValue = -1;
    }
    if(m_SeaTransportUnitListValue & 0x80000000) {
        sint32 id = m_SeaTransportUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_SeaTransportUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SeaTransportUnitListValue == 0x7fffffff) {
        m_SeaTransportUnitListValue = -1;
    }
    if(m_AirTransportUnitListValue & 0x80000000) {
        sint32 id = m_AirTransportUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_AirTransportUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_AirTransportUnitListValue == 0x7fffffff) {
        m_AirTransportUnitListValue = -1;
    }
    if(m_FreightUnitListValue & 0x80000000) {
        sint32 id = m_FreightUnitListValue & 0x7fffffff;
        if(!g_theUnitBuildListDB->GetNamedItem(id, m_FreightUnitListValue)) {
            c3errors_ErrorDialog("DB", "%s not found in UnitBuildList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_FreightUnitListValue == 0x7fffffff) {
        m_FreightUnitListValue = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numBuildListSequenceElement; i++) {
            m_BuildListSequenceElement[i].ResolveDBReferences();
        }
    }
    if(m_ResearchValue & 0x80000000) {
        sint32 id = m_ResearchValue & 0x7fffffff;
        if(!g_theAdvanceListDB->GetNamedItem(id, m_ResearchValue)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_ResearchValue == 0x7fffffff) {
        m_ResearchValue = -1;
    }
    if(m_StopResearchValue & 0x80000000) {
        sint32 id = m_StopResearchValue & 0x7fffffff;
        if(!g_theAdvanceListDB->GetNamedItem(id, m_StopResearchValue)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceList database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_StopResearchValue == 0x7fffffff) {
        m_StopResearchValue = -1;
    }
    m_OffensiveValue.ResolveDBReferences();
    m_DefensiveValue.ResolveDBReferences();
    m_StealthAttackValue.ResolveDBReferences();
    m_BombardValue.ResolveDBReferences();
    m_SpecialValue.ResolveDBReferences();
    m_HarassValue.ResolveDBReferences();
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
StrategyRecord::PopAssignmentElement::PopAssignmentElement()
{
    m_flags0 = 0;
    m_Specialists = 0.000000;
    m_FarmerPercent = 0.000000;
    m_LaborerPercent = 0.000000;
    m_MerchantPercent = 0.000000;
    m_EntertainerPercent = 0.000000;
    m_ScientistPercent = 0.000000;
    m_TopValue = 0.0;
    m_BottomValue = 0.0;
}
StrategyRecord::PopAssignmentElement::~PopAssignmentElement()
{
}
void StrategyRecord::PopAssignmentElement::operator=(const PopAssignmentElement & rval)
{
	m_Specialists = rval.m_Specialists; 

	m_FarmerPercent = rval.m_FarmerPercent; 

	m_LaborerPercent = rval.m_LaborerPercent; 

	m_MerchantPercent = rval.m_MerchantPercent; 

	m_EntertainerPercent = rval.m_EntertainerPercent; 

	m_ScientistPercent = rval.m_ScientistPercent; 

	m_flags0 = rval.m_flags0; 
		m_TopValue = rval.m_TopValue; 

	m_flags0 = rval.m_flags0; 
		m_BottomValue = rval.m_BottomValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
}
static char *s_Strategy_PopAssignmentElement_Tokens[] = {
    "Specialists",
    "FarmerPercent",
    "LaborerPercent",
    "MerchantPercent",
    "EntertainerPercent",
    "ScientistPercent",
    "Top",
    "Bottom",
    "ProductionCities",
    "GrowthCities",
    "GoldCities",
    "Default",
};
#define k_Token_Strategy_PopAssignmentElement_Specialists ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_PopAssignmentElement_FarmerPercent ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_PopAssignmentElement_LaborerPercent ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_PopAssignmentElement_MerchantPercent ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_PopAssignmentElement_EntertainerPercent ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_PopAssignmentElement_ScientistPercent ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_PopAssignmentElement_Top ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_PopAssignmentElement_Bottom ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_PopAssignmentElement_ProductionCities ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_PopAssignmentElement_GrowthCities ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_PopAssignmentElement_GoldCities ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_PopAssignmentElement_Default ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_PopAssignmentElement_Max ((k_Token_Custom_Base) + 12)
sint32 StrategyRecord::PopAssignmentElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for PopAssignmentElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Strategy_PopAssignmentElement_Tokens, k_Token_Strategy_PopAssignmentElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_PopAssignmentElement_Specialists:
                if(!lex->GetFloatAssignment(m_Specialists)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_FarmerPercent:
                if(!lex->GetFloatAssignment(m_FarmerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_LaborerPercent:
                if(!lex->GetFloatAssignment(m_LaborerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_MerchantPercent:
                if(!lex->GetFloatAssignment(m_MerchantPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_EntertainerPercent:
                if(!lex->GetFloatAssignment(m_EntertainerPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_ScientistPercent:
                if(!lex->GetFloatAssignment(m_ScientistPercent)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_Top:
                m_flags0 |= k_PopAssignmentElement_Top_Bit;
                if(!lex->GetFloatAssignment(m_TopValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_Bottom:
                m_flags0 |= k_PopAssignmentElement_Bottom_Bit;
                if(!lex->GetFloatAssignment(m_BottomValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_PopAssignmentElement_ProductionCities:
                m_flags0 |= k_PopAssignmentElement_ProductionCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_GrowthCities:
                m_flags0 |= k_PopAssignmentElement_GrowthCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_GoldCities:
                m_flags0 |= k_PopAssignmentElement_GoldCities_Bit;
                break;
            case k_Token_Strategy_PopAssignmentElement_Default:
                m_flags0 |= k_PopAssignmentElement_Default_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::PopAssignmentElement::ParseInArray(DBLexer *lex, PopAssignmentElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PopAssignmentElement *oldArray = *array;
        *array = new PopAssignmentElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PopAssignmentElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 StrategyRecord::PopAssignmentElement::ParseInArray(DBLexer *lex, PopAssignmentElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void StrategyRecord::PopAssignmentElement::ResolveDBReferences()
{
}
StrategyRecord::SliderElement::SliderElement()
{
    m_flags0 = 0;
    m_Delta = 0;
}
StrategyRecord::SliderElement::~SliderElement()
{
}
void StrategyRecord::SliderElement::operator=(const SliderElement & rval)
{
	m_Delta = rval.m_Delta; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
}
static char *s_Strategy_SliderElement_Tokens[] = {
    "Delta",
    "Production",
    "Gold",
    "Food",
};
#define k_Token_Strategy_SliderElement_Delta     ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_SliderElement_Production ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_SliderElement_Gold      ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_SliderElement_Food      ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_SliderElement_Max ((k_Token_Custom_Base) + 4)
sint32 StrategyRecord::SliderElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for SliderElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Strategy_SliderElement_Tokens, k_Token_Strategy_SliderElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_SliderElement_Delta:
                if(!lex->GetIntAssignment(m_Delta)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_SliderElement_Production:
                m_flags0 |= k_SliderElement_Production_Bit;
                break;
            case k_Token_Strategy_SliderElement_Gold:
                m_flags0 |= k_SliderElement_Gold_Bit;
                break;
            case k_Token_Strategy_SliderElement_Food:
                m_flags0 |= k_SliderElement_Food_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::SliderElement::ParseInArray(DBLexer *lex, SliderElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SliderElement *oldArray = *array;
        *array = new SliderElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SliderElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 StrategyRecord::SliderElement::ParseInArray(DBLexer *lex, SliderElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void StrategyRecord::SliderElement::ResolveDBReferences()
{
}
StrategyRecord::GoalElement::GoalElement()
{
    m_flags0 = 0;
    m_Goal = 0x7fffffff;
    m_Priority = 0;
    m_MaxEval = 0.000000;
    m_MaxExec = 0.000000;
}
StrategyRecord::GoalElement::~GoalElement()
{
}
void StrategyRecord::GoalElement::operator=(const GoalElement & rval)
{
	m_Goal = rval.m_Goal; 

	m_Priority = rval.m_Priority; 

	m_MaxEval = rval.m_MaxEval; 

	m_MaxExec = rval.m_MaxExec; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
}
static char *s_Strategy_GoalElement_Tokens[] = {
    "Goal",
    "Priority",
    "MaxEval",
    "MaxExec",
    "ExecPerCity",
    "EvalPerCity",
    "PerCity",
};
#define k_Token_Strategy_GoalElement_Goal        ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_GoalElement_Priority    ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_GoalElement_MaxEval     ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_GoalElement_MaxExec     ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_GoalElement_ExecPerCity ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_GoalElement_EvalPerCity ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_GoalElement_PerCity     ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_GoalElement_Max ((k_Token_Custom_Base) + 7)
sint32 StrategyRecord::GoalElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for GoalElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Strategy_GoalElement_Tokens, k_Token_Strategy_GoalElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_GoalElement_Goal:
                if(!g_theGoalDB->GetRecordFromLexer(lex, m_Goal, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_Priority:
                if(!lex->GetIntAssignment(m_Priority)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_MaxEval:
                if(!lex->GetFloatAssignment(m_MaxEval)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_MaxExec:
                if(!lex->GetFloatAssignment(m_MaxExec)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_GoalElement_ExecPerCity:
                m_flags0 |= k_GoalElement_ExecPerCity_Bit;
                break;
            case k_Token_Strategy_GoalElement_EvalPerCity:
                m_flags0 |= k_GoalElement_EvalPerCity_Bit;
                break;
            case k_Token_Strategy_GoalElement_PerCity:
                m_flags0 |= k_GoalElement_PerCity_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::GoalElement::ParseInArray(DBLexer *lex, GoalElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        GoalElement *oldArray = *array;
        *array = new GoalElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new GoalElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 StrategyRecord::GoalElement::ParseInArray(DBLexer *lex, GoalElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void StrategyRecord::GoalElement::ResolveDBReferences()
{
    if(m_Goal & 0x80000000) {
        sint32 id = m_Goal & 0x7fffffff;
        if(!g_theGoalDB->GetNamedItem(id, m_Goal)) {
            c3errors_ErrorDialog("DB", "%s not found in Goal database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Goal == 0x7fffffff) {
        m_Goal = -1;
    }
}
StrategyRecord::BuildListSequenceElement::BuildListSequenceElement()
{
    m_flags0 = 0;
    m_Priority = 0;
    m_BuildListSequence = 0x7fffffff;
    m_TopValue = 0.0;
    m_BottomValue = 0.0;
    m_AdviceValue = 0;
}
StrategyRecord::BuildListSequenceElement::~BuildListSequenceElement()
{
}
void StrategyRecord::BuildListSequenceElement::operator=(const BuildListSequenceElement & rval)
{
	m_Priority = rval.m_Priority; 

	m_BuildListSequence = rval.m_BuildListSequence; 

	m_flags0 = rval.m_flags0; 
		m_TopValue = rval.m_TopValue; 

	m_flags0 = rval.m_flags0; 
		m_BottomValue = rval.m_BottomValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
		m_AdviceValue = rval.m_AdviceValue; 

}
static char *s_Strategy_BuildListSequenceElement_Tokens[] = {
    "Priority",
    "BuildListSequence",
    "Top",
    "Bottom",
    "ProductionCities",
    "GrowthCities",
    "CommerceCities",
    "HappyCities",
    "ThreatenedCities",
    "PowerCities",
    "Default",
    "Advice",
};
#define k_Token_Strategy_BuildListSequenceElement_Priority ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_BuildListSequenceElement_BuildListSequence ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_BuildListSequenceElement_Top ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_BuildListSequenceElement_Bottom ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_BuildListSequenceElement_ProductionCities ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_BuildListSequenceElement_GrowthCities ((k_Token_Custom_Base) + 5)
#define k_Token_Strategy_BuildListSequenceElement_CommerceCities ((k_Token_Custom_Base) + 6)
#define k_Token_Strategy_BuildListSequenceElement_HappyCities ((k_Token_Custom_Base) + 7)
#define k_Token_Strategy_BuildListSequenceElement_ThreatenedCities ((k_Token_Custom_Base) + 8)
#define k_Token_Strategy_BuildListSequenceElement_PowerCities ((k_Token_Custom_Base) + 9)
#define k_Token_Strategy_BuildListSequenceElement_Default ((k_Token_Custom_Base) + 10)
#define k_Token_Strategy_BuildListSequenceElement_Advice ((k_Token_Custom_Base) + 11)
#define k_Token_Strategy_BuildListSequenceElement_Max ((k_Token_Custom_Base) + 12)
sint32 StrategyRecord::BuildListSequenceElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for BuildListSequenceElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Strategy_BuildListSequenceElement_Tokens, k_Token_Strategy_BuildListSequenceElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_BuildListSequenceElement_Priority:
                if(!lex->GetIntAssignment(m_Priority)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_BuildListSequence:
                if(!g_theBuildListSequenceDB->GetRecordFromLexer(lex, m_BuildListSequence, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_Top:
                m_flags0 |= k_BuildListSequenceElement_Top_Bit;
                if(!lex->GetFloatAssignment(m_TopValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_Bottom:
                m_flags0 |= k_BuildListSequenceElement_Bottom_Bit;
                if(!lex->GetFloatAssignment(m_BottomValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Strategy_BuildListSequenceElement_ProductionCities:
                m_flags0 |= k_BuildListSequenceElement_ProductionCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_GrowthCities:
                m_flags0 |= k_BuildListSequenceElement_GrowthCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_CommerceCities:
                m_flags0 |= k_BuildListSequenceElement_CommerceCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_HappyCities:
                m_flags0 |= k_BuildListSequenceElement_HappyCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_ThreatenedCities:
                m_flags0 |= k_BuildListSequenceElement_ThreatenedCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_PowerCities:
                m_flags0 |= k_BuildListSequenceElement_PowerCities_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_Default:
                m_flags0 |= k_BuildListSequenceElement_Default_Bit;
                break;
            case k_Token_Strategy_BuildListSequenceElement_Advice:
                m_flags0 |= k_BuildListSequenceElement_Advice_Bit;
                if(!lex->GetStringIdAssignment(m_AdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::BuildListSequenceElement::ParseInArray(DBLexer *lex, BuildListSequenceElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildListSequenceElement *oldArray = *array;
        *array = new BuildListSequenceElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildListSequenceElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 StrategyRecord::BuildListSequenceElement::ParseInArray(DBLexer *lex, BuildListSequenceElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void StrategyRecord::BuildListSequenceElement::ResolveDBReferences()
{
    if(m_BuildListSequence & 0x80000000) {
        sint32 id = m_BuildListSequence & 0x7fffffff;
        if(!g_theBuildListSequenceDB->GetNamedItem(id, m_BuildListSequence)) {
            c3errors_ErrorDialog("DB", "%s not found in BuildListSequence database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildListSequence == 0x7fffffff) {
        m_BuildListSequence = -1;
    }
}
StrategyRecord::ForceMatch::ForceMatch()
{
    m_AttackMatch = 0.000000;
    m_DefenseMatch = 0.000000;
    m_RangedMatch = 0.000000;
    m_BombardMatch = 0.000000;
    m_ValueMatch = 0.000000;
}
StrategyRecord::ForceMatch::~ForceMatch()
{
}
void StrategyRecord::ForceMatch::operator=(const ForceMatch & rval)
{
	m_AttackMatch = rval.m_AttackMatch; 

	m_DefenseMatch = rval.m_DefenseMatch; 

	m_RangedMatch = rval.m_RangedMatch; 

	m_BombardMatch = rval.m_BombardMatch; 

	m_ValueMatch = rval.m_ValueMatch; 

}
static char *s_Strategy_ForceMatch_Tokens[] = {
    "AttackMatch",
    "DefenseMatch",
    "RangedMatch",
    "BombardMatch",
    "ValueMatch",
};
#define k_Token_Strategy_ForceMatch_AttackMatch  ((k_Token_Custom_Base) + 0)
#define k_Token_Strategy_ForceMatch_DefenseMatch ((k_Token_Custom_Base) + 1)
#define k_Token_Strategy_ForceMatch_RangedMatch  ((k_Token_Custom_Base) + 2)
#define k_Token_Strategy_ForceMatch_BombardMatch ((k_Token_Custom_Base) + 3)
#define k_Token_Strategy_ForceMatch_ValueMatch   ((k_Token_Custom_Base) + 4)
#define k_Token_Strategy_ForceMatch_Max ((k_Token_Custom_Base) + 5)
sint32 StrategyRecord::ForceMatch::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_AttackMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DefenseMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_RangedMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_BombardMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_ValueMatch)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 StrategyRecord::ForceMatch::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for ForceMatch"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Strategy_ForceMatch_Tokens, k_Token_Strategy_ForceMatch_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Strategy_ForceMatch_AttackMatch:
                if(!lex->GetFloatAssignment(m_AttackMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_DefenseMatch:
                if(!lex->GetFloatAssignment(m_DefenseMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_RangedMatch:
                if(!lex->GetFloatAssignment(m_RangedMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_BombardMatch:
                if(!lex->GetFloatAssignment(m_BombardMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_Strategy_ForceMatch_ValueMatch:
                if(!lex->GetFloatAssignment(m_ValueMatch)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 StrategyRecord::ForceMatch::ParseInArray(DBLexer *lex, ForceMatch **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ForceMatch *oldArray = *array;
        *array = new ForceMatch[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ForceMatch[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 StrategyRecord::ForceMatch::ParseInArray(DBLexer *lex, ForceMatch *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void StrategyRecord::ForceMatch::ResolveDBReferences()
{
}
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
static char *s_Strategy_NuclearFirstStrike_BitNames[] = {
    "Enabled",
    "Disabled",
};
#define k_Strategy_NuclearFirstStrike_Num_BitNames 2

sint32 StrategyRecord::ParseNuclearFirstStrikeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Strategy_NuclearFirstStrike_BitNames, k_Strategy_NuclearFirstStrike_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of NuclearFirstStrike", lex->GetTokenText()));
        return 0;
    }
    m_NuclearFirstStrike |= (1 << bitindex);
    return 1;
}

static char *s_Strategy_NuclearTargeting_BitNames[] = {
    "Enabled",
    "Disabled",
};
#define k_Strategy_NuclearTargeting_Num_BitNames 2

sint32 StrategyRecord::ParseNuclearTargetingBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Strategy_NuclearTargeting_BitNames, k_Strategy_NuclearTargeting_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of NuclearTargeting", lex->GetTokenText()));
        return 0;
    }
    m_NuclearTargeting |= (1 << bitindex);
    return 1;
}

void StrategyRecord::Merge(const StrategyRecord & rval){
	int index = 0, obj_index = 0;
	// copy values of rval.m_Inherit to m_Inherit
	for (index = 0; index < m_numInherit; index++) 
	{ 
 		if (index < rval.m_numInherit)
 			m_Inherit[index] = rval.m_Inherit[index];
	} 
 	// replace struct elements of m_PopAssignmentElement
	for (index = 0; index < m_numPopAssignmentElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numPopAssignmentElement; obj_index++) 
			if (m_PopAssignmentElement[index] == rval.m_PopAssignmentElement[obj_index]) {
				// replace struct element 
				m_PopAssignmentElement[index] = rval.m_PopAssignmentElement[obj_index]; 
				}
	} 
	// resize m_Government if necessary
	if (rval.m_numGovernment > m_numGovernment)
 	{ 
		delete m_Government;
 		m_Government = NULL;
 		if (rval.m_numGovernment > 0)
 			m_Government = new sint32 [rval.m_numGovernment]; 
		m_numGovernment = rval.m_numGovernment;
 	} 

	// copy values of rval.m_Government to m_Government
	for (index = 0; index < m_numGovernment; index++) 
	{ 
 		if (index < rval.m_numGovernment)
 			m_Government[index] = rval.m_Government[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MinimumHappiness_Bit) != 0) 
		m_MinimumHappinessValue = rval.m_MinimumHappinessValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_DeficitSpending_Bit) != 0) 
		m_DeficitSpendingValue = rval.m_DeficitSpendingValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaximumWagePercent_Bit) != 0) 
		m_MaximumWagePercentValue = rval.m_MaximumWagePercentValue; 

	// replace struct elements of m_SliderElement
	for (index = 0; index < m_numSliderElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numSliderElement; obj_index++) 
			if (m_SliderElement[index] == rval.m_SliderElement[obj_index]) {
				// replace struct element 
				m_SliderElement[index] = rval.m_SliderElement[obj_index]; 
				}
	} 
	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_SciencePercent_Bit) != 0) 
		m_SciencePercentValue = rval.m_SciencePercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaxSupportCostPercent_Bit) != 0) 
		m_MaxSupportCostPercentValue = rval.m_MaxSupportCostPercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ReadinessLevel_Bit) != 0) 
		m_ReadinessLevelValue = rval.m_ReadinessLevelValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_PublicWorksPercent_Bit) != 0) 
		m_PublicWorksPercentValue = rval.m_PublicWorksPercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_PublicWorksReserve_Bit) != 0) 
		m_PublicWorksReserveValue = rval.m_PublicWorksReserveValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaxEvalTileImprovements_Bit) != 0) 
		m_MaxEvalTileImprovementsValue = rval.m_MaxEvalTileImprovementsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_TimeToFixRoads_Bit) != 0) 
		m_TimeToFixRoadsValue = rval.m_TimeToFixRoadsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_TimeToFixPollution_Bit) != 0) 
		m_TimeToFixPollutionValue = rval.m_TimeToFixPollutionValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_FixPollutionThreshold_Bit) != 0) 
		m_FixPollutionThresholdValue = rval.m_FixPollutionThresholdValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_RoadUtilityBonus_Bit) != 0) 
		m_RoadUtilityBonusValue = rval.m_RoadUtilityBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ImproveProductionBonus_Bit) != 0) 
		m_ImproveProductionBonusValue = rval.m_ImproveProductionBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ImproveGrowthBonus_Bit) != 0) 
		m_ImproveGrowthBonusValue = rval.m_ImproveGrowthBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ImproveGoodBonus_Bit) != 0) 
		m_ImproveGoodBonusValue = rval.m_ImproveGoodBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ImproveSmallCityGrowthBonus_Bit) != 0) 
		m_ImproveSmallCityGrowthBonusValue = rval.m_ImproveSmallCityGrowthBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_ImproveLargeCityProductionBonus_Bit) != 0) 
		m_ImproveLargeCityProductionBonusValue = rval.m_ImproveLargeCityProductionBonusValue; 

	// replace struct elements of m_GoalElement
	for (index = 0; index < m_numGoalElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numGoalElement; obj_index++) 
			if (m_GoalElement[index] == rval.m_GoalElement[obj_index]) {
				// replace struct element 
				m_GoalElement[index] = rval.m_GoalElement[obj_index]; 
				}
	} 
	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_DistanceModifierFactor_Bit) != 0) 
		m_DistanceModifierFactorValue = rval.m_DistanceModifierFactorValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_DisbandArmyCount_Bit) != 0) 
		m_DisbandArmyCountValue = rval.m_DisbandArmyCountValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MinSettleDistance_Bit) != 0) 
		m_MinSettleDistanceValue = rval.m_MinSettleDistanceValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MinSettleScore_Bit) != 0) 
		m_MinSettleScoreValue = rval.m_MinSettleScoreValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_RushBuyThreatBonus_Bit) != 0) 
		m_RushBuyThreatBonusValue = rval.m_RushBuyThreatBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_RushBuyReservePercent_Bit) != 0) 
		m_RushBuyReservePercentValue = rval.m_RushBuyReservePercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_UnitSupportPercent_Bit) != 0) 
		m_UnitSupportPercentValue = rval.m_UnitSupportPercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaxSettlerBuildTurns_Bit) != 0) 
		m_MaxSettlerBuildTurnsValue = rval.m_MaxSettlerBuildTurnsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaxUnitBuildTurns_Bit) != 0) 
		m_MaxUnitBuildTurnsValue = rval.m_MaxUnitBuildTurnsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_MaxWonderBuildTurns_Bit) != 0) 
		m_MaxWonderBuildTurnsValue = rval.m_MaxWonderBuildTurnsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_BuildTransportProductionLevel_Bit) != 0) 
		m_BuildTransportProductionLevelValue = rval.m_BuildTransportProductionLevelValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_BuildSettlerProductionLevel_Bit) != 0) 
		m_BuildSettlerProductionLevelValue = rval.m_BuildSettlerProductionLevelValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_OffensiveUnitsPercent_Bit) != 0) 
		m_OffensiveUnitsPercentValue = rval.m_OffensiveUnitsPercentValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Strategy_DefensiveUnitsPercent_Bit) != 0) 
		m_DefensiveUnitsPercentValue = rval.m_DefensiveUnitsPercentValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_RangedUnitsPercent_Bit) != 0) 
		m_RangedUnitsPercentValue = rval.m_RangedUnitsPercentValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SeaUnitsPercent_Bit) != 0) 
		m_SeaUnitsPercentValue = rval.m_SeaUnitsPercentValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_AirUnitsPercent_Bit) != 0) 
		m_AirUnitsPercentValue = rval.m_AirUnitsPercentValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SettlerUnitsCount_Bit) != 0) 
		m_SettlerUnitsCountValue = rval.m_SettlerUnitsCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SpecialUnitsCount_Bit) != 0) 
		m_SpecialUnitsCountValue = rval.m_SpecialUnitsCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SeaTransportUnitsCount_Bit) != 0) 
		m_SeaTransportUnitsCountValue = rval.m_SeaTransportUnitsCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_AirTransportUnitsCount_Bit) != 0) 
		m_AirTransportUnitsCountValue = rval.m_AirTransportUnitsCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_OffensiveUnitList_Bit) != 0) 
		m_OffensiveUnitListValue = rval.m_OffensiveUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_DefensiveUnitList_Bit) != 0) 
		m_DefensiveUnitListValue = rval.m_DefensiveUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_RangedUnitList_Bit) != 0) 
		m_RangedUnitListValue = rval.m_RangedUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SeaUnitList_Bit) != 0) 
		m_SeaUnitListValue = rval.m_SeaUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_AirUnitList_Bit) != 0) 
		m_AirUnitListValue = rval.m_AirUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SettlerUnitList_Bit) != 0) 
		m_SettlerUnitListValue = rval.m_SettlerUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SpecialUnitList_Bit) != 0) 
		m_SpecialUnitListValue = rval.m_SpecialUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_SeaTransportUnitList_Bit) != 0) 
		m_SeaTransportUnitListValue = rval.m_SeaTransportUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_AirTransportUnitList_Bit) != 0) 
		m_AirTransportUnitListValue = rval.m_AirTransportUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FreightUnitList_Bit) != 0) 
		m_FreightUnitListValue = rval.m_FreightUnitListValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_OffensiveGarrisonCount_Bit) != 0) 
		m_OffensiveGarrisonCountValue = rval.m_OffensiveGarrisonCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_DefensiveGarrisonCount_Bit) != 0) 
		m_DefensiveGarrisonCountValue = rval.m_DefensiveGarrisonCountValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_RangedGarrisonCount_Bit) != 0) 
		m_RangedGarrisonCountValue = rval.m_RangedGarrisonCountValue; 

	// replace struct elements of m_BuildListSequenceElement
	for (index = 0; index < m_numBuildListSequenceElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numBuildListSequenceElement; obj_index++) 
			if (m_BuildListSequenceElement[index] == rval.m_BuildListSequenceElement[obj_index]) {
				// replace struct element 
				m_BuildListSequenceElement[index] = rval.m_BuildListSequenceElement[obj_index]; 
				}
	} 
	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_Research_Bit) != 0) 
		m_ResearchValue = rval.m_ResearchValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_StopResearch_Bit) != 0) 
		m_StopResearchValue = rval.m_StopResearchValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearInvasion_Bit) != 0) 
		m_FearInvasionValue = rval.m_FearInvasionValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearCityDefense_Bit) != 0) 
		m_FearCityDefenseValue = rval.m_FearCityDefenseValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearPiracy_Bit) != 0) 
		m_FearPiracyValue = rval.m_FearPiracyValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearScienceRank_Bit) != 0) 
		m_FearScienceRankValue = rval.m_FearScienceRankValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearMilitaryRank_Bit) != 0) 
		m_FearMilitaryRankValue = rval.m_FearMilitaryRankValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearTradeRank_Bit) != 0) 
		m_FearTradeRankValue = rval.m_FearTradeRankValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_FearPollution_Bit) != 0) 
		m_FearPollutionValue = rval.m_FearPollutionValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_DesireAttack_Bit) != 0) 
		m_DesireAttackValue = rval.m_DesireAttackValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_DesireGold_Bit) != 0) 
		m_DesireGoldValue = rval.m_DesireGoldValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Strategy_DesireScience_Bit) != 0) 
		m_DesireScienceValue = rval.m_DesireScienceValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_DesireMakeFriend_Bit) != 0) 
		m_DesireMakeFriendValue = rval.m_DesireMakeFriendValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_DesireEnlistFriend_Bit) != 0) 
		m_DesireEnlistFriendValue = rval.m_DesireEnlistFriendValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_PiracyMemoryTurns_Bit) != 0) 
		m_PiracyMemoryTurnsValue = rval.m_PiracyMemoryTurnsValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_MaxPiracyEvents_Bit) != 0) 
		m_MaxPiracyEventsValue = rval.m_MaxPiracyEventsValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_Offensive_Bit) != 0) 
		m_OffensiveValue = rval.m_OffensiveValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_Defensive_Bit) != 0) 
		m_DefensiveValue = rval.m_DefensiveValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_StealthAttack_Bit) != 0) 
		m_StealthAttackValue = rval.m_StealthAttackValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_Bombard_Bit) != 0) 
		m_BombardValue = rval.m_BombardValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_Special_Bit) != 0) 
		m_SpecialValue = rval.m_SpecialValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_Harass_Bit) != 0) 
		m_HarassValue = rval.m_HarassValue; 

	// only replace values that have been set
	if(rval.m_NuclearFirstStrike != 0x0) 
		m_NuclearFirstStrike = rval.m_NuclearFirstStrike; 

	// only replace values that have been set
	if(rval.m_NuclearTargeting != 0x0) 
		m_NuclearTargeting = rval.m_NuclearTargeting; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_PreemptiveStrikeRegard_Bit) != 0) 
		m_PreemptiveStrikeRegardValue = rval.m_PreemptiveStrikeRegardValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_PreemptiveStrikeRiskRatio_Bit) != 0) 
		m_PreemptiveStrikeRiskRatioValue = rval.m_PreemptiveStrikeRiskRatioValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Strategy_PreemptiveStrikeSuperiorityRatio_Bit) != 0) 
		m_PreemptiveStrikeSuperiorityRatioValue = rval.m_PreemptiveStrikeSuperiorityRatioValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
sint32 StrategyRecord::GetInheritIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return m_Inherit[index];
}

const StrategyRecord *StrategyRecord::GetInherit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return g_theStrategyDB->Get(m_Inherit[index]);
}

const StrategyRecord::PopAssignmentElement *StrategyRecord::GetPopAssignmentElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPopAssignmentElement);
    if((index < 0) || (index >= m_numPopAssignmentElement)) {
        return 0;
    }
    return &m_PopAssignmentElement[index];
}

sint32 StrategyRecord::GetGovernmentIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernment);
    if((index < 0) || (index >= m_numGovernment)) {
        return 0;
    }
    return m_Government[index];
}

const GovernmentRecord *StrategyRecord::GetGovernment(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernment);
    if((index < 0) || (index >= m_numGovernment)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_Government[index]);
}

const StrategyRecord::SliderElement *StrategyRecord::GetSliderElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSliderElement);
    if((index < 0) || (index >= m_numSliderElement)) {
        return 0;
    }
    return &m_SliderElement[index];
}

const ImprovementListRecord *StrategyRecord::GetImproveGrowthList() const
{
    return g_theImprovementListDB->Get(m_ImproveGrowthList);
}

const ImprovementListRecord *StrategyRecord::GetImproveProductionList() const
{
    return g_theImprovementListDB->Get(m_ImproveProductionList);
}

const ImprovementListRecord *StrategyRecord::GetImproveRandomList() const
{
    return g_theImprovementListDB->Get(m_ImproveRandomList);
}

const StrategyRecord::GoalElement *StrategyRecord::GetGoalElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGoalElement);
    if((index < 0) || (index >= m_numGoalElement)) {
        return 0;
    }
    return &m_GoalElement[index];
}

const UnitBuildListRecord *StrategyRecord::GetOffensiveUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_OffensiveUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetDefensiveUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_DefensiveUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetRangedUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_RangedUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetSeaUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SeaUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetAirUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_AirUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetSettlerUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SettlerUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetSpecialUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SpecialUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetSeaTransportUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_SeaTransportUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetAirTransportUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_AirTransportUnitListValue);
}

const UnitBuildListRecord *StrategyRecord::GetFreightUnitListPtr() const
{
    return g_theUnitBuildListDB->Get(m_FreightUnitListValue);
}

const StrategyRecord::BuildListSequenceElement *StrategyRecord::GetBuildListSequenceElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildListSequenceElement);
    if((index < 0) || (index >= m_numBuildListSequenceElement)) {
        return 0;
    }
    return &m_BuildListSequenceElement[index];
}

const AdvanceListRecord *StrategyRecord::GetResearchPtr() const
{
    return g_theAdvanceListDB->Get(m_ResearchValue);
}

const AdvanceListRecord *StrategyRecord::GetStopResearchPtr() const
{
    return g_theAdvanceListDB->Get(m_StopResearchValue);
}

const GoalRecord *StrategyRecord::GoalElement::GetGoal() const
{
    return g_theGoalDB->Get(m_Goal);
}

const BuildListSequenceRecord *StrategyRecord::BuildListSequenceElement::GetBuildListSequence() const
{
    return g_theBuildListSequenceDB->Get(m_BuildListSequence);
}

