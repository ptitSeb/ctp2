
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "SpecialAttackInfoRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "SoundRecord.h"
#include "SpecialEffectRecord.h"

CTPDatabase<SpecialAttackInfoRecord> *g_theSpecialAttackInfoDB = NULL;

SpecialAttackInfoRecord::Init()
{
    m_SoundID = 0x7fffffff;
    m_SpriteID = 0x7fffffff;
}

SpecialAttackInfoRecord::~SpecialAttackInfoRecord()
{
	int index = 0;
}

void SpecialAttackInfoRecord::operator=(const SpecialAttackInfoRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_SoundID = rval.m_SoundID; 

	m_SpriteID = rval.m_SpriteID; 

}

char *g_SpecialAttackInfo_Tokens[] =
{
    "SoundID",
    "SpriteID",
};

SpecialAttackInfoRecordAccessorInfo g_SpecialAttackInfoRecord_Accessors[] = 
{
    {SpecialAttackInfoRecord::GetSoundIDIndex, NULL, NULL, NULL, NULL },
    {SpecialAttackInfoRecord::GetSpriteIDIndex, NULL, NULL, NULL, NULL },
};

#define k_Token_SpecialAttackInfo_SoundID        ((k_Token_Custom_Base) + 0)
#define k_Token_SpecialAttackInfo_SpriteID       ((k_Token_Custom_Base) + 1)
#define k_Token_SpecialAttackInfo_Max            ((k_Token_Custom_Base) + 2)


static BitArray s_ParsedTokens(2);
void SpecialAttackInfoRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 SpecialAttackInfoRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_SpecialAttackInfo_Tokens, k_Token_SpecialAttackInfo_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_SpecialAttackInfo_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_SpecialAttackInfo_SoundID:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundID, err)) {
                    done = true; break;
                }
                break;
            case k_Token_SpecialAttackInfo_SpriteID:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_SpriteID, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void SpecialAttackInfoRecord::ResolveDBReferences()
{
    if(m_SoundID & 0x80000000) {
        sint32 id = m_SoundID & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundID)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundID == 0x7fffffff) {
        m_SoundID = -1;
    }
    if(m_SpriteID & 0x80000000) {
        sint32 id = m_SpriteID & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_SpriteID)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SpriteID == 0x7fffffff) {
        m_SpriteID = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void SpecialAttackInfoRecord::Merge(const SpecialAttackInfoRecord & rval){
	int index = 0, obj_index = 0;
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const SoundRecord *SpecialAttackInfoRecord::GetSoundID() const
{
    return g_theSoundDB->Get(m_SoundID);
}

const SpecialEffectRecord *SpecialAttackInfoRecord::GetSpriteID() const
{
    return g_theSpecialEffectDB->Get(m_SpriteID);
}

