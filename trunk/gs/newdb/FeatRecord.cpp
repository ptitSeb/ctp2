
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "FeatRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "AdvanceRecord.h"
#include "WonderRecord.h"
#include "FeatRecord.h"
#include "AdvanceRecord.h"
#include "WonderRecord.h"
#include "FeatRecord.h"
#include "BuildingRecord.h"

CTPDatabase<FeatRecord> *g_theFeatDB = NULL;

FeatRecord::Init()
{
    m_flags0 = 0;
    m_Duration = 0;
    m_Description = 0;
    m_SlicMessageValue = NULL;
    m_EffectBoatMovementValue = 0;
    m_EffectCityDefenseBonusValue = 0;
    m_EffectReduceCityWallsValue = 0;
    m_EffectIncreaseCityVisionValue = 0;
    m_EffectIncreaseProductionValue = 0;
    m_EffectIncreaseCommerceValue = 0;
    m_EffectIncreaseHappinessValue = 0;
    m_EffectEliminateDistancePenaltyValue = 0;
    m_EffectIncreaseBoatVisionValue = 0;
    m_EffectIncreaseScienceValue = 0;
    m_EffectIncreaseHitPointsValue = 0;
    m_EffectScriptedTurnValue = NULL;
    m_EffectScriptedCityValue = NULL;
    m_ExcludeAdvance = NULL;
    m_numExcludeAdvance = 0;
    m_ExcludeWonder = NULL;
    m_numExcludeWonder = 0;
    m_ExcludeFeat = NULL;
    m_numExcludeFeat = 0;
    m_ExcludeFunctionValue = NULL;
    m_CancelAdvance = NULL;
    m_numCancelAdvance = 0;
    m_CancelWonder = NULL;
    m_numCancelWonder = 0;
    m_CancelFeat = NULL;
    m_numCancelFeat = 0;
    m_CancelFunctionValue = NULL;
    memset(&m_BuildingValue, 0, sizeof(m_BuildingValue));
    m_MinimumSizeOfCivValue = 0;
}

FeatRecord::~FeatRecord()
{
	int index = 0;
	// free string attribute SlicMessageValue
	if (m_SlicMessageValue) 
		delete m_SlicMessageValue; 
	m_SlicMessageValue = NULL; 

	// free string attribute EffectScriptedTurnValue
	if (m_EffectScriptedTurnValue) 
		delete m_EffectScriptedTurnValue; 
	m_EffectScriptedTurnValue = NULL; 

	// free string attribute EffectScriptedCityValue
	if (m_EffectScriptedCityValue) 
		delete m_EffectScriptedCityValue; 
	m_EffectScriptedCityValue = NULL; 

	// free array ExcludeAdvance 
 	if (m_numExcludeAdvance > 0) 
		delete [m_numExcludeAdvance] m_ExcludeAdvance; 
	m_ExcludeAdvance = NULL; 
	m_numExcludeAdvance = 0; 

	// free array ExcludeWonder 
 	if (m_numExcludeWonder > 0) 
		delete [m_numExcludeWonder] m_ExcludeWonder; 
	m_ExcludeWonder = NULL; 
	m_numExcludeWonder = 0; 

	// free array ExcludeFeat 
 	if (m_numExcludeFeat > 0) 
		delete [m_numExcludeFeat] m_ExcludeFeat; 
	m_ExcludeFeat = NULL; 
	m_numExcludeFeat = 0; 

	// free string attribute ExcludeFunctionValue
	if (m_ExcludeFunctionValue) 
		delete m_ExcludeFunctionValue; 
	m_ExcludeFunctionValue = NULL; 

	// free array CancelAdvance 
 	if (m_numCancelAdvance > 0) 
		delete [m_numCancelAdvance] m_CancelAdvance; 
	m_CancelAdvance = NULL; 
	m_numCancelAdvance = 0; 

	// free array CancelWonder 
 	if (m_numCancelWonder > 0) 
		delete [m_numCancelWonder] m_CancelWonder; 
	m_CancelWonder = NULL; 
	m_numCancelWonder = 0; 

	// free array CancelFeat 
 	if (m_numCancelFeat > 0) 
		delete [m_numCancelFeat] m_CancelFeat; 
	m_CancelFeat = NULL; 
	m_numCancelFeat = 0; 

	// free string attribute CancelFunctionValue
	if (m_CancelFunctionValue) 
		delete m_CancelFunctionValue; 
	m_CancelFunctionValue = NULL; 

}

void FeatRecord::operator=(const FeatRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_Duration = rval.m_Duration; 

	m_Description = rval.m_Description; 

	m_flags0 = rval.m_flags0; 
		{ 
			delete m_SlicMessageValue; 
			m_SlicMessageValue = new char[strlen(rval.m_SlicMessageValue)+1]; 
			strcpy(m_SlicMessageValue, rval.m_SlicMessageValue); 
		} 

	m_flags0 = rval.m_flags0; 
		m_EffectBoatMovementValue = rval.m_EffectBoatMovementValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectCityDefenseBonusValue = rval.m_EffectCityDefenseBonusValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectReduceCityWallsValue = rval.m_EffectReduceCityWallsValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseCityVisionValue = rval.m_EffectIncreaseCityVisionValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseProductionValue = rval.m_EffectIncreaseProductionValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseCommerceValue = rval.m_EffectIncreaseCommerceValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseHappinessValue = rval.m_EffectIncreaseHappinessValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectEliminateDistancePenaltyValue = rval.m_EffectEliminateDistancePenaltyValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseBoatVisionValue = rval.m_EffectIncreaseBoatVisionValue; 

	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseScienceValue = rval.m_EffectIncreaseScienceValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
		m_EffectIncreaseHitPointsValue = rval.m_EffectIncreaseHitPointsValue; 

	m_flags0 = rval.m_flags0; 
		{ 
			delete m_EffectScriptedTurnValue; 
			m_EffectScriptedTurnValue = new char[strlen(rval.m_EffectScriptedTurnValue)+1]; 
			strcpy(m_EffectScriptedTurnValue, rval.m_EffectScriptedTurnValue); 
		} 

	m_flags0 = rval.m_flags0; 
		{ 
			delete m_EffectScriptedCityValue; 
			m_EffectScriptedCityValue = new char[strlen(rval.m_EffectScriptedCityValue)+1]; 
			strcpy(m_EffectScriptedCityValue, rval.m_EffectScriptedCityValue); 
		} 

	// free array ExcludeAdvance 
 	if (m_numExcludeAdvance > 0) 
	{
		delete [m_numExcludeAdvance] m_ExcludeAdvance; 
		m_ExcludeAdvance = NULL; 
		m_numExcludeAdvance = 0; 
	}
	if (rval.m_numExcludeAdvance > 0) 
	{
		m_ExcludeAdvance = new sint32 [rval.m_numExcludeAdvance]; 
		memcpy(m_ExcludeAdvance, rval.m_ExcludeAdvance, sizeof(sint32)*rval.m_numExcludeAdvance); 

	} 
	m_numExcludeAdvance = rval.m_numExcludeAdvance;

	// free array ExcludeWonder 
 	if (m_numExcludeWonder > 0) 
	{
		delete [m_numExcludeWonder] m_ExcludeWonder; 
		m_ExcludeWonder = NULL; 
		m_numExcludeWonder = 0; 
	}
	if (rval.m_numExcludeWonder > 0) 
	{
		m_ExcludeWonder = new sint32 [rval.m_numExcludeWonder]; 
		memcpy(m_ExcludeWonder, rval.m_ExcludeWonder, sizeof(sint32)*rval.m_numExcludeWonder); 

	} 
	m_numExcludeWonder = rval.m_numExcludeWonder;

	// free array ExcludeFeat 
 	if (m_numExcludeFeat > 0) 
	{
		delete [m_numExcludeFeat] m_ExcludeFeat; 
		m_ExcludeFeat = NULL; 
		m_numExcludeFeat = 0; 
	}
	if (rval.m_numExcludeFeat > 0) 
	{
		m_ExcludeFeat = new sint32 [rval.m_numExcludeFeat]; 
		memcpy(m_ExcludeFeat, rval.m_ExcludeFeat, sizeof(sint32)*rval.m_numExcludeFeat); 

	} 
	m_numExcludeFeat = rval.m_numExcludeFeat;

	m_flags0 = rval.m_flags0; 
		{ 
			delete m_ExcludeFunctionValue; 
			m_ExcludeFunctionValue = new char[strlen(rval.m_ExcludeFunctionValue)+1]; 
			strcpy(m_ExcludeFunctionValue, rval.m_ExcludeFunctionValue); 
		} 

	// free array CancelAdvance 
 	if (m_numCancelAdvance > 0) 
	{
		delete [m_numCancelAdvance] m_CancelAdvance; 
		m_CancelAdvance = NULL; 
		m_numCancelAdvance = 0; 
	}
	if (rval.m_numCancelAdvance > 0) 
	{
		m_CancelAdvance = new sint32 [rval.m_numCancelAdvance]; 
		memcpy(m_CancelAdvance, rval.m_CancelAdvance, sizeof(sint32)*rval.m_numCancelAdvance); 

	} 
	m_numCancelAdvance = rval.m_numCancelAdvance;

	// free array CancelWonder 
 	if (m_numCancelWonder > 0) 
	{
		delete [m_numCancelWonder] m_CancelWonder; 
		m_CancelWonder = NULL; 
		m_numCancelWonder = 0; 
	}
	if (rval.m_numCancelWonder > 0) 
	{
		m_CancelWonder = new sint32 [rval.m_numCancelWonder]; 
		memcpy(m_CancelWonder, rval.m_CancelWonder, sizeof(sint32)*rval.m_numCancelWonder); 

	} 
	m_numCancelWonder = rval.m_numCancelWonder;

	// free array CancelFeat 
 	if (m_numCancelFeat > 0) 
	{
		delete [m_numCancelFeat] m_CancelFeat; 
		m_CancelFeat = NULL; 
		m_numCancelFeat = 0; 
	}
	if (rval.m_numCancelFeat > 0) 
	{
		m_CancelFeat = new sint32 [rval.m_numCancelFeat]; 
		memcpy(m_CancelFeat, rval.m_CancelFeat, sizeof(sint32)*rval.m_numCancelFeat); 

	} 
	m_numCancelFeat = rval.m_numCancelFeat;

	m_flags0 = rval.m_flags0; 
		{ 
			delete m_CancelFunctionValue; 
			m_CancelFunctionValue = new char[strlen(rval.m_CancelFunctionValue)+1]; 
			strcpy(m_CancelFunctionValue, rval.m_CancelFunctionValue); 
		} 

	m_flags0 = rval.m_flags0; 
		m_BuildingValue = rval.m_BuildingValue; 

	m_flags0 = rval.m_flags0; 
		m_MinimumSizeOfCivValue = rval.m_MinimumSizeOfCivValue; 

}

char *g_Feat_Tokens[] =
{
    "Duration",
    "Description",
    "SlicMessage",
    "SlicMessageValue",
    "EffectBoatMovement",
    "EffectBoatMovementValue",
    "EffectCityDefenseBonus",
    "EffectCityDefenseBonusValue",
    "EffectReduceCityWalls",
    "EffectReduceCityWallsValue",
    "EffectIncreaseCityVision",
    "EffectIncreaseCityVisionValue",
    "EffectIncreaseProduction",
    "EffectIncreaseProductionValue",
    "EffectIncreaseCommerce",
    "EffectIncreaseCommerceValue",
    "EffectIncreaseHappiness",
    "EffectIncreaseHappinessValue",
    "EffectEliminateDistancePenalty",
    "EffectEliminateDistancePenaltyValue",
    "EffectIncreaseBoatVision",
    "EffectIncreaseBoatVisionValue",
    "EffectIncreaseScience",
    "EffectIncreaseScienceValue",
    "EffectGiveMaps",
    "EffectIncreaseHitPoints",
    "EffectIncreaseHitPointsValue",
    "EffectScriptedTurn",
    "EffectScriptedTurnValue",
    "EffectScriptedCity",
    "EffectScriptedCityValue",
    "ExcludeAdvance",
    "ExcludeWonder",
    "ExcludeFeat",
    "ExcludeFunction",
    "ExcludeFunctionValue",
    "CancelAdvance",
    "CancelWonder",
    "CancelFeat",
    "CancelFunction",
    "CancelFunctionValue",
    "Building",
    "BuildingValue",
    "MinimumSizeOfCiv",
    "MinimumSizeOfCivValue",
};

FeatRecordAccessorInfo g_FeatRecord_Accessors[] = 
{
    { FeatRecord::GetDuration, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Description */
    { NULL, NULL, NULL, NULL, NULL}, /* SlicMessage */
    { NULL, NULL, NULL, NULL, NULL}, /* SlicMessage */
    { NULL, NULL, NULL, FeatRecord::GetEffectBoatMovement, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectBoatMovement */
    { NULL, NULL, NULL, FeatRecord::GetEffectCityDefenseBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectCityDefenseBonus */
    { NULL, NULL, NULL, FeatRecord::GetEffectReduceCityWalls, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectReduceCityWalls */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseCityVision, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseCityVision */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseProduction, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseProduction */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseCommerce, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseCommerce */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseHappiness, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseHappiness */
    { NULL, NULL, NULL, FeatRecord::GetEffectEliminateDistancePenalty, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectEliminateDistancePenalty */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseBoatVision, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseBoatVision */
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseScience, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseScience */
    { NULL, FeatRecord::GetEffectGiveMaps, NULL, NULL, NULL },
    { NULL, NULL, NULL, FeatRecord::GetEffectIncreaseHitPoints, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EffectIncreaseHitPoints */
    { NULL, NULL, NULL, NULL, NULL}, /* EffectScriptedTurn */
    { NULL, NULL, NULL, NULL, NULL}, /* EffectScriptedTurn */
    { NULL, NULL, NULL, NULL, NULL}, /* EffectScriptedCity */
    { NULL, NULL, NULL, NULL, NULL}, /* EffectScriptedCity */
    { NULL, NULL, NULL, NULL, NULL}, /* ExcludeAdvance (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* ExcludeWonder (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* ExcludeFeat (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* ExcludeFunction */
    { NULL, NULL, NULL, NULL, NULL}, /* ExcludeFunction */
    { NULL, NULL, NULL, NULL, NULL}, /* CancelAdvance (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* CancelWonder (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* CancelFeat (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* CancelFunction */
    { NULL, NULL, NULL, NULL, NULL}, /* CancelFunction */
    { NULL, NULL, NULL, NULL, NULL}, /* Building */
    { NULL, NULL, NULL, NULL, NULL}, /* Building */
    { NULL, NULL, NULL, FeatRecord::GetMinimumSizeOfCiv, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinimumSizeOfCiv */
};

#define k_Token_Feat_Duration                    ((k_Token_Custom_Base) + 0)
#define k_Token_Feat_Description                 ((k_Token_Custom_Base) + 1)
#define k_Token_Feat_SlicMessage                 ((k_Token_Custom_Base) + 2)
#define k_Token_Feat_SlicMessage_Value           ((k_Token_Custom_Base) + 3)
#define k_Token_Feat_EffectBoatMovement          ((k_Token_Custom_Base) + 4)
#define k_Token_Feat_EffectBoatMovement_Value    ((k_Token_Custom_Base) + 5)
#define k_Token_Feat_EffectCityDefenseBonus      ((k_Token_Custom_Base) + 6)
#define k_Token_Feat_EffectCityDefenseBonus_Value ((k_Token_Custom_Base) + 7)
#define k_Token_Feat_EffectReduceCityWalls       ((k_Token_Custom_Base) + 8)
#define k_Token_Feat_EffectReduceCityWalls_Value ((k_Token_Custom_Base) + 9)
#define k_Token_Feat_EffectIncreaseCityVision    ((k_Token_Custom_Base) + 10)
#define k_Token_Feat_EffectIncreaseCityVision_Value ((k_Token_Custom_Base) + 11)
#define k_Token_Feat_EffectIncreaseProduction    ((k_Token_Custom_Base) + 12)
#define k_Token_Feat_EffectIncreaseProduction_Value ((k_Token_Custom_Base) + 13)
#define k_Token_Feat_EffectIncreaseCommerce      ((k_Token_Custom_Base) + 14)
#define k_Token_Feat_EffectIncreaseCommerce_Value ((k_Token_Custom_Base) + 15)
#define k_Token_Feat_EffectIncreaseHappiness     ((k_Token_Custom_Base) + 16)
#define k_Token_Feat_EffectIncreaseHappiness_Value ((k_Token_Custom_Base) + 17)
#define k_Token_Feat_EffectEliminateDistancePenalty ((k_Token_Custom_Base) + 18)
#define k_Token_Feat_EffectEliminateDistancePenalty_Value ((k_Token_Custom_Base) + 19)
#define k_Token_Feat_EffectIncreaseBoatVision    ((k_Token_Custom_Base) + 20)
#define k_Token_Feat_EffectIncreaseBoatVision_Value ((k_Token_Custom_Base) + 21)
#define k_Token_Feat_EffectIncreaseScience       ((k_Token_Custom_Base) + 22)
#define k_Token_Feat_EffectIncreaseScience_Value ((k_Token_Custom_Base) + 23)
#define k_Token_Feat_EffectGiveMaps              ((k_Token_Custom_Base) + 24)
#define k_Token_Feat_EffectIncreaseHitPoints     ((k_Token_Custom_Base) + 25)
#define k_Token_Feat_EffectIncreaseHitPoints_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Feat_EffectScriptedTurn          ((k_Token_Custom_Base) + 27)
#define k_Token_Feat_EffectScriptedTurn_Value    ((k_Token_Custom_Base) + 28)
#define k_Token_Feat_EffectScriptedCity          ((k_Token_Custom_Base) + 29)
#define k_Token_Feat_EffectScriptedCity_Value    ((k_Token_Custom_Base) + 30)
#define k_Token_Feat_ExcludeAdvance              ((k_Token_Custom_Base) + 31)
#define k_Token_Feat_ExcludeWonder               ((k_Token_Custom_Base) + 32)
#define k_Token_Feat_ExcludeFeat                 ((k_Token_Custom_Base) + 33)
#define k_Token_Feat_ExcludeFunction             ((k_Token_Custom_Base) + 34)
#define k_Token_Feat_ExcludeFunction_Value       ((k_Token_Custom_Base) + 35)
#define k_Token_Feat_CancelAdvance               ((k_Token_Custom_Base) + 36)
#define k_Token_Feat_CancelWonder                ((k_Token_Custom_Base) + 37)
#define k_Token_Feat_CancelFeat                  ((k_Token_Custom_Base) + 38)
#define k_Token_Feat_CancelFunction              ((k_Token_Custom_Base) + 39)
#define k_Token_Feat_CancelFunction_Value        ((k_Token_Custom_Base) + 40)
#define k_Token_Feat_Building                    ((k_Token_Custom_Base) + 41)
#define k_Token_Feat_Building_Value              ((k_Token_Custom_Base) + 42)
#define k_Token_Feat_MinimumSizeOfCiv            ((k_Token_Custom_Base) + 43)
#define k_Token_Feat_MinimumSizeOfCiv_Value      ((k_Token_Custom_Base) + 44)
#define k_Token_Feat_Max                         ((k_Token_Custom_Base) + 45)


static BitArray s_ParsedTokens(45);
void FeatRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Feat_Duration - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Duration missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Feat_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}
    
sint32 FeatRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Feat_Tokens, k_Token_Feat_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Feat_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Feat_Duration:
                if(!lex->GetIntAssignment(m_Duration)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_SlicMessage:
                m_flags0 |= k_Feat_SlicMessage_Bit;
                if(!lex->GetFileAssignment(m_SlicMessageValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectBoatMovement:
                m_flags0 |= k_Feat_EffectBoatMovement_Bit;
                if(!lex->GetIntAssignment(m_EffectBoatMovementValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectCityDefenseBonus:
                m_flags0 |= k_Feat_EffectCityDefenseBonus_Bit;
                if(!lex->GetIntAssignment(m_EffectCityDefenseBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectReduceCityWalls:
                m_flags0 |= k_Feat_EffectReduceCityWalls_Bit;
                if(!lex->GetIntAssignment(m_EffectReduceCityWallsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseCityVision:
                m_flags0 |= k_Feat_EffectIncreaseCityVision_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseCityVisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseProduction:
                m_flags0 |= k_Feat_EffectIncreaseProduction_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseProductionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseCommerce:
                m_flags0 |= k_Feat_EffectIncreaseCommerce_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseCommerceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseHappiness:
                m_flags0 |= k_Feat_EffectIncreaseHappiness_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseHappinessValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectEliminateDistancePenalty:
                m_flags0 |= k_Feat_EffectEliminateDistancePenalty_Bit;
                if(!lex->GetIntAssignment(m_EffectEliminateDistancePenaltyValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseBoatVision:
                m_flags0 |= k_Feat_EffectIncreaseBoatVision_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseBoatVisionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectIncreaseScience:
                m_flags0 |= k_Feat_EffectIncreaseScience_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseScienceValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectGiveMaps:
                m_flags0 |= k_Feat_EffectGiveMaps_Bit;
                break;
            case k_Token_Feat_EffectIncreaseHitPoints:
                m_flags0 |= k_Feat_EffectIncreaseHitPoints_Bit;
                if(!lex->GetIntAssignment(m_EffectIncreaseHitPointsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectScriptedTurn:
                m_flags0 |= k_Feat_EffectScriptedTurn_Bit;
                if(!lex->GetFileAssignment(m_EffectScriptedTurnValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_EffectScriptedCity:
                m_flags0 |= k_Feat_EffectScriptedCity_Bit;
                if(!lex->GetFileAssignment(m_EffectScriptedCityValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeAdvance, &m_numExcludeAdvance, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeWonder, &m_numExcludeWonder, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeFeat:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_ExcludeFeat, &m_numExcludeFeat, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_ExcludeFunction:
                m_flags0 |= k_Feat_ExcludeFunction_Bit;
                if(!lex->GetFileAssignment(m_ExcludeFunctionValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_CancelAdvance, &m_numCancelAdvance, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelWonder:
                if(!g_theWonderDB->ParseRecordInArray(lex, (sint32 **)&m_CancelWonder, &m_numCancelWonder, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelFeat:
                if(!g_theFeatDB->ParseRecordInArray(lex, (sint32 **)&m_CancelFeat, &m_numCancelFeat, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Feat_CancelFunction:
                m_flags0 |= k_Feat_CancelFunction_Bit;
                if(!lex->GetFileAssignment(m_CancelFunctionValue)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_Building:
                m_flags0 |= k_Feat_Building_Bit;
                if(!m_BuildingValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_MinimumSizeOfCiv:
                m_flags0 |= k_Feat_MinimumSizeOfCiv_Bit;
                if(!lex->GetIntAssignment(m_MinimumSizeOfCivValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void FeatRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numExcludeAdvance; i++) {
            if(m_ExcludeAdvance[i] & 0x80000000) {
                sint32 id = m_ExcludeAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ExcludeAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeAdvance[i] == 0x7fffffff){
                m_ExcludeAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludeWonder; i++) {
            if(m_ExcludeWonder[i] & 0x80000000) {
                sint32 id = m_ExcludeWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_ExcludeWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeWonder[i] == 0x7fffffff){
                m_ExcludeWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numExcludeFeat; i++) {
            if(m_ExcludeFeat[i] & 0x80000000) {
                sint32 id = m_ExcludeFeat[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_ExcludeFeat[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ExcludeFeat[i] == 0x7fffffff){
                m_ExcludeFeat[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelAdvance; i++) {
            if(m_CancelAdvance[i] & 0x80000000) {
                sint32 id = m_CancelAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_CancelAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelAdvance[i] == 0x7fffffff){
                m_CancelAdvance[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelWonder; i++) {
            if(m_CancelWonder[i] & 0x80000000) {
                sint32 id = m_CancelWonder[i] & 0x7fffffff;
                if(!g_theWonderDB->GetNamedItem(id, m_CancelWonder[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelWonder[i] == 0x7fffffff){
                m_CancelWonder[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numCancelFeat; i++) {
            if(m_CancelFeat[i] & 0x80000000) {
                sint32 id = m_CancelFeat[i] & 0x7fffffff;
                if(!g_theFeatDB->GetNamedItem(id, m_CancelFeat[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_CancelFeat[i] == 0x7fffffff){
                m_CancelFeat[i] = -1;
            }
        }
    }
    m_BuildingValue.ResolveDBReferences();
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
FeatRecord::BuildingFeat::BuildingFeat()
{
    m_flags0 = 0;
    m_Building = 0x7fffffff;
    m_NumValue = 0;
    m_PercentCitiesValue = 0;
}
FeatRecord::BuildingFeat::~BuildingFeat()
{
}
void FeatRecord::BuildingFeat::operator=(const BuildingFeat & rval)
{
	m_Building = rval.m_Building; 

	m_flags0 = rval.m_flags0; 
		m_NumValue = rval.m_NumValue; 

	m_flags0 = rval.m_flags0; 
		m_PercentCitiesValue = rval.m_PercentCitiesValue; 

}
static char *s_Feat_BuildingFeat_Tokens[] = {
    "Building",
    "Num",
    "PercentCities",
};
#define k_Token_Feat_BuildingFeat_Building       ((k_Token_Custom_Base) + 0)
#define k_Token_Feat_BuildingFeat_Num            ((k_Token_Custom_Base) + 1)
#define k_Token_Feat_BuildingFeat_PercentCities  ((k_Token_Custom_Base) + 2)
#define k_Token_Feat_BuildingFeat_Max ((k_Token_Custom_Base) + 3)
sint32 FeatRecord::BuildingFeat::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for BuildingFeat"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Feat_BuildingFeat_Tokens, k_Token_Feat_BuildingFeat_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Feat_BuildingFeat_Building:
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_Building, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Feat_BuildingFeat_Num:
                m_flags0 |= k_BuildingFeat_Num_Bit;
                if(!lex->GetIntAssignment(m_NumValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Feat_BuildingFeat_PercentCities:
                m_flags0 |= k_BuildingFeat_PercentCities_Bit;
                if(!lex->GetIntAssignment(m_PercentCitiesValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 FeatRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildingFeat *oldArray = *array;
        *array = new BuildingFeat[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildingFeat[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 FeatRecord::BuildingFeat::ParseInArray(DBLexer *lex, BuildingFeat *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void FeatRecord::BuildingFeat::ResolveDBReferences()
{
    if(m_Building & 0x80000000) {
        sint32 id = m_Building & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_Building)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Building == 0x7fffffff) {
        m_Building = -1;
    }
}
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void FeatRecord::Merge(const FeatRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_SlicMessage_Bit) != 0) 
		{ 
			delete m_SlicMessageValue; 
			m_SlicMessageValue = new char[strlen(rval.m_SlicMessageValue)+1]; 
			strcpy(m_SlicMessageValue, rval.m_SlicMessageValue); 
		} 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectBoatMovement_Bit) != 0) 
		m_EffectBoatMovementValue = rval.m_EffectBoatMovementValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectCityDefenseBonus_Bit) != 0) 
		m_EffectCityDefenseBonusValue = rval.m_EffectCityDefenseBonusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectReduceCityWalls_Bit) != 0) 
		m_EffectReduceCityWallsValue = rval.m_EffectReduceCityWallsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseCityVision_Bit) != 0) 
		m_EffectIncreaseCityVisionValue = rval.m_EffectIncreaseCityVisionValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseProduction_Bit) != 0) 
		m_EffectIncreaseProductionValue = rval.m_EffectIncreaseProductionValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseCommerce_Bit) != 0) 
		m_EffectIncreaseCommerceValue = rval.m_EffectIncreaseCommerceValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseHappiness_Bit) != 0) 
		m_EffectIncreaseHappinessValue = rval.m_EffectIncreaseHappinessValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectEliminateDistancePenalty_Bit) != 0) 
		m_EffectEliminateDistancePenaltyValue = rval.m_EffectEliminateDistancePenaltyValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseBoatVision_Bit) != 0) 
		m_EffectIncreaseBoatVisionValue = rval.m_EffectIncreaseBoatVisionValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseScience_Bit) != 0) 
		m_EffectIncreaseScienceValue = rval.m_EffectIncreaseScienceValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectIncreaseHitPoints_Bit) != 0) 
		m_EffectIncreaseHitPointsValue = rval.m_EffectIncreaseHitPointsValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectScriptedTurn_Bit) != 0) 
		{ 
			delete m_EffectScriptedTurnValue; 
			m_EffectScriptedTurnValue = new char[strlen(rval.m_EffectScriptedTurnValue)+1]; 
			strcpy(m_EffectScriptedTurnValue, rval.m_EffectScriptedTurnValue); 
		} 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_EffectScriptedCity_Bit) != 0) 
		{ 
			delete m_EffectScriptedCityValue; 
			m_EffectScriptedCityValue = new char[strlen(rval.m_EffectScriptedCityValue)+1]; 
			strcpy(m_EffectScriptedCityValue, rval.m_EffectScriptedCityValue); 
		} 

	// resize m_ExcludeAdvance if necessary
	if (rval.m_numExcludeAdvance > m_numExcludeAdvance)
 	{ 
		delete m_ExcludeAdvance;
 		m_ExcludeAdvance = NULL;
 		if (rval.m_numExcludeAdvance > 0)
 			m_ExcludeAdvance = new sint32 [rval.m_numExcludeAdvance]; 
		m_numExcludeAdvance = rval.m_numExcludeAdvance;
 	} 

	// copy values of rval.m_ExcludeAdvance to m_ExcludeAdvance
	for (index = 0; index < m_numExcludeAdvance; index++) 
	{ 
 		if (index < rval.m_numExcludeAdvance)
 			m_ExcludeAdvance[index] = rval.m_ExcludeAdvance[index];
	} 
 	// resize m_ExcludeWonder if necessary
	if (rval.m_numExcludeWonder > m_numExcludeWonder)
 	{ 
		delete m_ExcludeWonder;
 		m_ExcludeWonder = NULL;
 		if (rval.m_numExcludeWonder > 0)
 			m_ExcludeWonder = new sint32 [rval.m_numExcludeWonder]; 
		m_numExcludeWonder = rval.m_numExcludeWonder;
 	} 

	// copy values of rval.m_ExcludeWonder to m_ExcludeWonder
	for (index = 0; index < m_numExcludeWonder; index++) 
	{ 
 		if (index < rval.m_numExcludeWonder)
 			m_ExcludeWonder[index] = rval.m_ExcludeWonder[index];
	} 
 	// resize m_ExcludeFeat if necessary
	if (rval.m_numExcludeFeat > m_numExcludeFeat)
 	{ 
		delete m_ExcludeFeat;
 		m_ExcludeFeat = NULL;
 		if (rval.m_numExcludeFeat > 0)
 			m_ExcludeFeat = new sint32 [rval.m_numExcludeFeat]; 
		m_numExcludeFeat = rval.m_numExcludeFeat;
 	} 

	// copy values of rval.m_ExcludeFeat to m_ExcludeFeat
	for (index = 0; index < m_numExcludeFeat; index++) 
	{ 
 		if (index < rval.m_numExcludeFeat)
 			m_ExcludeFeat[index] = rval.m_ExcludeFeat[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_ExcludeFunction_Bit) != 0) 
		{ 
			delete m_ExcludeFunctionValue; 
			m_ExcludeFunctionValue = new char[strlen(rval.m_ExcludeFunctionValue)+1]; 
			strcpy(m_ExcludeFunctionValue, rval.m_ExcludeFunctionValue); 
		} 

	// resize m_CancelAdvance if necessary
	if (rval.m_numCancelAdvance > m_numCancelAdvance)
 	{ 
		delete m_CancelAdvance;
 		m_CancelAdvance = NULL;
 		if (rval.m_numCancelAdvance > 0)
 			m_CancelAdvance = new sint32 [rval.m_numCancelAdvance]; 
		m_numCancelAdvance = rval.m_numCancelAdvance;
 	} 

	// copy values of rval.m_CancelAdvance to m_CancelAdvance
	for (index = 0; index < m_numCancelAdvance; index++) 
	{ 
 		if (index < rval.m_numCancelAdvance)
 			m_CancelAdvance[index] = rval.m_CancelAdvance[index];
	} 
 	// resize m_CancelWonder if necessary
	if (rval.m_numCancelWonder > m_numCancelWonder)
 	{ 
		delete m_CancelWonder;
 		m_CancelWonder = NULL;
 		if (rval.m_numCancelWonder > 0)
 			m_CancelWonder = new sint32 [rval.m_numCancelWonder]; 
		m_numCancelWonder = rval.m_numCancelWonder;
 	} 

	// copy values of rval.m_CancelWonder to m_CancelWonder
	for (index = 0; index < m_numCancelWonder; index++) 
	{ 
 		if (index < rval.m_numCancelWonder)
 			m_CancelWonder[index] = rval.m_CancelWonder[index];
	} 
 	// resize m_CancelFeat if necessary
	if (rval.m_numCancelFeat > m_numCancelFeat)
 	{ 
		delete m_CancelFeat;
 		m_CancelFeat = NULL;
 		if (rval.m_numCancelFeat > 0)
 			m_CancelFeat = new sint32 [rval.m_numCancelFeat]; 
		m_numCancelFeat = rval.m_numCancelFeat;
 	} 

	// copy values of rval.m_CancelFeat to m_CancelFeat
	for (index = 0; index < m_numCancelFeat; index++) 
	{ 
 		if (index < rval.m_numCancelFeat)
 			m_CancelFeat[index] = rval.m_CancelFeat[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_CancelFunction_Bit) != 0) 
		{ 
			delete m_CancelFunctionValue; 
			m_CancelFunctionValue = new char[strlen(rval.m_CancelFunctionValue)+1]; 
			strcpy(m_CancelFunctionValue, rval.m_CancelFunctionValue); 
		} 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_Building_Bit) != 0) 
		m_BuildingValue = rval.m_BuildingValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Feat_MinimumSizeOfCiv_Bit) != 0) 
		m_MinimumSizeOfCivValue = rval.m_MinimumSizeOfCivValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
sint32 FeatRecord::GetExcludeAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeAdvance);
    if((index < 0) || (index >= m_numExcludeAdvance)) {
        return 0;
    }
    return m_ExcludeAdvance[index];
}

const AdvanceRecord *FeatRecord::GetExcludeAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeAdvance);
    if((index < 0) || (index >= m_numExcludeAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ExcludeAdvance[index]);
}

sint32 FeatRecord::GetExcludeWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeWonder);
    if((index < 0) || (index >= m_numExcludeWonder)) {
        return 0;
    }
    return m_ExcludeWonder[index];
}

const WonderRecord *FeatRecord::GetExcludeWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeWonder);
    if((index < 0) || (index >= m_numExcludeWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_ExcludeWonder[index]);
}

sint32 FeatRecord::GetExcludeFeatIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeFeat);
    if((index < 0) || (index >= m_numExcludeFeat)) {
        return 0;
    }
    return m_ExcludeFeat[index];
}

const FeatRecord *FeatRecord::GetExcludeFeat(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numExcludeFeat);
    if((index < 0) || (index >= m_numExcludeFeat)) {
        return 0;
    }
    return g_theFeatDB->Get(m_ExcludeFeat[index]);
}

sint32 FeatRecord::GetCancelAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelAdvance);
    if((index < 0) || (index >= m_numCancelAdvance)) {
        return 0;
    }
    return m_CancelAdvance[index];
}

const AdvanceRecord *FeatRecord::GetCancelAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelAdvance);
    if((index < 0) || (index >= m_numCancelAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_CancelAdvance[index]);
}

sint32 FeatRecord::GetCancelWonderIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelWonder);
    if((index < 0) || (index >= m_numCancelWonder)) {
        return 0;
    }
    return m_CancelWonder[index];
}

const WonderRecord *FeatRecord::GetCancelWonder(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelWonder);
    if((index < 0) || (index >= m_numCancelWonder)) {
        return 0;
    }
    return g_theWonderDB->Get(m_CancelWonder[index]);
}

sint32 FeatRecord::GetCancelFeatIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelFeat);
    if((index < 0) || (index >= m_numCancelFeat)) {
        return 0;
    }
    return m_CancelFeat[index];
}

const FeatRecord *FeatRecord::GetCancelFeat(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numCancelFeat);
    if((index < 0) || (index >= m_numCancelFeat)) {
        return 0;
    }
    return g_theFeatDB->Get(m_CancelFeat[index]);
}

const BuildingRecord *FeatRecord::BuildingFeat::GetBuilding() const
{
    return g_theBuildingDB->Get(m_Building);
}

