
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "IconRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"


CTPDatabase<IconRecord> *g_theIconDB = NULL;

IconRecord::Init()
{
    m_Icon = NULL;
    m_Movie = NULL;
    m_Gameplay = NULL;
    m_Historical = NULL;
    m_Prereq = NULL;
    m_Vari = NULL;
    m_FirstFrame = NULL;
    m_StatText = NULL;
    m_LargeIcon = NULL;
    m_SmallIcon = NULL;
}

IconRecord::~IconRecord()
{
	int index = 0;
	// free string attribute Icon
	if (m_Icon) 
		delete m_Icon; 
	m_Icon = NULL; 

	// free string attribute Movie
	if (m_Movie) 
		delete m_Movie; 
	m_Movie = NULL; 

	// free string attribute Gameplay
	if (m_Gameplay) 
		delete m_Gameplay; 
	m_Gameplay = NULL; 

	// free string attribute Historical
	if (m_Historical) 
		delete m_Historical; 
	m_Historical = NULL; 

	// free string attribute Prereq
	if (m_Prereq) 
		delete m_Prereq; 
	m_Prereq = NULL; 

	// free string attribute Vari
	if (m_Vari) 
		delete m_Vari; 
	m_Vari = NULL; 

	// free string attribute FirstFrame
	if (m_FirstFrame) 
		delete m_FirstFrame; 
	m_FirstFrame = NULL; 

	// free string attribute StatText
	if (m_StatText) 
		delete m_StatText; 
	m_StatText = NULL; 

	// free string attribute LargeIcon
	if (m_LargeIcon) 
		delete m_LargeIcon; 
	m_LargeIcon = NULL; 

	// free string attribute SmallIcon
	if (m_SmallIcon) 
		delete m_SmallIcon; 
	m_SmallIcon = NULL; 

}

void IconRecord::operator=(const IconRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	if (m_Icon) 
	{ 
	delete m_Icon; 

	}

	if (rval.m_Icon) 
	{ 
		m_Icon = new char [strlen(rval.m_Icon)+1]; 
		strcpy(m_Icon, rval.m_Icon);
	}

	if (m_Movie) 
	{ 
	delete m_Movie; 

	}

	if (rval.m_Movie) 
	{ 
		m_Movie = new char [strlen(rval.m_Movie)+1]; 
		strcpy(m_Movie, rval.m_Movie);
	}

	if (m_Gameplay) 
	{ 
	delete m_Gameplay; 

	}

	if (rval.m_Gameplay) 
	{ 
		m_Gameplay = new char [strlen(rval.m_Gameplay)+1]; 
		strcpy(m_Gameplay, rval.m_Gameplay);
	}

	if (m_Historical) 
	{ 
	delete m_Historical; 

	}

	if (rval.m_Historical) 
	{ 
		m_Historical = new char [strlen(rval.m_Historical)+1]; 
		strcpy(m_Historical, rval.m_Historical);
	}

	if (m_Prereq) 
	{ 
	delete m_Prereq; 

	}

	if (rval.m_Prereq) 
	{ 
		m_Prereq = new char [strlen(rval.m_Prereq)+1]; 
		strcpy(m_Prereq, rval.m_Prereq);
	}

	if (m_Vari) 
	{ 
	delete m_Vari; 

	}

	if (rval.m_Vari) 
	{ 
		m_Vari = new char [strlen(rval.m_Vari)+1]; 
		strcpy(m_Vari, rval.m_Vari);
	}

	if (m_FirstFrame) 
	{ 
	delete m_FirstFrame; 

	}

	if (rval.m_FirstFrame) 
	{ 
		m_FirstFrame = new char [strlen(rval.m_FirstFrame)+1]; 
		strcpy(m_FirstFrame, rval.m_FirstFrame);
	}

	if (m_StatText) 
	{ 
	delete m_StatText; 

	}

	if (rval.m_StatText) 
	{ 
		m_StatText = new char [strlen(rval.m_StatText)+1]; 
		strcpy(m_StatText, rval.m_StatText);
	}

	if (m_LargeIcon) 
	{ 
	delete m_LargeIcon; 

	}

	if (rval.m_LargeIcon) 
	{ 
		m_LargeIcon = new char [strlen(rval.m_LargeIcon)+1]; 
		strcpy(m_LargeIcon, rval.m_LargeIcon);
	}

	if (m_SmallIcon) 
	{ 
	delete m_SmallIcon; 

	}

	if (rval.m_SmallIcon) 
	{ 
		m_SmallIcon = new char [strlen(rval.m_SmallIcon)+1]; 
		strcpy(m_SmallIcon, rval.m_SmallIcon);
	}

}

char *g_Icon_Tokens[] =
{
    "Icon",
    "Movie",
    "Gameplay",
    "Historical",
    "Prereq",
    "Vari",
    "FirstFrame",
    "StatText",
    "LargeIcon",
    "SmallIcon",
};

IconRecordAccessorInfo g_IconRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Icon */
    { NULL, NULL, NULL, NULL, NULL}, /* Movie */
    { NULL, NULL, NULL, NULL, NULL}, /* Gameplay */
    { NULL, NULL, NULL, NULL, NULL}, /* Historical */
    { NULL, NULL, NULL, NULL, NULL}, /* Prereq */
    { NULL, NULL, NULL, NULL, NULL}, /* Vari */
    { NULL, NULL, NULL, NULL, NULL}, /* FirstFrame */
    { NULL, NULL, NULL, NULL, NULL}, /* StatText */
    { NULL, NULL, NULL, NULL, NULL}, /* LargeIcon */
    { NULL, NULL, NULL, NULL, NULL}, /* SmallIcon */
};

#define k_Token_Icon_Icon                        ((k_Token_Custom_Base) + 0)
#define k_Token_Icon_Movie                       ((k_Token_Custom_Base) + 1)
#define k_Token_Icon_Gameplay                    ((k_Token_Custom_Base) + 2)
#define k_Token_Icon_Historical                  ((k_Token_Custom_Base) + 3)
#define k_Token_Icon_Prereq                      ((k_Token_Custom_Base) + 4)
#define k_Token_Icon_Vari                        ((k_Token_Custom_Base) + 5)
#define k_Token_Icon_FirstFrame                  ((k_Token_Custom_Base) + 6)
#define k_Token_Icon_StatText                    ((k_Token_Custom_Base) + 7)
#define k_Token_Icon_LargeIcon                   ((k_Token_Custom_Base) + 8)
#define k_Token_Icon_SmallIcon                   ((k_Token_Custom_Base) + 9)
#define k_Token_Icon_Max                         ((k_Token_Custom_Base) + 10)


static BitArray s_ParsedTokens(10);
void IconRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Icon_Icon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Icon missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Movie - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Movie missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Gameplay - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Gameplay missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Historical - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Historical missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Prereq - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Prereq missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_Vari - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Vari missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_FirstFrame - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field FirstFrame missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_StatText - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StatText missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_LargeIcon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field LargeIcon missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Icon_SmallIcon - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field SmallIcon missing"));
    }
}
    
sint32 IconRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Icon_Tokens, k_Token_Icon_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Icon_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Icon_Icon:
                if(!lex->GetFileAssignment(m_Icon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Movie:
                if(!lex->GetFileAssignment(m_Movie)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Gameplay:
                if(!lex->GetFileAssignment(m_Gameplay)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Historical:
                if(!lex->GetFileAssignment(m_Historical)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Prereq:
                if(!lex->GetFileAssignment(m_Prereq)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_Vari:
                if(!lex->GetFileAssignment(m_Vari)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_FirstFrame:
                if(!lex->GetFileAssignment(m_FirstFrame)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_StatText:
                if(!lex->GetFileAssignment(m_StatText)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_LargeIcon:
                if(!lex->GetFileAssignment(m_LargeIcon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_Icon_SmallIcon:
                if(!lex->GetFileAssignment(m_SmallIcon)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void IconRecord::ResolveDBReferences()
{
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void IconRecord::Merge(const IconRecord & rval){
	int index = 0, obj_index = 0;
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
