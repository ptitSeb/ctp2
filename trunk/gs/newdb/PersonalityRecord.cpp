
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "PersonalityRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"


CTPDatabase<PersonalityRecord> *g_thePersonalityDB = NULL;

PersonalityRecord::Init()
{
    m_Exploration = 0;
    m_Expansion = 0;
    m_Discovery = 0;
    m_Conquest = 0;
    m_Trustworthiness = 0;
    m_Alignment = 0;
    m_StrongGreeting = 0;
    m_WeakGreeting = 0;
    m_ThreatFollowThrough = 0.000000;
    m_Description = 0;
}

PersonalityRecord::~PersonalityRecord()
{
	int index = 0;
}

void PersonalityRecord::operator=(const PersonalityRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_Exploration = rval.m_Exploration; 

	m_Expansion = rval.m_Expansion; 

	m_Discovery = rval.m_Discovery; 

	m_Conquest = rval.m_Conquest; 

	m_Trustworthiness = rval.m_Trustworthiness; 

	m_Alignment = rval.m_Alignment; 

	m_StrongGreeting = rval.m_StrongGreeting; 

	m_WeakGreeting = rval.m_WeakGreeting; 

	m_ThreatFollowThrough = rval.m_ThreatFollowThrough; 

	m_Description = rval.m_Description; 

}

char *g_Personality_Tokens[] =
{
    "Exploration",
    "Expansion",
    "Discovery",
    "Conquest",
    "Trustworthiness",
    "Alignment",
    "StrongGreeting",
    "WeakGreeting",
    "ThreatFollowThrough",
    "Description",
};

PersonalityRecordAccessorInfo g_PersonalityRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Exploration */
    { NULL, NULL, NULL, NULL, NULL}, /* Expansion */
    { NULL, NULL, NULL, NULL, NULL}, /* Discovery */
    { NULL, NULL, NULL, NULL, NULL}, /* Conquest */
    { NULL, NULL, NULL, NULL, NULL}, /* Trustworthiness */
    { NULL, NULL, NULL, NULL, NULL}, /* Alignment */
    { NULL, NULL, NULL, NULL, NULL}, /* StrongGreeting */
    { NULL, NULL, NULL, NULL, NULL}, /* WeakGreeting */
    { NULL, NULL, PersonalityRecord::GetThreatFollowThrough, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Description */
};

#define k_Token_Personality_Exploration          ((k_Token_Custom_Base) + 0)
#define k_Token_Personality_Expansion            ((k_Token_Custom_Base) + 1)
#define k_Token_Personality_Discovery            ((k_Token_Custom_Base) + 2)
#define k_Token_Personality_Conquest             ((k_Token_Custom_Base) + 3)
#define k_Token_Personality_Trustworthiness      ((k_Token_Custom_Base) + 4)
#define k_Token_Personality_Alignment            ((k_Token_Custom_Base) + 5)
#define k_Token_Personality_StrongGreeting       ((k_Token_Custom_Base) + 6)
#define k_Token_Personality_WeakGreeting         ((k_Token_Custom_Base) + 7)
#define k_Token_Personality_ThreatFollowThrough  ((k_Token_Custom_Base) + 8)
#define k_Token_Personality_Description          ((k_Token_Custom_Base) + 9)
#define k_Token_Personality_Max                  ((k_Token_Custom_Base) + 10)


static BitArray s_ParsedTokens(10);
void PersonalityRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Personality_StrongGreeting - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field StrongGreeting missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_WeakGreeting - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field WeakGreeting missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_ThreatFollowThrough - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ThreatFollowThrough missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Personality_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
}
    
sint32 PersonalityRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Personality_Tokens, k_Token_Personality_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Personality_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Personality_Exploration:
                if(!ParseExplorationBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Expansion:
                if(!ParseExpansionBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Discovery:
                if(!ParseDiscoveryBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Conquest:
                if(!ParseConquestBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Trustworthiness:
                if(!ParseTrustworthinessBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_Alignment:
                if(!ParseAlignmentBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Personality_StrongGreeting:
                if(!lex->GetStringIdAssignment(m_StrongGreeting)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_WeakGreeting:
                if(!lex->GetStringIdAssignment(m_WeakGreeting)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_ThreatFollowThrough:
                if(!lex->GetFloatAssignment(m_ThreatFollowThrough)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Personality_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void PersonalityRecord::ResolveDBReferences()
{
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
static char *s_Personality_Exploration_BitNames[] = {
    "Wide",
    "Medium",
    "Minimal",
};
#define k_Personality_Exploration_Num_BitNames 3

sint32 PersonalityRecord::ParseExplorationBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Exploration_BitNames, k_Personality_Exploration_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Exploration", lex->GetTokenText()));
        return 0;
    }
    m_Exploration |= (1 << bitindex);
    return 1;
}

static char *s_Personality_Expansion_BitNames[] = {
    "Maximum",
    "Average",
    "Minimum",
};
#define k_Personality_Expansion_Num_BitNames 3

sint32 PersonalityRecord::ParseExpansionBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Expansion_BitNames, k_Personality_Expansion_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Expansion", lex->GetTokenText()));
        return 0;
    }
    m_Expansion |= (1 << bitindex);
    return 1;
}

static char *s_Personality_Discovery_BitNames[] = {
    "Scientist",
    "Military",
    "Economic",
    "Ecotopian",
    "Diplomatic",
};
#define k_Personality_Discovery_Num_BitNames 5

sint32 PersonalityRecord::ParseDiscoveryBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Discovery_BitNames, k_Personality_Discovery_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Discovery", lex->GetTokenText()));
        return 0;
    }
    m_Discovery |= (1 << bitindex);
    return 1;
}

static char *s_Personality_Conquest_BitNames[] = {
    "Agressive",
    "Neutral",
    "Passive",
};
#define k_Personality_Conquest_Num_BitNames 3

sint32 PersonalityRecord::ParseConquestBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Conquest_BitNames, k_Personality_Conquest_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Conquest", lex->GetTokenText()));
        return 0;
    }
    m_Conquest |= (1 << bitindex);
    return 1;
}

static char *s_Personality_Trustworthiness_BitNames[] = {
    "Chaotic",
    "Neutral",
    "Lawful",
};
#define k_Personality_Trustworthiness_Num_BitNames 3

sint32 PersonalityRecord::ParseTrustworthinessBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Trustworthiness_BitNames, k_Personality_Trustworthiness_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Trustworthiness", lex->GetTokenText()));
        return 0;
    }
    m_Trustworthiness |= (1 << bitindex);
    return 1;
}

static char *s_Personality_Alignment_BitNames[] = {
    "Evil",
    "Neutral",
    "Good",
};
#define k_Personality_Alignment_Num_BitNames 3

sint32 PersonalityRecord::ParseAlignmentBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Personality_Alignment_BitNames, k_Personality_Alignment_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Alignment", lex->GetTokenText()));
        return 0;
    }
    m_Alignment |= (1 << bitindex);
    return 1;
}

void PersonalityRecord::Merge(const PersonalityRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if(rval.m_Exploration != 0x0) 
		m_Exploration = rval.m_Exploration; 

	// only replace values that have been set
	if(rval.m_Expansion != 0x0) 
		m_Expansion = rval.m_Expansion; 

	// only replace values that have been set
	if(rval.m_Discovery != 0x0) 
		m_Discovery = rval.m_Discovery; 

	// only replace values that have been set
	if(rval.m_Conquest != 0x0) 
		m_Conquest = rval.m_Conquest; 

	// only replace values that have been set
	if(rval.m_Trustworthiness != 0x0) 
		m_Trustworthiness = rval.m_Trustworthiness; 

	// only replace values that have been set
	if(rval.m_Alignment != 0x0) 
		m_Alignment = rval.m_Alignment; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
