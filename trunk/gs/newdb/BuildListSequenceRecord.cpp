
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "BuildListSequenceRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "WonderBuildListRecord.h"
#include "BuildingBuildListRecord.h"

CTPDatabase<BuildListSequenceRecord> *g_theBuildListSequenceDB = NULL;

BuildListSequenceRecord::Init()
{
    m_BuildListElement = NULL;
    m_numBuildListElement = 0;
}

BuildListSequenceRecord::~BuildListSequenceRecord()
{
	int index = 0;
	// free array BuildListElement 
 			// free struct elements
	if (m_numBuildListElement > 0) 
		delete [m_numBuildListElement] m_BuildListElement; 
	m_BuildListElement = NULL; 
	m_numBuildListElement = 0; 

}

void BuildListSequenceRecord::operator=(const BuildListSequenceRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	// free array BuildListElement 
 	// free struct elements of BuildListElement[]
	if (m_numBuildListElement > 0) 
	{
		delete [m_numBuildListElement] m_BuildListElement; 
		m_BuildListElement = NULL; 
	}

	if (rval.m_numBuildListElement > 0) 
	{
		m_BuildListElement = new BuildListElement [rval.m_numBuildListElement];
	}

	// copy struct elements of BuildListElement[]
	for (index = 0; index < rval.m_numBuildListElement; index++) 
		{ 
			m_BuildListElement[index] = rval.m_BuildListElement[index]; 
	} 
	m_numBuildListElement = rval.m_numBuildListElement;

}

char *g_BuildListSequence_Tokens[] =
{
    "BuildListElement",
};

BuildListSequenceRecordAccessorInfo g_BuildListSequenceRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* BuildListElement */
};

#define k_Token_BuildListSequence_BuildListElement ((k_Token_Custom_Base) + 0)
#define k_Token_BuildListSequence_Max            ((k_Token_Custom_Base) + 1)


static BitArray s_ParsedTokens(1);
void BuildListSequenceRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 BuildListSequenceRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_BuildListSequence_Tokens, k_Token_BuildListSequence_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_BuildListSequence_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_BuildListSequence_BuildListElement:
                if(!BuildListSequenceRecord::BuildListElement::ParseInArray(lex, &m_BuildListElement, &m_numBuildListElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void BuildListSequenceRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numBuildListElement; i++) {
            m_BuildListElement[i].ResolveDBReferences();
        }
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
BuildListSequenceRecord::BuildListElement::BuildListElement()
{
    m_flags0 = 0;
    m_WonderBuildListValue = 0;
    m_BuildingBuildListValue = 0;
}
BuildListSequenceRecord::BuildListElement::~BuildListElement()
{
}
void BuildListSequenceRecord::BuildListElement::operator=(const BuildListElement & rval)
{
	m_flags0 = rval.m_flags0; 
		m_WonderBuildListValue = rval.m_WonderBuildListValue; 

	m_flags0 = rval.m_flags0; 
		m_BuildingBuildListValue = rval.m_BuildingBuildListValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
}
static char *s_BuildListSequence_BuildListElement_Tokens[] = {
    "WonderBuildList",
    "BuildingBuildList",
    "AllUnitBuildList",
    "GarrisonUnitBuildList",
    "Capitalization",
    "Infrastructure",
    "Freight",
};
#define k_Token_BuildListSequence_BuildListElement_WonderBuildList ((k_Token_Custom_Base) + 0)
#define k_Token_BuildListSequence_BuildListElement_BuildingBuildList ((k_Token_Custom_Base) + 1)
#define k_Token_BuildListSequence_BuildListElement_AllUnitBuildList ((k_Token_Custom_Base) + 2)
#define k_Token_BuildListSequence_BuildListElement_GarrisonUnitBuildList ((k_Token_Custom_Base) + 3)
#define k_Token_BuildListSequence_BuildListElement_Capitalization ((k_Token_Custom_Base) + 4)
#define k_Token_BuildListSequence_BuildListElement_Infrastructure ((k_Token_Custom_Base) + 5)
#define k_Token_BuildListSequence_BuildListElement_Freight ((k_Token_Custom_Base) + 6)
#define k_Token_BuildListSequence_BuildListElement_Max ((k_Token_Custom_Base) + 7)
sint32 BuildListSequenceRecord::BuildListElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for BuildListElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_BuildListSequence_BuildListElement_Tokens, k_Token_BuildListSequence_BuildListElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_BuildListSequence_BuildListElement_WonderBuildList:
                m_flags0 |= k_BuildListElement_WonderBuildList_Bit;
                if(!g_theWonderBuildListDB->GetRecordFromLexer(lex, m_WonderBuildListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_BuildListSequence_BuildListElement_BuildingBuildList:
                m_flags0 |= k_BuildListElement_BuildingBuildList_Bit;
                if(!g_theBuildingBuildListDB->GetRecordFromLexer(lex, m_BuildingBuildListValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_BuildListSequence_BuildListElement_AllUnitBuildList:
                m_flags0 |= k_BuildListElement_AllUnitBuildList_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_GarrisonUnitBuildList:
                m_flags0 |= k_BuildListElement_GarrisonUnitBuildList_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Capitalization:
                m_flags0 |= k_BuildListElement_Capitalization_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Infrastructure:
                m_flags0 |= k_BuildListElement_Infrastructure_Bit;
                break;
            case k_Token_BuildListSequence_BuildListElement_Freight:
                m_flags0 |= k_BuildListElement_Freight_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 BuildListSequenceRecord::BuildListElement::ParseInArray(DBLexer *lex, BuildListElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        BuildListElement *oldArray = *array;
        *array = new BuildListElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new BuildListElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 BuildListSequenceRecord::BuildListElement::ParseInArray(DBLexer *lex, BuildListElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void BuildListSequenceRecord::BuildListElement::ResolveDBReferences()
{
}
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void BuildListSequenceRecord::Merge(const BuildListSequenceRecord & rval){
	int index = 0, obj_index = 0;
	// replace struct elements of m_BuildListElement
	for (index = 0; index < m_numBuildListElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numBuildListElement; obj_index++) 
			if (m_BuildListElement[index] == rval.m_BuildListElement[obj_index]) {
				// replace struct element 
				m_BuildListElement[index] = rval.m_BuildListElement[obj_index]; 
				}
	} 
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const BuildListSequenceRecord::BuildListElement *BuildListSequenceRecord::GetBuildListElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numBuildListElement);
    if((index < 0) || (index >= m_numBuildListElement)) {
        return 0;
    }
    return &m_BuildListElement[index];
}

const WonderBuildListRecord *BuildListSequenceRecord::BuildListElement::GetWonderBuildListPtr() const
{
    return g_theWonderBuildListDB->Get(m_WonderBuildListValue);
}

const BuildingBuildListRecord *BuildListSequenceRecord::BuildListElement::GetBuildingBuildListPtr() const
{
    return g_theBuildingBuildListDB->Get(m_BuildingBuildListValue);
}

