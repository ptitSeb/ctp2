
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "AdvanceRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "IconRecord.h"
#include "AdvanceBranchRecord.h"
#include "AgeRecord.h"
#include "FeatRecord.h"

CTPDatabase<AdvanceRecord> *g_theAdvanceDB = NULL;

AdvanceRecord::Init()
{
    m_flags0 = 0;
    m_Cost = 0;
    memset(m_Prerequisites, 0, sizeof(m_Prerequisites));
    m_numPrerequisites = 0;
    m_Dependencies = NULL;
    m_numDependencies = 0;
    m_LeadsTo = NULL;
    m_numLeadsTo = 0;
    m_Icon = 0x7fffffff;
    m_Branch = 0x7fffffff;
    m_Age = 0x7fffffff;
    m_PowerPoints = 0;
    m_PollutionSizeModifierValue = 0.0;
    m_PollutionProductionModifierValue = 0.0;
    m_TriggerFeatValue = 0;
    m_KeyAdvanceAdviceValue = 0;
}

AdvanceRecord::~AdvanceRecord()
{
	int index = 0;
	// free array Dependencies 
 	if (m_numDependencies > 0) 
		delete [m_numDependencies] m_Dependencies; 
	m_Dependencies = NULL; 
	m_numDependencies = 0; 

	// free array LeadsTo 
 	if (m_numLeadsTo > 0) 
		delete [m_numLeadsTo] m_LeadsTo; 
	m_LeadsTo = NULL; 
	m_numLeadsTo = 0; 

}

void AdvanceRecord::operator=(const AdvanceRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_Cost = rval.m_Cost; 

	// copy fixed sized array Prerequisites[] 
 		memcpy(m_Prerequisites, rval.m_Prerequisites, sizeof(sint32)*rval.m_numPrerequisites); 

	// free array Dependencies 
 	if (m_numDependencies > 0) 
	{
		delete [m_numDependencies] m_Dependencies; 
		m_Dependencies = NULL; 
		m_numDependencies = 0; 
	}
	if (rval.m_numDependencies > 0) 
	{
		m_Dependencies = new sint32 [rval.m_numDependencies]; 
		memcpy(m_Dependencies, rval.m_Dependencies, sizeof(sint32)*rval.m_numDependencies); 

	} 
	m_numDependencies = rval.m_numDependencies;

	// free array LeadsTo 
 	if (m_numLeadsTo > 0) 
	{
		delete [m_numLeadsTo] m_LeadsTo; 
		m_LeadsTo = NULL; 
		m_numLeadsTo = 0; 
	}
	if (rval.m_numLeadsTo > 0) 
	{
		m_LeadsTo = new sint32 [rval.m_numLeadsTo]; 
		memcpy(m_LeadsTo, rval.m_LeadsTo, sizeof(sint32)*rval.m_numLeadsTo); 

	} 
	m_numLeadsTo = rval.m_numLeadsTo;

	m_Icon = rval.m_Icon; 

	m_Branch = rval.m_Branch; 

	m_Age = rval.m_Age; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_PowerPoints = rval.m_PowerPoints; 

	m_flags0 = rval.m_flags0; 
		m_PollutionSizeModifierValue = rval.m_PollutionSizeModifierValue; 

	m_flags0 = rval.m_flags0; 
		m_PollutionProductionModifierValue = rval.m_PollutionProductionModifierValue; 

	m_flags0 = rval.m_flags0; 
		m_TriggerFeatValue = rval.m_TriggerFeatValue; 

	m_flags0 = rval.m_flags0; 
		m_KeyAdvanceAdviceValue = rval.m_KeyAdvanceAdviceValue; 

}

char *g_Advance_Tokens[] =
{
    "Cost",
    "Prerequisites",
    "Dependencies",
    "LeadsTo",
    "Icon",
    "Branch",
    "Age",
    "DeepOcean",
    "Capitalization",
    "Infrastructure",
    "Transform",
    "RequiresProbeRecovery",
    "Genetic",
    "PlantNuke",
    "NoIndex",
    "Roads",
    "Railroads",
    "AlienLife",
    "MagLev",
    "Tunnels",
    "GLHidden",
    "PowerPoints",
    "PollutionSizeModifier",
    "PollutionSizeModifierValue",
    "PollutionProductionModifier",
    "PollutionProductionModifierValue",
    "TriggerFeat",
    "TriggerFeatValue",
    "KeyAdvanceAdvice",
    "KeyAdvanceAdviceValue",
};

AdvanceRecordAccessorInfo g_AdvanceRecord_Accessors[] = 
{
    { AdvanceRecord::GetCost, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Prerequisites (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* Dependencies (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* LeadsTo (array) */
    {AdvanceRecord::GetIconIndex, NULL, NULL, NULL, NULL },
    {AdvanceRecord::GetBranchIndex, NULL, NULL, NULL, NULL },
    {AdvanceRecord::GetAgeIndex, NULL, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetDeepOcean, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetCapitalization, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetInfrastructure, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetTransform, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetRequiresProbeRecovery, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetGenetic, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetPlantNuke, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetNoIndex, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetRoads, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetRailroads, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetAlienLife, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetMagLev, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetTunnels, NULL, NULL, NULL },
    { NULL, AdvanceRecord::GetGLHidden, NULL, NULL, NULL },
    { AdvanceRecord::GetPowerPoints, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, AdvanceRecord::GetPollutionSizeModifier},
    { NULL, NULL, NULL, NULL, NULL}, /* PollutionSizeModifier */
    { NULL, NULL, NULL, NULL, AdvanceRecord::GetPollutionProductionModifier},
    { NULL, NULL, NULL, NULL, NULL}, /* PollutionProductionModifier */
    { NULL, NULL, NULL, NULL, NULL}, /* TriggerFeat */
    { NULL, NULL, NULL, NULL, NULL}, /* TriggerFeat */
    { NULL, NULL, NULL, NULL, NULL}, /* KeyAdvanceAdvice */
    { NULL, NULL, NULL, NULL, NULL}, /* KeyAdvanceAdvice */
};

#define k_Token_Advance_Cost                     ((k_Token_Custom_Base) + 0)
#define k_Token_Advance_Prerequisites            ((k_Token_Custom_Base) + 1)
#define k_Token_Advance_Dependencies             ((k_Token_Custom_Base) + 2)
#define k_Token_Advance_LeadsTo                  ((k_Token_Custom_Base) + 3)
#define k_Token_Advance_Icon                     ((k_Token_Custom_Base) + 4)
#define k_Token_Advance_Branch                   ((k_Token_Custom_Base) + 5)
#define k_Token_Advance_Age                      ((k_Token_Custom_Base) + 6)
#define k_Token_Advance_DeepOcean                ((k_Token_Custom_Base) + 7)
#define k_Token_Advance_Capitalization           ((k_Token_Custom_Base) + 8)
#define k_Token_Advance_Infrastructure           ((k_Token_Custom_Base) + 9)
#define k_Token_Advance_Transform                ((k_Token_Custom_Base) + 10)
#define k_Token_Advance_RequiresProbeRecovery    ((k_Token_Custom_Base) + 11)
#define k_Token_Advance_Genetic                  ((k_Token_Custom_Base) + 12)
#define k_Token_Advance_PlantNuke                ((k_Token_Custom_Base) + 13)
#define k_Token_Advance_NoIndex                  ((k_Token_Custom_Base) + 14)
#define k_Token_Advance_Roads                    ((k_Token_Custom_Base) + 15)
#define k_Token_Advance_Railroads                ((k_Token_Custom_Base) + 16)
#define k_Token_Advance_AlienLife                ((k_Token_Custom_Base) + 17)
#define k_Token_Advance_MagLev                   ((k_Token_Custom_Base) + 18)
#define k_Token_Advance_Tunnels                  ((k_Token_Custom_Base) + 19)
#define k_Token_Advance_GLHidden                 ((k_Token_Custom_Base) + 20)
#define k_Token_Advance_PowerPoints              ((k_Token_Custom_Base) + 21)
#define k_Token_Advance_PollutionSizeModifier    ((k_Token_Custom_Base) + 22)
#define k_Token_Advance_PollutionSizeModifier_Value ((k_Token_Custom_Base) + 23)
#define k_Token_Advance_PollutionProductionModifier ((k_Token_Custom_Base) + 24)
#define k_Token_Advance_PollutionProductionModifier_Value ((k_Token_Custom_Base) + 25)
#define k_Token_Advance_TriggerFeat              ((k_Token_Custom_Base) + 26)
#define k_Token_Advance_TriggerFeat_Value        ((k_Token_Custom_Base) + 27)
#define k_Token_Advance_KeyAdvanceAdvice         ((k_Token_Custom_Base) + 28)
#define k_Token_Advance_KeyAdvanceAdvice_Value   ((k_Token_Custom_Base) + 29)
#define k_Token_Advance_Max                      ((k_Token_Custom_Base) + 30)


static BitArray s_ParsedTokens(30);
void AdvanceRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Advance_Cost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Cost missing"));
    }
}
    
sint32 AdvanceRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Advance_Tokens, k_Token_Advance_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Advance_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Advance_Cost:
                if(!lex->GetIntAssignment(m_Cost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_Prerequisites:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_Prerequisites, &m_numPrerequisites, k_MAX_Prerequisites, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Dependencies:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_Dependencies, &m_numDependencies, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_LeadsTo:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 **)&m_LeadsTo, &m_numLeadsTo, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Icon:
                if(!g_theIconDB->GetRecordFromLexer(lex, m_Icon, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Branch:
                if(!g_theAdvanceBranchDB->GetRecordFromLexer(lex, m_Branch, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_Age:
                if(!g_theAgeDB->GetRecordFromLexer(lex, m_Age, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Advance_DeepOcean:
                m_flags0 |= k_Advance_DeepOcean_Bit;
                break;
            case k_Token_Advance_Capitalization:
                m_flags0 |= k_Advance_Capitalization_Bit;
                break;
            case k_Token_Advance_Infrastructure:
                m_flags0 |= k_Advance_Infrastructure_Bit;
                break;
            case k_Token_Advance_Transform:
                m_flags0 |= k_Advance_Transform_Bit;
                break;
            case k_Token_Advance_RequiresProbeRecovery:
                m_flags0 |= k_Advance_RequiresProbeRecovery_Bit;
                break;
            case k_Token_Advance_Genetic:
                m_flags0 |= k_Advance_Genetic_Bit;
                break;
            case k_Token_Advance_PlantNuke:
                m_flags0 |= k_Advance_PlantNuke_Bit;
                break;
            case k_Token_Advance_NoIndex:
                m_flags0 |= k_Advance_NoIndex_Bit;
                break;
            case k_Token_Advance_Roads:
                m_flags0 |= k_Advance_Roads_Bit;
                break;
            case k_Token_Advance_Railroads:
                m_flags0 |= k_Advance_Railroads_Bit;
                break;
            case k_Token_Advance_AlienLife:
                m_flags0 |= k_Advance_AlienLife_Bit;
                break;
            case k_Token_Advance_MagLev:
                m_flags0 |= k_Advance_MagLev_Bit;
                break;
            case k_Token_Advance_Tunnels:
                m_flags0 |= k_Advance_Tunnels_Bit;
                break;
            case k_Token_Advance_GLHidden:
                m_flags0 |= k_Advance_GLHidden_Bit;
                break;
            case k_Token_Advance_PowerPoints:
                if(!lex->GetIntAssignment(m_PowerPoints)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_PollutionSizeModifier:
                m_flags0 |= k_Advance_PollutionSizeModifier_Bit;
                if(!lex->GetFloatAssignment(m_PollutionSizeModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_PollutionProductionModifier:
                m_flags0 |= k_Advance_PollutionProductionModifier_Bit;
                if(!lex->GetFloatAssignment(m_PollutionProductionModifierValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_TriggerFeat:
                m_flags0 |= k_Advance_TriggerFeat_Bit;
                if(!g_theFeatDB->GetRecordFromLexer(lex, m_TriggerFeatValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_Advance_KeyAdvanceAdvice:
                m_flags0 |= k_Advance_KeyAdvanceAdvice_Bit;
                if(!lex->GetStringIdAssignment(m_KeyAdvanceAdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void AdvanceRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numPrerequisites; i++) {
            if(m_Prerequisites[i] & 0x80000000) {
                sint32 id = m_Prerequisites[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_Prerequisites[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Prerequisites[i] == 0x7fffffff){
                m_Prerequisites[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numDependencies; i++) {
            if(m_Dependencies[i] & 0x80000000) {
                sint32 id = m_Dependencies[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_Dependencies[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Dependencies[i] == 0x7fffffff){
                m_Dependencies[i] = -1;
            }
        }
    }
    {
        sint32 i;
        for(i = 0; i < m_numLeadsTo; i++) {
            if(m_LeadsTo[i] & 0x80000000) {
                sint32 id = m_LeadsTo[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_LeadsTo[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_LeadsTo[i] == 0x7fffffff){
                m_LeadsTo[i] = -1;
            }
        }
    }
    if(m_Icon & 0x80000000) {
        sint32 id = m_Icon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_Icon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Icon == 0x7fffffff) {
        m_Icon = -1;
    }
    if(m_Branch & 0x80000000) {
        sint32 id = m_Branch & 0x7fffffff;
        if(!g_theAdvanceBranchDB->GetNamedItem(id, m_Branch)) {
            c3errors_ErrorDialog("DB", "%s not found in AdvanceBranch database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Branch == 0x7fffffff) {
        m_Branch = -1;
    }
    if(m_Age & 0x80000000) {
        sint32 id = m_Age & 0x7fffffff;
        if(!g_theAgeDB->GetNamedItem(id, m_Age)) {
            c3errors_ErrorDialog("DB", "%s not found in Age database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Age == 0x7fffffff) {
        m_Age = -1;
    }
    if(m_TriggerFeatValue & 0x80000000) {
        sint32 id = m_TriggerFeatValue & 0x7fffffff;
        if(!g_theFeatDB->GetNamedItem(id, m_TriggerFeatValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Feat database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TriggerFeatValue == 0x7fffffff) {
        m_TriggerFeatValue = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void AdvanceRecord::Merge(const AdvanceRecord & rval){
	int index = 0, obj_index = 0;
	// copy values of rval.m_Prerequisites to m_Prerequisites
	for (index = 0; index < m_numPrerequisites; index++) 
	{ 
 		if (index < rval.m_numPrerequisites)
 			m_Prerequisites[index] = rval.m_Prerequisites[index];
	} 
 	// resize m_Dependencies if necessary
	if (rval.m_numDependencies > m_numDependencies)
 	{ 
		delete m_Dependencies;
 		m_Dependencies = NULL;
 		if (rval.m_numDependencies > 0)
 			m_Dependencies = new sint32 [rval.m_numDependencies]; 
		m_numDependencies = rval.m_numDependencies;
 	} 

	// copy values of rval.m_Dependencies to m_Dependencies
	for (index = 0; index < m_numDependencies; index++) 
	{ 
 		if (index < rval.m_numDependencies)
 			m_Dependencies[index] = rval.m_Dependencies[index];
	} 
 	// resize m_LeadsTo if necessary
	if (rval.m_numLeadsTo > m_numLeadsTo)
 	{ 
		delete m_LeadsTo;
 		m_LeadsTo = NULL;
 		if (rval.m_numLeadsTo > 0)
 			m_LeadsTo = new sint32 [rval.m_numLeadsTo]; 
		m_numLeadsTo = rval.m_numLeadsTo;
 	} 

	// copy values of rval.m_LeadsTo to m_LeadsTo
	for (index = 0; index < m_numLeadsTo; index++) 
	{ 
 		if (index < rval.m_numLeadsTo)
 			m_LeadsTo[index] = rval.m_LeadsTo[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Advance_PollutionSizeModifier_Bit) != 0) 
		m_PollutionSizeModifierValue = rval.m_PollutionSizeModifierValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Advance_PollutionProductionModifier_Bit) != 0) 
		m_PollutionProductionModifierValue = rval.m_PollutionProductionModifierValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Advance_TriggerFeat_Bit) != 0) 
		m_TriggerFeatValue = rval.m_TriggerFeatValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Advance_KeyAdvanceAdvice_Bit) != 0) 
		m_KeyAdvanceAdviceValue = rval.m_KeyAdvanceAdviceValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
sint32 AdvanceRecord::GetPrerequisitesIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisites);
    if((index < 0) || (index >= m_numPrerequisites)) {
        return 0;
    }
    return m_Prerequisites[index];
}

const AdvanceRecord *AdvanceRecord::GetPrerequisites(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numPrerequisites);
    if((index < 0) || (index >= m_numPrerequisites)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_Prerequisites[index]);
}

sint32 AdvanceRecord::GetDependenciesIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numDependencies);
    if((index < 0) || (index >= m_numDependencies)) {
        return 0;
    }
    return m_Dependencies[index];
}

const AdvanceRecord *AdvanceRecord::GetDependencies(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numDependencies);
    if((index < 0) || (index >= m_numDependencies)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_Dependencies[index]);
}

sint32 AdvanceRecord::GetLeadsToIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numLeadsTo);
    if((index < 0) || (index >= m_numLeadsTo)) {
        return 0;
    }
    return m_LeadsTo[index];
}

const AdvanceRecord *AdvanceRecord::GetLeadsTo(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numLeadsTo);
    if((index < 0) || (index >= m_numLeadsTo)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_LeadsTo[index]);
}

const IconRecord *AdvanceRecord::GetIcon() const
{
    return g_theIconDB->Get(m_Icon);
}

const AdvanceBranchRecord *AdvanceRecord::GetBranch() const
{
    return g_theAdvanceBranchDB->Get(m_Branch);
}

const AgeRecord *AdvanceRecord::GetAge() const
{
    return g_theAgeDB->Get(m_Age);
}

const FeatRecord *AdvanceRecord::GetTriggerFeatPtr() const
{
    return g_theFeatDB->Get(m_TriggerFeatValue);
}

