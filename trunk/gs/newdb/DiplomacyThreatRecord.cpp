
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "DiplomacyThreatRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"


CTPDatabase<DiplomacyThreatRecord> *g_theDiplomacyThreatDB = NULL;

DiplomacyThreatRecord::Init()
{
    m_Title = 0;
    m_Type = NULL;
    m_Arg1 = 0;
    m_Details = 0;
}

DiplomacyThreatRecord::~DiplomacyThreatRecord()
{
	int index = 0;
	// free string attribute Type
	if (m_Type) 
		delete m_Type; 
	m_Type = NULL; 

}

void DiplomacyThreatRecord::operator=(const DiplomacyThreatRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_Title = rval.m_Title; 

	if (m_Type) 
	{ 
	delete m_Type; 

	}

	if (rval.m_Type) 
	{ 
		m_Type = new char [strlen(rval.m_Type)+1]; 
		strcpy(m_Type, rval.m_Type);
	}

	m_Arg1 = rval.m_Arg1; 

	m_Details = rval.m_Details; 

}

char *g_DiplomacyThreat_Tokens[] =
{
    "Title",
    "Type",
    "Arg1",
    "Details",
};

DiplomacyThreatRecordAccessorInfo g_DiplomacyThreatRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Title */
    { NULL, NULL, NULL, NULL, NULL}, /* Type */
    { NULL, NULL, NULL, NULL, NULL}, /* Arg1 */
    { NULL, NULL, NULL, NULL, NULL}, /* Details */
};

#define k_Token_DiplomacyThreat_Title            ((k_Token_Custom_Base) + 0)
#define k_Token_DiplomacyThreat_Type             ((k_Token_Custom_Base) + 1)
#define k_Token_DiplomacyThreat_Arg1             ((k_Token_Custom_Base) + 2)
#define k_Token_DiplomacyThreat_Details          ((k_Token_Custom_Base) + 3)
#define k_Token_DiplomacyThreat_Max              ((k_Token_Custom_Base) + 4)


static BitArray s_ParsedTokens(4);
void DiplomacyThreatRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_DiplomacyThreat_Title - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Title missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_DiplomacyThreat_Type - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Type missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_DiplomacyThreat_Details - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Details missing"));
    }
}
    
sint32 DiplomacyThreatRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_DiplomacyThreat_Tokens, k_Token_DiplomacyThreat_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_DiplomacyThreat_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_DiplomacyThreat_Title:
                if(!lex->GetStringIdAssignment(m_Title)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_DiplomacyThreat_Type:
                if(!lex->GetFileAssignment(m_Type)) {
                    DBERROR(("Expected string"));
                    done = true; break;
                }
                break;
            case k_Token_DiplomacyThreat_Arg1:
                if(!ParseArg1Bit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_DiplomacyThreat_Details:
                if(!lex->GetStringIdAssignment(m_Details)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void DiplomacyThreatRecord::ResolveDBReferences()
{
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
static char *s_DiplomacyThreat_Arg1_BitNames[] = {
    "ThirdParty",
    "HisCity",
    "SpecialAttack",
    "AgreementId",
};
#define k_DiplomacyThreat_Arg1_Num_BitNames 4

sint32 DiplomacyThreatRecord::ParseArg1Bit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_DiplomacyThreat_Arg1_BitNames, k_DiplomacyThreat_Arg1_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Arg1", lex->GetTokenText()));
        return 0;
    }
    m_Arg1 |= (1 << bitindex);
    return 1;
}

void DiplomacyThreatRecord::Merge(const DiplomacyThreatRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if(rval.m_Arg1 != 0x0) 
		m_Arg1 = rval.m_Arg1; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
