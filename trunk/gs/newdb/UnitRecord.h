
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#ifndef __Unit_RECORD_H__
#define __Unit_RECORD_H__

/*
 * Unit description
 */
#include "CTPRecord.h"
//
// m_flags0
#define k_Unit_LossMoveToDmgNone_Bit             0x00000001
#define k_Unit_LossMoveToDmgTwo_Bit              0x00000002
#define k_Unit_NoFuelThenCrash_Bit               0x00000004
#define k_Unit_TransformPartial_Bit              0x00000008
#define k_Unit_IgnoreZOC_Bit                     0x00000010
#define k_Unit_NoZoc_Bit                         0x00000020
#define k_Unit_CanCounterBombard_Bit             0x00000040
#define k_Unit_CanLiftOff_Bit                    0x00000080
#define k_Unit_SpaceLaunch_Bit                   0x00000100
#define k_Unit_SpaceLand_Bit                     0x00000200
#define k_Unit_CantCaptureCity_Bit               0x00000400
#define k_Unit_HasPopAndCanBuild_Bit             0x00000800
#define k_Unit_IsTrader_Bit                      0x00001000
#define k_Unit_ExertsMartialLaw_Bit              0x00002000
#define k_Unit_CanEntrench_Bit                   0x00004000
#define k_Unit_CanPatrol_Bit                     0x00008000
#define k_Unit_NeedsNoSupport_Bit                0x00010000
#define k_Unit_CanExpelPop_Bit                   0x00020000
#define k_Unit_IsFlanker_Bit                     0x00040000
#define k_Unit_CanBeachAssault_Bit               0x00080000
#define k_Unit_DefendAgainstSpies_Bit            0x00100000
#define k_Unit_CanBeExpelled_Bit                 0x00200000
#define k_Unit_CanBeSued_Bit                     0x00400000
#define k_Unit_AttackFromSpaceship_Bit           0x00800000
#define k_Unit_CantBeAttacked_Bit                0x01000000
#define k_Unit_CargoPod_Bit                      0x02000000
#define k_Unit_IsMounted_Bit                     0x04000000
#define k_Unit_IgnoreCityWalls_Bit               0x08000000
#define k_Unit_IsSubmarine_Bit                   0x10000000
#define k_Unit_NoLandAttack_Bit                  0x20000000
#define k_Unit_NoSeaAttack_Bit                   0x40000000
#define k_Unit_NoAirAttack_Bit                   0x80000000
//
// m_flags1
#define k_Unit_NoSpaceAttack_Bit                 0x00000001
#define k_Unit_NoUnderwaterAttack_Bit            0x00000002
#define k_Unit_NoMountainAttack_Bit              0x00000004
#define k_Unit_NoShallowWaterAttack_Bit          0x00000008
#define k_Unit_Paratrooper_Bit                   0x00000010
#define k_Unit_AssistedDrops_Bit                 0x00000020
#define k_Unit_BonusAgainstMounted_Bit           0x00000040
#define k_Unit_SingleUse_Bit                     0x00000080
#define k_Unit_BonusAirDefense_Bit               0x00000100
#define k_Unit_WoodenShip_Bit                    0x00000200
#define k_Unit_AttackWoodenShipBonus_Bit         0x00000400
#define k_Unit_HasAttackCityBonus_Bit            0x00000800
#define k_Unit_HasAttackBonusSubmarine_Bit       0x00001000
#define k_Unit_ReplaceWithCargoModule_Bit        0x00002000
#define k_Unit_VisibileAttacking_Bit             0x00004000
#define k_Unit_NuclearAttack_Bit                 0x00008000
#define k_Unit_CanSue_Bit                        0x00010000
#define k_Unit_IsStealthy_Bit                    0x00020000
#define k_Unit_SeeSurfaceFromSpace_Bit           0x00040000
#define k_Unit_EstablishEmbassy_Bit              0x00080000
#define k_Unit_ThrowParty_Bit                    0x00100000
#define k_Unit_HearGossip_Bit                    0x00200000
#define k_Unit_StealTechnology_Bit               0x00400000
#define k_Unit_InciteRevolution_Bit              0x00800000
#define k_Unit_AssasinateRuler_Bit               0x01000000
#define k_Unit_InvestigateReadiness_Bit          0x02000000
#define k_Unit_NullifyCityWalls_Bit              0x04000000
#define k_Unit_CreateFranchise_Bit               0x08000000
#define k_Unit_CauseUnhappiness_Bit              0x10000000
#define k_Unit_ConductHits_Bit                   0x20000000
#define k_Unit_BioTerror_Bit                     0x40000000
#define k_Unit_NanoTerror_Bit                    0x80000000
//
// m_flags2
#define k_Unit_Plague_Bit                        0x00000001
#define k_Unit_SlaveRaids_Bit                    0x00000002
#define k_Unit_SettlerSlaveRaids_Bit             0x00000004
#define k_Unit_SlaveUprising_Bit                 0x00000008
#define k_Unit_UndergroundRailway_Bit            0x00000010
#define k_Unit_VictoryEnslavement_Bit            0x00000020
#define k_Unit_DefuseLandMines_Bit               0x00000040
#define k_Unit_DefuseSeaMines_Bit                0x00000080
#define k_Unit_DefuseXrayMines_Bit               0x00000100
#define k_Unit_IndulgenceSales_Bit               0x00000200
#define k_Unit_ConvertCities_Bit                 0x00000400
#define k_Unit_BuildXrayMines_Bit                0x00000800
#define k_Unit_BuildWonder_Bit                   0x00001000
#define k_Unit_NoSlaves_Bit                      0x00002000
#define k_Unit_CreateRift_Bit                    0x00004000
#define k_Unit_CanCloak_Bit                      0x00008000
#define k_Unit_ParatrooperTransport_Bit          0x00010000
#define k_Unit_CantBuild_Bit                     0x00020000
#define k_Unit_PlantNuke_Bit                     0x00040000
#define k_Unit_IsTelevangelist_Bit               0x00080000
#define k_Unit_CanSoothsay_Bit                   0x00100000
#define k_Unit_CanBeRustled_Bit                  0x00200000
#define k_Unit_CreateParks_Bit                   0x00400000
#define k_Unit_CanInjoin_Bit                     0x00800000
#define k_Unit_WormholeProbe_Bit                 0x01000000
#define k_Unit_HasBonusFood_Bit                  0x02000000
#define k_Unit_LandCityCanBuild_Bit              0x04000000
#define k_Unit_SeaCityCanBuild_Bit               0x08000000
#define k_Unit_SpaceCityCanBuild_Bit             0x10000000
#define k_Unit_IsSpecialForces_Bit               0x20000000
#define k_Unit_NotAffectedByLandMines_Bit        0x40000000
#define k_Unit_InternalReserved_Bit              0x80000000
//
// m_flags3
#define k_Unit_DeathEffectsHappy_Bit             0x00000001
#define k_Unit_EnableCarrierDefenses_Bit         0x00000002
#define k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit 0x00000004
#define k_Unit_BuildingRemovesAPop_Bit           0x00000008
#define k_Unit_Explodes_Bit                      0x00000010
#define k_Unit_Advertise_Bit                     0x00000020
#define k_Unit_CanRustle_Bit                     0x00000040
#define k_Unit_OnlyBuildOne_Bit                  0x00000080
#define k_Unit_CanExpel_Bit                      0x00000100
#define k_Unit_CanReform_Bit                     0x00000200
#define k_Unit_CanPillage_Bit                    0x00000400
#define k_Unit_CanPirate_Bit                     0x00000800
#define k_Unit_CargoData_Bit                     0x00001000
#define k_Unit_BRange_Bit                        0x00002000
#define k_Unit_BRadius_Bit                       0x00004000
#define k_Unit_ElectronicCombatFactor_Bit        0x00008000
#define k_Unit_TransType_Bit                     0x00010000
#define k_Unit_ProbOfBombHit_Bit                 0x00020000
#define k_Unit_BombRounds_Bit                    0x00040000
#define k_Unit_LaunchPollution_Bit               0x00080000
#define k_Unit_DeathPollution_Bit                0x00100000
#define k_Unit_MountedBonus_Bit                  0x00200000
#define k_Unit_AirBonus_Bit                      0x00400000
#define k_Unit_WoodenShipBonus_Bit               0x00800000
#define k_Unit_AttackCityBonus_Bit               0x01000000
#define k_Unit_AttackBonusSubmarine_Bit          0x02000000
#define k_Unit_CargoModule_Bit                   0x04000000
#define k_Unit_SpyVsSpy_Bit                      0x08000000
#define k_Unit_InvestigateCity_Bit               0x10000000
#define k_Unit_BonusFood_Bit                     0x20000000
#define k_Unit_BombardRange_Bit                  0x40000000
#define k_Unit_Revolution_Bit                    0x80000000
//
// m_flags4
#define k_Unit_CityGrowthCoefficient_Bit         0x00000001
#define k_Unit_NoIndex_Bit                       0x00000002
#define k_Unit_CheatIndex_Bit                    0x00000004
#define k_Unit_Advice_Bit                        0x00000008
#define k_Unit_GLHidden_Bit                      0x00000010
#define k_Unit_CantMove_Bit                      0x00000020
#define k_Unit_Civilian_Bit                      0x00000040
//
// m_MovementType bit group
#define k_Unit_MovementType_Land_Bit             0x00000001
#define k_Unit_MovementType_Sea_Bit              0x00000002
#define k_Unit_MovementType_Air_Bit              0x00000004
#define k_Unit_MovementType_Mountain_Bit         0x00000008
#define k_Unit_MovementType_Trade_Bit            0x00000010
#define k_Unit_MovementType_ShallowWater_Bit     0x00000020
#define k_Unit_MovementType_Space_Bit            0x00000040
//
// m_CanCarry bit group
#define k_Unit_CanCarry_SmallLand_Bit            0x00000001
#define k_Unit_CanCarry_MedLand_Bit              0x00000002
#define k_Unit_CanCarry_LargeLand_Bit            0x00000004
#define k_Unit_CanCarry_SmallAir_Bit             0x00000008
#define k_Unit_CanCarry_MedAir_Bit               0x00000010
#define k_Unit_CanCarry_LargeAir_Bit             0x00000020
#define k_Unit_CanCarry_SmallWater_Bit           0x00000040
#define k_Unit_CanCarry_MedWater_Bit             0x00000080
#define k_Unit_CanCarry_LargeWater_Bit           0x00000100
#define k_Unit_CanCarry_SmallSpace_Bit           0x00000200
#define k_Unit_CanCarry_MedSpace_Bit             0x00000400
#define k_Unit_CanCarry_LargeSpace_Bit           0x00000800
//
// m_Size bit group
#define k_Unit_Size_Small_Bit                    0x00000001
#define k_Unit_Size_Medium_Bit                   0x00000002
#define k_Unit_Size_Large_Bit                    0x00000004
//
// m_CanBombard bit group
#define k_Unit_CanBombard_Land_Bit               0x00000001
#define k_Unit_CanBombard_Air_Bit                0x00000002
#define k_Unit_CanBombard_Water_Bit              0x00000004
#define k_Unit_CanBombard_Space_Bit              0x00000008
#define k_Unit_CanBombard_Mountain_Bit           0x00000010
//
// m_Settle bit group
#define k_Unit_Settle_Land_Bit                   0x00000001
#define k_Unit_Settle_Water_Bit                  0x00000002
#define k_Unit_Settle_Mountain_Bit               0x00000004
#define k_Unit_Settle_Space_Bit                  0x00000008
//
// m_Defend bit group
#define k_Unit_Defend_Land_Bit                   0x00000001
#define k_Unit_Defend_Air_Bit                    0x00000002
#define k_Unit_Defend_Water_Bit                  0x00000004
#define k_Unit_Defend_Space_Bit                  0x00000008
#define k_Unit_Defend_Mountain_Bit               0x00000010
//
// m_VisionClass bit group
#define k_Unit_VisionClass_Standard_Bit          0x00000001
#define k_Unit_VisionClass_Underwater_Bit        0x00000002
#define k_Unit_VisionClass_Stealth_Bit           0x00000004
#define k_Unit_VisionClass_UnusedBit3_Bit        0x00000008
#define k_Unit_VisionClass_UnusedBit4_Bit        0x00000010
#define k_Unit_VisionClass_UnusedBit5_Bit        0x00000020
#define k_Unit_VisionClass_UnusedBit6_Bit        0x00000040
#define k_Unit_VisionClass_UnusedBit7_Bit        0x00000080
#define k_Unit_VisionClass_UnusedBit8_Bit        0x00000100
#define k_Unit_VisionClass_UnusedBit9_Bit        0x00000200
#define k_Unit_VisionClass_UnusedBit10_Bit       0x00000400
#define k_Unit_VisionClass_UnusedBit11_Bit       0x00000800
#define k_Unit_VisionClass_UnusedBit12_Bit       0x00001000
#define k_Unit_VisionClass_UnusedBit13_Bit       0x00002000
#define k_Unit_VisionClass_UnusedBit14_Bit       0x00004000
#define k_Unit_VisionClass_UnusedBit15_Bit       0x00008000
//
// m_CanSee bit group
#define k_Unit_CanSee_Standard_Bit               0x00000001
#define k_Unit_CanSee_Underwater_Bit             0x00000002
#define k_Unit_CanSee_Stealth_Bit                0x00000004
#define k_Unit_CanSee_UnusedBit3_Bit             0x00000008
#define k_Unit_CanSee_UnusedBit4_Bit             0x00000010
#define k_Unit_CanSee_UnusedBit5_Bit             0x00000020
#define k_Unit_CanSee_UnusedBit6_Bit             0x00000040
#define k_Unit_CanSee_UnusedBit7_Bit             0x00000080
#define k_Unit_CanSee_UnusedBit8_Bit             0x00000100
#define k_Unit_CanSee_UnusedBit9_Bit             0x00000200
#define k_Unit_CanSee_UnusedBit10_Bit            0x00000400
#define k_Unit_CanSee_UnusedBit11_Bit            0x00000800
#define k_Unit_CanSee_UnusedBit12_Bit            0x00001000
#define k_Unit_CanSee_UnusedBit13_Bit            0x00002000
#define k_Unit_CanSee_UnusedBit14_Bit            0x00004000
#define k_Unit_CanSee_UnusedBit15_Bit            0x00008000
//
// m_CanAttack bit group
#define k_Unit_CanAttack_Land_Bit                0x00000001
#define k_Unit_CanAttack_Sea_Bit                 0x00000002
#define k_Unit_CanAttack_Air_Bit                 0x00000004
#define k_Unit_CanAttack_Mountain_Bit            0x00000008
#define k_Unit_CanAttack_Trade_Bit               0x00000010
#define k_Unit_CanAttack_ShallowWater_Bit        0x00000020
#define k_Unit_CanAttack_Space_Bit               0x00000040
#define k_Unit_CanAttack_Underwater_Bit          0x00000080
//
// m_UserFlags bit group
#define k_Unit_UserFlags_UF1_Bit                 0x00000001
#define k_Unit_UserFlags_UF2_Bit                 0x00000002
#define k_Unit_UserFlags_UF3_Bit                 0x00000004
#define k_Unit_UserFlags_UF4_Bit                 0x00000008
#define k_Unit_UserFlags_UF5_Bit                 0x00000010
#define k_Unit_UserFlags_UF6_Bit                 0x00000020
#define k_Unit_UserFlags_UF7_Bit                 0x00000040
#define k_Unit_UserFlags_UF8_Bit                 0x00000080
#define k_Unit_UserFlags_UF9_Bit                 0x00000100
#define k_Unit_UserFlags_UF10_Bit                0x00000200
#define k_Unit_UserFlags_UF11_Bit                0x00000400
#define k_Unit_UserFlags_UF12_Bit                0x00000800
#define k_Unit_UserFlags_UF13_Bit                0x00001000
#define k_Unit_UserFlags_UF14_Bit                0x00002000
#define k_Unit_UserFlags_UF15_Bit                0x00004000
#define k_Unit_UserFlags_UF16_Bit                0x00008000
#define k_Unit_UserFlags_UF17_Bit                0x00010000
#define k_Unit_UserFlags_UF18_Bit                0x00020000
#define k_Unit_UserFlags_UF19_Bit                0x00040000
#define k_Unit_UserFlags_UF20_Bit                0x00080000
#define k_Unit_UserFlags_UF21_Bit                0x00100000
#define k_Unit_UserFlags_UF22_Bit                0x00200000
#define k_Unit_UserFlags_UF23_Bit                0x00400000
#define k_Unit_UserFlags_UF24_Bit                0x00800000
#define k_Unit_UserFlags_UF25_Bit                0x01000000
#define k_Unit_UserFlags_UF26_Bit                0x02000000
#define k_Unit_UserFlags_UF27_Bit                0x04000000
#define k_Unit_UserFlags_UF28_Bit                0x08000000
#define k_Unit_UserFlags_UF29_Bit                0x10000000
#define k_Unit_UserFlags_UF30_Bit                0x20000000
#define k_Unit_UserFlags_UF31_Bit                0x40000000
//
// Range definitions
#define k_MAX_ObsoleteAdvance                5
#define k_MAX_SpecialAttacks                 8

/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
class AdvanceRecord;
class AdvanceRecord;
class UnitRecord;
class BuildingRecord;
class GovernmentRecord;
class SpriteRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SpecialAttackInfoRecord;
class IconRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SpecialEffectRecord;
class SoundRecord;
class SoundRecord;
class SoundRecord;
class SpecialEffectRecord;

class UnitRecord : public CTPRecord
{
public:
    typedef sint32 (UnitRecord::*IntAccessor)() const;
    typedef bool (UnitRecord::*BoolAccessor)() const;
    typedef double (UnitRecord::*FloatAccessor)() const ;
    typedef bool (UnitRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool (UnitRecord::*BitFloatAccessor)(double &val) const;
    class SuccessDeath {
    private:
        double            m_Chance;
        double            m_DeathChance;
    public:
        SuccessDeath();
        ~SuccessDeath();
        void operator=(const SuccessDeath & rval);
        bool operator==(const SuccessDeath & rval) { 
          return false; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeath **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetDeathChance() const { return m_DeathChance; }
    }; /* class SuccessDeath */

    class SuccessDeathEffect {
    private:
        double            m_Chance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        SuccessDeathEffect();
        ~SuccessDeathEffect();
        void operator=(const SuccessDeathEffect & rval);
        bool operator==(const SuccessDeathEffect & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class SuccessDeathEffect */

    class StealTechnologyData {
    private:
        double            m_RandomChance;
        double            m_SpecificChance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        StealTechnologyData();
        ~StealTechnologyData();
        void operator=(const StealTechnologyData & rval);
        bool operator==(const StealTechnologyData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, StealTechnologyData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetRandomChance() const { return m_RandomChance; }
        double           GetSpecificChance() const { return m_SpecificChance; }
        double           GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class StealTechnologyData */

    class InciteRevolutionData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        InciteRevolutionData();
        ~InciteRevolutionData();
        void operator=(const InciteRevolutionData & rval);
        bool operator==(const InciteRevolutionData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetEliteChance() const { return m_EliteChance; }
        double           GetDeathChance() const { return m_DeathChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class InciteRevolutionData */

    class AssasinateRulerData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;
    public:
        AssasinateRulerData();
        ~AssasinateRulerData();
        void operator=(const AssasinateRulerData & rval);
        bool operator==(const AssasinateRulerData & rval) { 
          return false; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetEliteChance() const { return m_EliteChance; }
        double           GetDeathChance() const { return m_DeathChance; }
    }; /* class AssasinateRulerData */

    class InvestigateReadinessData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;
    public:
        InvestigateReadinessData();
        ~InvestigateReadinessData();
        void operator=(const InvestigateReadinessData & rval);
        bool operator==(const InvestigateReadinessData & rval) { 
          return false; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetEliteChance() const { return m_EliteChance; }
        double           GetDeathChance() const { return m_DeathChance; }
    }; /* class InvestigateReadinessData */

    class ChanceEffect {
    private:
        double            m_Chance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        ChanceEffect();
        ~ChanceEffect();
        void operator=(const ChanceEffect & rval);
        bool operator==(const ChanceEffect & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, ChanceEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class ChanceEffect */

    class CauseUnhappinessData {
    private:
        double            m_Chance;
        sint32            m_Timer;
        sint32            m_Amount;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        CauseUnhappinessData();
        ~CauseUnhappinessData();
        void operator=(const CauseUnhappinessData & rval);
        bool operator==(const CauseUnhappinessData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        sint32           GetTimer() const { return m_Timer; }
        sint32           GetAmount() const { return m_Amount; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class CauseUnhappinessData */

    class SlaveRaidsData {
    private:
        double            m_Chance;
        double            m_DeathChance;
        sint32            m_Timer;
        sint32            m_Amount;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        SlaveRaidsData();
        ~SlaveRaidsData();
        void operator=(const SlaveRaidsData & rval);
        bool operator==(const SlaveRaidsData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetDeathChance() const { return m_DeathChance; }
        sint32           GetTimer() const { return m_Timer; }
        sint32           GetAmount() const { return m_Amount; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class SlaveRaidsData */

    class SoundAndEffect {
    private:
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        SoundAndEffect();
        ~SoundAndEffect();
        void operator=(const SoundAndEffect & rval);
        bool operator==(const SoundAndEffect & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, SoundAndEffect **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class SoundAndEffect */

    class PlantNukeData {
    private:
        double            m_Chance;
        double            m_EscapeChance;
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        PlantNukeData();
        ~PlantNukeData();
        void operator=(const PlantNukeData & rval);
        bool operator==(const PlantNukeData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, PlantNukeData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetEscapeChance() const { return m_EscapeChance; }
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class PlantNukeData */

    class CargoData {
    private:
        sint32            m_MaxCargo;
        sint32            m_Load; // Index into Sound database
        sint32            m_Unload; // Index into Sound database
    public:
        CargoData();
        ~CargoData();
        void operator=(const CargoData & rval);
        bool operator==(const CargoData & rval) { 
          if (m_Load != rval.m_Load) 
             return false; 
          if (m_Unload != rval.m_Unload) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, CargoData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        sint32           GetMaxCargo() const { return m_MaxCargo; }
        sint32           GetLoadIndex() const { return m_Load; }
    const SoundRecord *GetLoad() const;
        sint32           GetUnloadIndex() const { return m_Unload; }
    const SoundRecord *GetUnload() const;
    }; /* class CargoData */

    class InvestigateCityData {
    private:
        double            m_Chance;
        double            m_EliteChance;
        double            m_DeathChance;
    public:
        InvestigateCityData();
        ~InvestigateCityData();
        void operator=(const InvestigateCityData & rval);
        bool operator==(const InvestigateCityData & rval) { 
          return false; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, InvestigateCityData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        double           GetChance() const { return m_Chance; }
        double           GetEliteChance() const { return m_EliteChance; }
        double           GetDeathChance() const { return m_DeathChance; }
    }; /* class InvestigateCityData */

    class RevolutionData {
    private:
        sint32            m_Sound; // Index into Sound database
        sint32            m_Effect; // Index into SpecialEffect database
    public:
        RevolutionData();
        ~RevolutionData();
        void operator=(const RevolutionData & rval);
        bool operator==(const RevolutionData & rval) { 
          if (m_Sound != rval.m_Sound) 
             return false; 
          if (m_Effect != rval.m_Effect) 
             return false; 
          return true; 
        } 

        sint32 Parse(DBLexer *lex);
        sint32 ParseSequential(DBLexer *lex);
        static sint32 ParseInArray(DBLexer *lex, RevolutionData **array, sint32 *numElements);
        static sint32 ParseInArray(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize);
        void ResolveDBReferences();
        sint32           GetSoundIndex() const { return m_Sound; }
    const SoundRecord *GetSound() const;
        sint32           GetEffectIndex() const { return m_Effect; }
    const SpecialEffectRecord *GetEffect() const;
    }; /* class RevolutionData */

private:
    uint32 m_flags0;
    uint32 m_flags1;
    uint32 m_flags2;
    uint32 m_flags3;
    uint32 m_flags4;

    uint32            m_MovementType;
    uint32            m_CanCarry;
    sint32            m_EnableAdvance; // Index into Advance database
    sint32            m_ObsoleteAdvance[k_MAX_ObsoleteAdvance]; // Index into Advance database
    sint32           m_numObsoleteAdvance;
    uint32            m_Size;
    uint32            m_CanBombard;
    uint32            m_Settle;
    sint32            m_SettleCityType; // Index into Unit database
    sint32            m_SettleSize;
    sint32           *m_SettleBuilding; // Index into Building database
    sint32           m_numSettleBuilding;
    sint32            m_SpaceLaunchValue;
    uint32            m_Defend;
    double            m_DefendAgainstSpiesValue;
    sint32            m_ReplaceWithCargoModuleValue;
    SoundAndEffect    m_NuclearAttackValue;
    StealTechnologyData   m_StealTechnologyValue;
    InciteRevolutionData   m_InciteRevolutionValue;
    AssasinateRulerData   m_AssasinateRulerValue;
    InvestigateReadinessData   m_InvestigateReadinessValue;
    ChanceEffect      m_CreateFranchiseValue;
    CauseUnhappinessData   m_CauseUnhappinessValue;
    SoundAndEffect    m_ConductHitsValue;
    ChanceEffect      m_BioTerrorValue;
    ChanceEffect      m_NanoTerrorValue;
    ChanceEffect      m_PlagueValue;
    SlaveRaidsData    m_SlaveRaidsValue;
    SoundAndEffect    m_SettlerSlaveRaidsValue;
    SoundAndEffect    m_SlaveUprisingValue;
    SuccessDeathEffect   m_UndergroundRailwayValue;
    SoundAndEffect    m_IndulgenceSalesValue;
    SuccessDeathEffect   m_ConvertCitiesValue;
    sint32           *m_GovernmentType; // Index into Government database
    sint32           m_numGovernmentType;
    PlantNukeData     m_PlantNukeValue;
    SoundAndEffect    m_CanSoothsayValue;
    SoundAndEffect    m_CreateParksValue;
    SoundAndEffect    m_CanInjoinValue;
    SoundAndEffect    m_CanReformValue;
    uint32            m_VisionClass;
    uint32            m_CanSee;
    uint32            m_CanAttack;
    CargoData         m_CargoDataValue;
    sint32            m_ShieldCost;
    sint32            m_PowerPoints;
    sint32            m_MaxHP;
    double            m_MaxHPr;
    double            m_Attack;
    double            m_Defense;
    sint32            m_Firepower;
    sint32            m_ZBRangeAttack;
    double            m_Armor;
    sint32            m_BRangeValue;
    sint32            m_BRadiusValue;
    sint32            m_VisionRange;
    sint32            m_ActiveDefenseRange;
    sint32            m_ElectronicCombatFactorValue;
    double            m_MaxMovePoints;
    sint32            m_MaxFuel;
    sint32            m_TransTypeValue;
    sint32            m_ProbOfBombHitValue;
    sint32            m_BombRoundsValue;
    sint32            m_ShieldHunger;
    sint32            m_FoodHunger;
    sint32            m_DefaultSprite; // Index into Sprite database
    sint32            m_LaunchPollutionValue;
    sint32            m_DeathPollutionValue;
    double            m_MountedBonusValue;
    double            m_AirBonusValue;
    double            m_WoodenShipBonusValue;
    double            m_AttackCityBonusValue;
    double            m_AttackBonusSubmarineValue;
    sint32            m_CargoModuleValue;
    double            m_SpyVsSpyValue;
    InvestigateCityData   m_InvestigateCityValue;
    sint32            m_BonusFoodValue;
    sint32            m_BombardRangeValue;
    RevolutionData    m_RevolutionValue;
    sint32            m_SoundSelect1; // Index into Sound database
    sint32            m_SoundSelect2; // Index into Sound database
    sint32            m_SoundMove; // Index into Sound database
    sint32            m_SoundAcknowledge; // Index into Sound database
    sint32            m_SoundCantMove; // Index into Sound database
    sint32            m_SoundAttack; // Index into Sound database
    sint32            m_SoundWork; // Index into Sound database
    sint32            m_SoundVictory; // Index into Sound database
    sint32            m_SoundDeath; // Index into Sound database
    sint32            m_SoundLoad; // Index into Sound database
    sint32            m_SoundUnload; // Index into Sound database
    sint32            m_SpecialAttacks[k_MAX_SpecialAttacks]; // Index into SpecialAttackInfo database
    sint32           m_numSpecialAttacks;
    double            m_CityGrowthCoefficientValue;
    uint32            m_UserFlags;
    sint32            m_DefaultIcon; // Index into Icon database
    sint32            m_CheatIndexValue;
    sint32            m_Description;
    sint32            m_AdviceValue;
    sint32            m_Category;

public:
    UnitRecord() { Init(); };
    ~UnitRecord();
    Init();
    // These methods are needed for records to conform to
    // 'Orthodox Cannonical Form' and work with resizing STL vectors. 
    UnitRecord(const UnitRecord &rval) { Init(); *this = rval; }
    void operator=(const UnitRecord &rval);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex);

    void ResolveDBReferences();
    void Merge(const UnitRecord & rval);
    sint32 ParseMovementTypeBit(DBLexer *lex);
    sint32 ParseCanCarryBit(DBLexer *lex);
    sint32 ParseSizeBit(DBLexer *lex);
    sint32 ParseCanBombardBit(DBLexer *lex);
    sint32 ParseSettleBit(DBLexer *lex);
    sint32 ParseDefendBit(DBLexer *lex);
    sint32 ParseVisionClassBit(DBLexer *lex);
    sint32 ParseCanSeeBit(DBLexer *lex);
    sint32 ParseCanAttackBit(DBLexer *lex);
    sint32 ParseUserFlagsBit(DBLexer *lex);
    //
    // Accessors
    //

    //
    // MovementType flag group
    uint32           GetMovementType() const { return m_MovementType; }
    bool             GetMovementTypeLand() const { return (m_MovementType & k_Unit_MovementType_Land_Bit) != 0; }
    bool             GetMovementTypeSea() const { return (m_MovementType & k_Unit_MovementType_Sea_Bit) != 0; }
    bool             GetMovementTypeAir() const { return (m_MovementType & k_Unit_MovementType_Air_Bit) != 0; }
    bool             GetMovementTypeMountain() const { return (m_MovementType & k_Unit_MovementType_Mountain_Bit) != 0; }
    bool             GetMovementTypeTrade() const { return (m_MovementType & k_Unit_MovementType_Trade_Bit) != 0; }
    bool             GetMovementTypeShallowWater() const { return (m_MovementType & k_Unit_MovementType_ShallowWater_Bit) != 0; }
    bool             GetMovementTypeSpace() const { return (m_MovementType & k_Unit_MovementType_Space_Bit) != 0; }
    // End MovementType flag group
    //

    //
    // CanCarry flag group
    uint32           GetCanCarry() const { return m_CanCarry; }
    bool             GetCanCarrySmallLand() const { return (m_CanCarry & k_Unit_CanCarry_SmallLand_Bit) != 0; }
    bool             GetCanCarryMedLand() const { return (m_CanCarry & k_Unit_CanCarry_MedLand_Bit) != 0; }
    bool             GetCanCarryLargeLand() const { return (m_CanCarry & k_Unit_CanCarry_LargeLand_Bit) != 0; }
    bool             GetCanCarrySmallAir() const { return (m_CanCarry & k_Unit_CanCarry_SmallAir_Bit) != 0; }
    bool             GetCanCarryMedAir() const { return (m_CanCarry & k_Unit_CanCarry_MedAir_Bit) != 0; }
    bool             GetCanCarryLargeAir() const { return (m_CanCarry & k_Unit_CanCarry_LargeAir_Bit) != 0; }
    bool             GetCanCarrySmallWater() const { return (m_CanCarry & k_Unit_CanCarry_SmallWater_Bit) != 0; }
    bool             GetCanCarryMedWater() const { return (m_CanCarry & k_Unit_CanCarry_MedWater_Bit) != 0; }
    bool             GetCanCarryLargeWater() const { return (m_CanCarry & k_Unit_CanCarry_LargeWater_Bit) != 0; }
    bool             GetCanCarrySmallSpace() const { return (m_CanCarry & k_Unit_CanCarry_SmallSpace_Bit) != 0; }
    bool             GetCanCarryMedSpace() const { return (m_CanCarry & k_Unit_CanCarry_MedSpace_Bit) != 0; }
    bool             GetCanCarryLargeSpace() const { return (m_CanCarry & k_Unit_CanCarry_LargeSpace_Bit) != 0; }
    // End CanCarry flag group
    //
    sint32           GetEnableAdvanceIndex() const { return m_EnableAdvance; }
    const AdvanceRecord *GetEnableAdvance() const;
    sint32           GetObsoleteAdvanceIndex(sint32 index) const;
    const AdvanceRecord *GetObsoleteAdvance(sint32 index) const;
    sint32           GetNumObsoleteAdvance() const { return m_numObsoleteAdvance;}

    //
    // Size flag group
    uint32           GetSize() const { return m_Size; }
    bool             GetSizeSmall() const { return (m_Size & k_Unit_Size_Small_Bit) != 0; }
    bool             GetSizeMedium() const { return (m_Size & k_Unit_Size_Medium_Bit) != 0; }
    bool             GetSizeLarge() const { return (m_Size & k_Unit_Size_Large_Bit) != 0; }
    // End Size flag group
    //
    bool             GetLossMoveToDmgNone() const { return (m_flags0 & k_Unit_LossMoveToDmgNone_Bit) != 0; }
    bool             GetLossMoveToDmgTwo() const { return (m_flags0 & k_Unit_LossMoveToDmgTwo_Bit) != 0; }
    bool             GetNoFuelThenCrash() const { return (m_flags0 & k_Unit_NoFuelThenCrash_Bit) != 0; }
    bool             GetTransformPartial() const { return (m_flags0 & k_Unit_TransformPartial_Bit) != 0; }
    bool             GetIgnoreZOC() const { return (m_flags0 & k_Unit_IgnoreZOC_Bit) != 0; }
    bool             GetNoZoc() const { return (m_flags0 & k_Unit_NoZoc_Bit) != 0; }

    //
    // CanBombard flag group
    uint32           GetCanBombard() const { return m_CanBombard; }
    bool             GetCanBombardLand() const { return (m_CanBombard & k_Unit_CanBombard_Land_Bit) != 0; }
    bool             GetCanBombardAir() const { return (m_CanBombard & k_Unit_CanBombard_Air_Bit) != 0; }
    bool             GetCanBombardWater() const { return (m_CanBombard & k_Unit_CanBombard_Water_Bit) != 0; }
    bool             GetCanBombardSpace() const { return (m_CanBombard & k_Unit_CanBombard_Space_Bit) != 0; }
    bool             GetCanBombardMountain() const { return (m_CanBombard & k_Unit_CanBombard_Mountain_Bit) != 0; }
    // End CanBombard flag group
    //
    bool             GetCanCounterBombard() const { return (m_flags0 & k_Unit_CanCounterBombard_Bit) != 0; }
    bool             GetCanLiftOff() const { return (m_flags0 & k_Unit_CanLiftOff_Bit) != 0; }

    //
    // Settle flag group
    uint32           GetSettle() const { return m_Settle; }
    bool             GetSettleLand() const { return (m_Settle & k_Unit_Settle_Land_Bit) != 0; }
    bool             GetSettleWater() const { return (m_Settle & k_Unit_Settle_Water_Bit) != 0; }
    bool             GetSettleMountain() const { return (m_Settle & k_Unit_Settle_Mountain_Bit) != 0; }
    bool             GetSettleSpace() const { return (m_Settle & k_Unit_Settle_Space_Bit) != 0; }
    // End Settle flag group
    //
    sint32           GetSettleCityTypeIndex() const { return m_SettleCityType; }
    const UnitRecord *GetSettleCityType() const;
    sint32           GetSettleSize() const { return m_SettleSize; }
    sint32           GetSettleBuildingIndex(sint32 index) const;
    const BuildingRecord *GetSettleBuilding(sint32 index) const;
    sint32           GetNumSettleBuilding() const { return m_numSettleBuilding;}
    bool             GetSpaceLaunch() const { return (m_flags0 & k_Unit_SpaceLaunch_Bit) != 0; }
    bool             GetSpaceLaunch(sint32 &value) const {
                         if((m_flags0 & k_Unit_SpaceLaunch_Bit) == 0) return false;
                         value = m_SpaceLaunchValue;
                         return true;
                     }
    bool             GetSpaceLand() const { return (m_flags0 & k_Unit_SpaceLand_Bit) != 0; }
    bool             GetCantCaptureCity() const { return (m_flags0 & k_Unit_CantCaptureCity_Bit) != 0; }
    bool             GetHasPopAndCanBuild() const { return (m_flags0 & k_Unit_HasPopAndCanBuild_Bit) != 0; }
    bool             GetIsTrader() const { return (m_flags0 & k_Unit_IsTrader_Bit) != 0; }
    bool             GetExertsMartialLaw() const { return (m_flags0 & k_Unit_ExertsMartialLaw_Bit) != 0; }
    bool             GetCanEntrench() const { return (m_flags0 & k_Unit_CanEntrench_Bit) != 0; }
    bool             GetCanPatrol() const { return (m_flags0 & k_Unit_CanPatrol_Bit) != 0; }
    bool             GetNeedsNoSupport() const { return (m_flags0 & k_Unit_NeedsNoSupport_Bit) != 0; }
    bool             GetCanExpelPop() const { return (m_flags0 & k_Unit_CanExpelPop_Bit) != 0; }
    bool             GetIsFlanker() const { return (m_flags0 & k_Unit_IsFlanker_Bit) != 0; }
    bool             GetCanBeachAssault() const { return (m_flags0 & k_Unit_CanBeachAssault_Bit) != 0; }

    //
    // Defend flag group
    uint32           GetDefend() const { return m_Defend; }
    bool             GetDefendLand() const { return (m_Defend & k_Unit_Defend_Land_Bit) != 0; }
    bool             GetDefendAir() const { return (m_Defend & k_Unit_Defend_Air_Bit) != 0; }
    bool             GetDefendWater() const { return (m_Defend & k_Unit_Defend_Water_Bit) != 0; }
    bool             GetDefendSpace() const { return (m_Defend & k_Unit_Defend_Space_Bit) != 0; }
    bool             GetDefendMountain() const { return (m_Defend & k_Unit_Defend_Mountain_Bit) != 0; }
    // End Defend flag group
    //
    bool             GetDefendAgainstSpies() const { return (m_flags0 & k_Unit_DefendAgainstSpies_Bit) != 0; }
    bool             GetDefendAgainstSpies(double &value) const {
                         if((m_flags0 & k_Unit_DefendAgainstSpies_Bit) == 0) return false;
                         value = m_DefendAgainstSpiesValue;
                         return true;
                     }
    bool             GetCanBeExpelled() const { return (m_flags0 & k_Unit_CanBeExpelled_Bit) != 0; }
    bool             GetCanBeSued() const { return (m_flags0 & k_Unit_CanBeSued_Bit) != 0; }
    bool             GetAttackFromSpaceship() const { return (m_flags0 & k_Unit_AttackFromSpaceship_Bit) != 0; }
    bool             GetCantBeAttacked() const { return (m_flags0 & k_Unit_CantBeAttacked_Bit) != 0; }
    bool             GetCargoPod() const { return (m_flags0 & k_Unit_CargoPod_Bit) != 0; }
    bool             GetIsMounted() const { return (m_flags0 & k_Unit_IsMounted_Bit) != 0; }
    bool             GetIgnoreCityWalls() const { return (m_flags0 & k_Unit_IgnoreCityWalls_Bit) != 0; }
    bool             GetIsSubmarine() const { return (m_flags0 & k_Unit_IsSubmarine_Bit) != 0; }
    bool             GetNoLandAttack() const { return (m_flags0 & k_Unit_NoLandAttack_Bit) != 0; }
    bool             GetNoSeaAttack() const { return (m_flags0 & k_Unit_NoSeaAttack_Bit) != 0; }
    bool             GetNoAirAttack() const { return (m_flags0 & k_Unit_NoAirAttack_Bit) != 0; }
    bool             GetNoSpaceAttack() const { return (m_flags1 & k_Unit_NoSpaceAttack_Bit) != 0; }
    bool             GetNoUnderwaterAttack() const { return (m_flags1 & k_Unit_NoUnderwaterAttack_Bit) != 0; }
    bool             GetNoMountainAttack() const { return (m_flags1 & k_Unit_NoMountainAttack_Bit) != 0; }
    bool             GetNoShallowWaterAttack() const { return (m_flags1 & k_Unit_NoShallowWaterAttack_Bit) != 0; }
    bool             GetParatrooper() const { return (m_flags1 & k_Unit_Paratrooper_Bit) != 0; }
    bool             GetAssistedDrops() const { return (m_flags1 & k_Unit_AssistedDrops_Bit) != 0; }
    bool             GetBonusAgainstMounted() const { return (m_flags1 & k_Unit_BonusAgainstMounted_Bit) != 0; }
    bool             GetSingleUse() const { return (m_flags1 & k_Unit_SingleUse_Bit) != 0; }
    bool             GetBonusAirDefense() const { return (m_flags1 & k_Unit_BonusAirDefense_Bit) != 0; }
    bool             GetWoodenShip() const { return (m_flags1 & k_Unit_WoodenShip_Bit) != 0; }
    bool             GetAttackWoodenShipBonus() const { return (m_flags1 & k_Unit_AttackWoodenShipBonus_Bit) != 0; }
    bool             GetHasAttackCityBonus() const { return (m_flags1 & k_Unit_HasAttackCityBonus_Bit) != 0; }
    bool             GetHasAttackBonusSubmarine() const { return (m_flags1 & k_Unit_HasAttackBonusSubmarine_Bit) != 0; }
    bool             GetReplaceWithCargoModule() const { return (m_flags1 & k_Unit_ReplaceWithCargoModule_Bit) != 0; }
    bool             GetReplaceWithCargoModule(sint32 &value) const {
                         if((m_flags1 & k_Unit_ReplaceWithCargoModule_Bit) == 0) return false;
                         value = m_ReplaceWithCargoModuleValue;
                         return true;
                     }
    bool             GetVisibileAttacking() const { return (m_flags1 & k_Unit_VisibileAttacking_Bit) != 0; }
    bool             GetNuclearAttack() const { return (m_flags1 & k_Unit_NuclearAttack_Bit) != 0; }
    bool             GetNuclearAttack(const SoundAndEffect *&ptr) const {
                         if((m_flags1 & k_Unit_NuclearAttack_Bit) == 0) return false;
                         ptr = &m_NuclearAttackValue;
                         return true;
                     }
    const SoundAndEffect        *GetNuclearAttackPtr() const {
                         if((m_flags1 & k_Unit_NuclearAttack_Bit) == 0) return NULL;
                         return &m_NuclearAttackValue;
                     }
    bool             GetCanSue() const { return (m_flags1 & k_Unit_CanSue_Bit) != 0; }
    bool             GetIsStealthy() const { return (m_flags1 & k_Unit_IsStealthy_Bit) != 0; }
    bool             GetSeeSurfaceFromSpace() const { return (m_flags1 & k_Unit_SeeSurfaceFromSpace_Bit) != 0; }
    bool             GetEstablishEmbassy() const { return (m_flags1 & k_Unit_EstablishEmbassy_Bit) != 0; }
    bool             GetThrowParty() const { return (m_flags1 & k_Unit_ThrowParty_Bit) != 0; }
    bool             GetHearGossip() const { return (m_flags1 & k_Unit_HearGossip_Bit) != 0; }
    bool             GetStealTechnology() const { return (m_flags1 & k_Unit_StealTechnology_Bit) != 0; }
    bool             GetStealTechnology(const StealTechnologyData *&ptr) const {
                         if((m_flags1 & k_Unit_StealTechnology_Bit) == 0) return false;
                         ptr = &m_StealTechnologyValue;
                         return true;
                     }
    const StealTechnologyData        *GetStealTechnologyPtr() const {
                         if((m_flags1 & k_Unit_StealTechnology_Bit) == 0) return NULL;
                         return &m_StealTechnologyValue;
                     }
    bool             GetInciteRevolution() const { return (m_flags1 & k_Unit_InciteRevolution_Bit) != 0; }
    bool             GetInciteRevolution(const InciteRevolutionData *&ptr) const {
                         if((m_flags1 & k_Unit_InciteRevolution_Bit) == 0) return false;
                         ptr = &m_InciteRevolutionValue;
                         return true;
                     }
    const InciteRevolutionData        *GetInciteRevolutionPtr() const {
                         if((m_flags1 & k_Unit_InciteRevolution_Bit) == 0) return NULL;
                         return &m_InciteRevolutionValue;
                     }
    bool             GetAssasinateRuler() const { return (m_flags1 & k_Unit_AssasinateRuler_Bit) != 0; }
    bool             GetAssasinateRuler(const AssasinateRulerData *&ptr) const {
                         if((m_flags1 & k_Unit_AssasinateRuler_Bit) == 0) return false;
                         ptr = &m_AssasinateRulerValue;
                         return true;
                     }
    const AssasinateRulerData        *GetAssasinateRulerPtr() const {
                         if((m_flags1 & k_Unit_AssasinateRuler_Bit) == 0) return NULL;
                         return &m_AssasinateRulerValue;
                     }
    bool             GetInvestigateReadiness() const { return (m_flags1 & k_Unit_InvestigateReadiness_Bit) != 0; }
    bool             GetInvestigateReadiness(const InvestigateReadinessData *&ptr) const {
                         if((m_flags1 & k_Unit_InvestigateReadiness_Bit) == 0) return false;
                         ptr = &m_InvestigateReadinessValue;
                         return true;
                     }
    const InvestigateReadinessData        *GetInvestigateReadinessPtr() const {
                         if((m_flags1 & k_Unit_InvestigateReadiness_Bit) == 0) return NULL;
                         return &m_InvestigateReadinessValue;
                     }
    bool             GetNullifyCityWalls() const { return (m_flags1 & k_Unit_NullifyCityWalls_Bit) != 0; }
    bool             GetCreateFranchise() const { return (m_flags1 & k_Unit_CreateFranchise_Bit) != 0; }
    bool             GetCreateFranchise(const ChanceEffect *&ptr) const {
                         if((m_flags1 & k_Unit_CreateFranchise_Bit) == 0) return false;
                         ptr = &m_CreateFranchiseValue;
                         return true;
                     }
    const ChanceEffect        *GetCreateFranchisePtr() const {
                         if((m_flags1 & k_Unit_CreateFranchise_Bit) == 0) return NULL;
                         return &m_CreateFranchiseValue;
                     }
    bool             GetCauseUnhappiness() const { return (m_flags1 & k_Unit_CauseUnhappiness_Bit) != 0; }
    bool             GetCauseUnhappiness(const CauseUnhappinessData *&ptr) const {
                         if((m_flags1 & k_Unit_CauseUnhappiness_Bit) == 0) return false;
                         ptr = &m_CauseUnhappinessValue;
                         return true;
                     }
    const CauseUnhappinessData        *GetCauseUnhappinessPtr() const {
                         if((m_flags1 & k_Unit_CauseUnhappiness_Bit) == 0) return NULL;
                         return &m_CauseUnhappinessValue;
                     }
    bool             GetConductHits() const { return (m_flags1 & k_Unit_ConductHits_Bit) != 0; }
    bool             GetConductHits(const SoundAndEffect *&ptr) const {
                         if((m_flags1 & k_Unit_ConductHits_Bit) == 0) return false;
                         ptr = &m_ConductHitsValue;
                         return true;
                     }
    const SoundAndEffect        *GetConductHitsPtr() const {
                         if((m_flags1 & k_Unit_ConductHits_Bit) == 0) return NULL;
                         return &m_ConductHitsValue;
                     }
    bool             GetBioTerror() const { return (m_flags1 & k_Unit_BioTerror_Bit) != 0; }
    bool             GetBioTerror(const ChanceEffect *&ptr) const {
                         if((m_flags1 & k_Unit_BioTerror_Bit) == 0) return false;
                         ptr = &m_BioTerrorValue;
                         return true;
                     }
    const ChanceEffect        *GetBioTerrorPtr() const {
                         if((m_flags1 & k_Unit_BioTerror_Bit) == 0) return NULL;
                         return &m_BioTerrorValue;
                     }
    bool             GetNanoTerror() const { return (m_flags1 & k_Unit_NanoTerror_Bit) != 0; }
    bool             GetNanoTerror(const ChanceEffect *&ptr) const {
                         if((m_flags1 & k_Unit_NanoTerror_Bit) == 0) return false;
                         ptr = &m_NanoTerrorValue;
                         return true;
                     }
    const ChanceEffect        *GetNanoTerrorPtr() const {
                         if((m_flags1 & k_Unit_NanoTerror_Bit) == 0) return NULL;
                         return &m_NanoTerrorValue;
                     }
    bool             GetPlague() const { return (m_flags2 & k_Unit_Plague_Bit) != 0; }
    bool             GetPlague(const ChanceEffect *&ptr) const {
                         if((m_flags2 & k_Unit_Plague_Bit) == 0) return false;
                         ptr = &m_PlagueValue;
                         return true;
                     }
    const ChanceEffect        *GetPlaguePtr() const {
                         if((m_flags2 & k_Unit_Plague_Bit) == 0) return NULL;
                         return &m_PlagueValue;
                     }
    bool             GetSlaveRaids() const { return (m_flags2 & k_Unit_SlaveRaids_Bit) != 0; }
    bool             GetSlaveRaids(const SlaveRaidsData *&ptr) const {
                         if((m_flags2 & k_Unit_SlaveRaids_Bit) == 0) return false;
                         ptr = &m_SlaveRaidsValue;
                         return true;
                     }
    const SlaveRaidsData        *GetSlaveRaidsPtr() const {
                         if((m_flags2 & k_Unit_SlaveRaids_Bit) == 0) return NULL;
                         return &m_SlaveRaidsValue;
                     }
    bool             GetSettlerSlaveRaids() const { return (m_flags2 & k_Unit_SettlerSlaveRaids_Bit) != 0; }
    bool             GetSettlerSlaveRaids(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_SettlerSlaveRaids_Bit) == 0) return false;
                         ptr = &m_SettlerSlaveRaidsValue;
                         return true;
                     }
    const SoundAndEffect        *GetSettlerSlaveRaidsPtr() const {
                         if((m_flags2 & k_Unit_SettlerSlaveRaids_Bit) == 0) return NULL;
                         return &m_SettlerSlaveRaidsValue;
                     }
    bool             GetSlaveUprising() const { return (m_flags2 & k_Unit_SlaveUprising_Bit) != 0; }
    bool             GetSlaveUprising(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_SlaveUprising_Bit) == 0) return false;
                         ptr = &m_SlaveUprisingValue;
                         return true;
                     }
    const SoundAndEffect        *GetSlaveUprisingPtr() const {
                         if((m_flags2 & k_Unit_SlaveUprising_Bit) == 0) return NULL;
                         return &m_SlaveUprisingValue;
                     }
    bool             GetUndergroundRailway() const { return (m_flags2 & k_Unit_UndergroundRailway_Bit) != 0; }
    bool             GetUndergroundRailway(const SuccessDeathEffect *&ptr) const {
                         if((m_flags2 & k_Unit_UndergroundRailway_Bit) == 0) return false;
                         ptr = &m_UndergroundRailwayValue;
                         return true;
                     }
    const SuccessDeathEffect        *GetUndergroundRailwayPtr() const {
                         if((m_flags2 & k_Unit_UndergroundRailway_Bit) == 0) return NULL;
                         return &m_UndergroundRailwayValue;
                     }
    bool             GetVictoryEnslavement() const { return (m_flags2 & k_Unit_VictoryEnslavement_Bit) != 0; }
    bool             GetDefuseLandMines() const { return (m_flags2 & k_Unit_DefuseLandMines_Bit) != 0; }
    bool             GetDefuseSeaMines() const { return (m_flags2 & k_Unit_DefuseSeaMines_Bit) != 0; }
    bool             GetDefuseXrayMines() const { return (m_flags2 & k_Unit_DefuseXrayMines_Bit) != 0; }
    bool             GetIndulgenceSales() const { return (m_flags2 & k_Unit_IndulgenceSales_Bit) != 0; }
    bool             GetIndulgenceSales(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_IndulgenceSales_Bit) == 0) return false;
                         ptr = &m_IndulgenceSalesValue;
                         return true;
                     }
    const SoundAndEffect        *GetIndulgenceSalesPtr() const {
                         if((m_flags2 & k_Unit_IndulgenceSales_Bit) == 0) return NULL;
                         return &m_IndulgenceSalesValue;
                     }
    bool             GetConvertCities() const { return (m_flags2 & k_Unit_ConvertCities_Bit) != 0; }
    bool             GetConvertCities(const SuccessDeathEffect *&ptr) const {
                         if((m_flags2 & k_Unit_ConvertCities_Bit) == 0) return false;
                         ptr = &m_ConvertCitiesValue;
                         return true;
                     }
    const SuccessDeathEffect        *GetConvertCitiesPtr() const {
                         if((m_flags2 & k_Unit_ConvertCities_Bit) == 0) return NULL;
                         return &m_ConvertCitiesValue;
                     }
    bool             GetBuildXrayMines() const { return (m_flags2 & k_Unit_BuildXrayMines_Bit) != 0; }
    bool             GetBuildWonder() const { return (m_flags2 & k_Unit_BuildWonder_Bit) != 0; }
    sint32           GetGovernmentTypeIndex(sint32 index) const;
    const GovernmentRecord *GetGovernmentType(sint32 index) const;
    sint32           GetNumGovernmentType() const { return m_numGovernmentType;}
    bool             GetNoSlaves() const { return (m_flags2 & k_Unit_NoSlaves_Bit) != 0; }
    bool             GetCreateRift() const { return (m_flags2 & k_Unit_CreateRift_Bit) != 0; }
    bool             GetCanCloak() const { return (m_flags2 & k_Unit_CanCloak_Bit) != 0; }
    bool             GetParatrooperTransport() const { return (m_flags2 & k_Unit_ParatrooperTransport_Bit) != 0; }
    bool             GetCantBuild() const { return (m_flags2 & k_Unit_CantBuild_Bit) != 0; }
    bool             GetPlantNuke() const { return (m_flags2 & k_Unit_PlantNuke_Bit) != 0; }
    bool             GetPlantNuke(const PlantNukeData *&ptr) const {
                         if((m_flags2 & k_Unit_PlantNuke_Bit) == 0) return false;
                         ptr = &m_PlantNukeValue;
                         return true;
                     }
    const PlantNukeData        *GetPlantNukePtr() const {
                         if((m_flags2 & k_Unit_PlantNuke_Bit) == 0) return NULL;
                         return &m_PlantNukeValue;
                     }
    bool             GetIsTelevangelist() const { return (m_flags2 & k_Unit_IsTelevangelist_Bit) != 0; }
    bool             GetCanSoothsay() const { return (m_flags2 & k_Unit_CanSoothsay_Bit) != 0; }
    bool             GetCanSoothsay(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_CanSoothsay_Bit) == 0) return false;
                         ptr = &m_CanSoothsayValue;
                         return true;
                     }
    const SoundAndEffect        *GetCanSoothsayPtr() const {
                         if((m_flags2 & k_Unit_CanSoothsay_Bit) == 0) return NULL;
                         return &m_CanSoothsayValue;
                     }
    bool             GetCanBeRustled() const { return (m_flags2 & k_Unit_CanBeRustled_Bit) != 0; }
    bool             GetCreateParks() const { return (m_flags2 & k_Unit_CreateParks_Bit) != 0; }
    bool             GetCreateParks(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_CreateParks_Bit) == 0) return false;
                         ptr = &m_CreateParksValue;
                         return true;
                     }
    const SoundAndEffect        *GetCreateParksPtr() const {
                         if((m_flags2 & k_Unit_CreateParks_Bit) == 0) return NULL;
                         return &m_CreateParksValue;
                     }
    bool             GetCanInjoin() const { return (m_flags2 & k_Unit_CanInjoin_Bit) != 0; }
    bool             GetCanInjoin(const SoundAndEffect *&ptr) const {
                         if((m_flags2 & k_Unit_CanInjoin_Bit) == 0) return false;
                         ptr = &m_CanInjoinValue;
                         return true;
                     }
    const SoundAndEffect        *GetCanInjoinPtr() const {
                         if((m_flags2 & k_Unit_CanInjoin_Bit) == 0) return NULL;
                         return &m_CanInjoinValue;
                     }
    bool             GetWormholeProbe() const { return (m_flags2 & k_Unit_WormholeProbe_Bit) != 0; }
    bool             GetHasBonusFood() const { return (m_flags2 & k_Unit_HasBonusFood_Bit) != 0; }
    bool             GetLandCityCanBuild() const { return (m_flags2 & k_Unit_LandCityCanBuild_Bit) != 0; }
    bool             GetSeaCityCanBuild() const { return (m_flags2 & k_Unit_SeaCityCanBuild_Bit) != 0; }
    bool             GetSpaceCityCanBuild() const { return (m_flags2 & k_Unit_SpaceCityCanBuild_Bit) != 0; }
    bool             GetIsSpecialForces() const { return (m_flags2 & k_Unit_IsSpecialForces_Bit) != 0; }
    bool             GetNotAffectedByLandMines() const { return (m_flags2 & k_Unit_NotAffectedByLandMines_Bit) != 0; }
    bool             GetInternalReserved() const { return (m_flags2 & k_Unit_InternalReserved_Bit) != 0; }
    bool             GetDeathEffectsHappy() const { return (m_flags3 & k_Unit_DeathEffectsHappy_Bit) != 0; }
    bool             GetEnableCarrierDefenses() const { return (m_flags3 & k_Unit_EnableCarrierDefenses_Bit) != 0; }
    bool             GetActiveDefenseOnlyWhenCarryingEnablers() const { return (m_flags3 & k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit) != 0; }
    bool             GetBuildingRemovesAPop() const { return (m_flags3 & k_Unit_BuildingRemovesAPop_Bit) != 0; }
    bool             GetExplodes() const { return (m_flags3 & k_Unit_Explodes_Bit) != 0; }
    bool             GetAdvertise() const { return (m_flags3 & k_Unit_Advertise_Bit) != 0; }
    bool             GetCanRustle() const { return (m_flags3 & k_Unit_CanRustle_Bit) != 0; }
    bool             GetOnlyBuildOne() const { return (m_flags3 & k_Unit_OnlyBuildOne_Bit) != 0; }
    bool             GetCanExpel() const { return (m_flags3 & k_Unit_CanExpel_Bit) != 0; }
    bool             GetCanReform() const { return (m_flags3 & k_Unit_CanReform_Bit) != 0; }
    bool             GetCanReform(const SoundAndEffect *&ptr) const {
                         if((m_flags3 & k_Unit_CanReform_Bit) == 0) return false;
                         ptr = &m_CanReformValue;
                         return true;
                     }
    const SoundAndEffect        *GetCanReformPtr() const {
                         if((m_flags3 & k_Unit_CanReform_Bit) == 0) return NULL;
                         return &m_CanReformValue;
                     }
    bool             GetCanPillage() const { return (m_flags3 & k_Unit_CanPillage_Bit) != 0; }
    bool             GetCanPirate() const { return (m_flags3 & k_Unit_CanPirate_Bit) != 0; }

    //
    // VisionClass flag group
    uint32           GetVisionClass() const { return m_VisionClass; }
    bool             GetVisionClassStandard() const { return (m_VisionClass & k_Unit_VisionClass_Standard_Bit) != 0; }
    bool             GetVisionClassUnderwater() const { return (m_VisionClass & k_Unit_VisionClass_Underwater_Bit) != 0; }
    bool             GetVisionClassStealth() const { return (m_VisionClass & k_Unit_VisionClass_Stealth_Bit) != 0; }
    bool             GetVisionClassUnusedBit3() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit3_Bit) != 0; }
    bool             GetVisionClassUnusedBit4() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit4_Bit) != 0; }
    bool             GetVisionClassUnusedBit5() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit5_Bit) != 0; }
    bool             GetVisionClassUnusedBit6() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit6_Bit) != 0; }
    bool             GetVisionClassUnusedBit7() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit7_Bit) != 0; }
    bool             GetVisionClassUnusedBit8() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit8_Bit) != 0; }
    bool             GetVisionClassUnusedBit9() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit9_Bit) != 0; }
    bool             GetVisionClassUnusedBit10() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit10_Bit) != 0; }
    bool             GetVisionClassUnusedBit11() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit11_Bit) != 0; }
    bool             GetVisionClassUnusedBit12() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit12_Bit) != 0; }
    bool             GetVisionClassUnusedBit13() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit13_Bit) != 0; }
    bool             GetVisionClassUnusedBit14() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit14_Bit) != 0; }
    bool             GetVisionClassUnusedBit15() const { return (m_VisionClass & k_Unit_VisionClass_UnusedBit15_Bit) != 0; }
    // End VisionClass flag group
    //

    //
    // CanSee flag group
    uint32           GetCanSee() const { return m_CanSee; }
    bool             GetCanSeeStandard() const { return (m_CanSee & k_Unit_CanSee_Standard_Bit) != 0; }
    bool             GetCanSeeUnderwater() const { return (m_CanSee & k_Unit_CanSee_Underwater_Bit) != 0; }
    bool             GetCanSeeStealth() const { return (m_CanSee & k_Unit_CanSee_Stealth_Bit) != 0; }
    bool             GetCanSeeUnusedBit3() const { return (m_CanSee & k_Unit_CanSee_UnusedBit3_Bit) != 0; }
    bool             GetCanSeeUnusedBit4() const { return (m_CanSee & k_Unit_CanSee_UnusedBit4_Bit) != 0; }
    bool             GetCanSeeUnusedBit5() const { return (m_CanSee & k_Unit_CanSee_UnusedBit5_Bit) != 0; }
    bool             GetCanSeeUnusedBit6() const { return (m_CanSee & k_Unit_CanSee_UnusedBit6_Bit) != 0; }
    bool             GetCanSeeUnusedBit7() const { return (m_CanSee & k_Unit_CanSee_UnusedBit7_Bit) != 0; }
    bool             GetCanSeeUnusedBit8() const { return (m_CanSee & k_Unit_CanSee_UnusedBit8_Bit) != 0; }
    bool             GetCanSeeUnusedBit9() const { return (m_CanSee & k_Unit_CanSee_UnusedBit9_Bit) != 0; }
    bool             GetCanSeeUnusedBit10() const { return (m_CanSee & k_Unit_CanSee_UnusedBit10_Bit) != 0; }
    bool             GetCanSeeUnusedBit11() const { return (m_CanSee & k_Unit_CanSee_UnusedBit11_Bit) != 0; }
    bool             GetCanSeeUnusedBit12() const { return (m_CanSee & k_Unit_CanSee_UnusedBit12_Bit) != 0; }
    bool             GetCanSeeUnusedBit13() const { return (m_CanSee & k_Unit_CanSee_UnusedBit13_Bit) != 0; }
    bool             GetCanSeeUnusedBit14() const { return (m_CanSee & k_Unit_CanSee_UnusedBit14_Bit) != 0; }
    bool             GetCanSeeUnusedBit15() const { return (m_CanSee & k_Unit_CanSee_UnusedBit15_Bit) != 0; }
    // End CanSee flag group
    //

    //
    // CanAttack flag group
    uint32           GetCanAttack() const { return m_CanAttack; }
    bool             GetCanAttackLand() const { return (m_CanAttack & k_Unit_CanAttack_Land_Bit) != 0; }
    bool             GetCanAttackSea() const { return (m_CanAttack & k_Unit_CanAttack_Sea_Bit) != 0; }
    bool             GetCanAttackAir() const { return (m_CanAttack & k_Unit_CanAttack_Air_Bit) != 0; }
    bool             GetCanAttackMountain() const { return (m_CanAttack & k_Unit_CanAttack_Mountain_Bit) != 0; }
    bool             GetCanAttackTrade() const { return (m_CanAttack & k_Unit_CanAttack_Trade_Bit) != 0; }
    bool             GetCanAttackShallowWater() const { return (m_CanAttack & k_Unit_CanAttack_ShallowWater_Bit) != 0; }
    bool             GetCanAttackSpace() const { return (m_CanAttack & k_Unit_CanAttack_Space_Bit) != 0; }
    bool             GetCanAttackUnderwater() const { return (m_CanAttack & k_Unit_CanAttack_Underwater_Bit) != 0; }
    // End CanAttack flag group
    //
    bool             GetCargoData() const { return (m_flags3 & k_Unit_CargoData_Bit) != 0; }
    bool             GetCargoData(const CargoData *&ptr) const {
                         if((m_flags3 & k_Unit_CargoData_Bit) == 0) return false;
                         ptr = &m_CargoDataValue;
                         return true;
                     }
    const CargoData        *GetCargoDataPtr() const {
                         if((m_flags3 & k_Unit_CargoData_Bit) == 0) return NULL;
                         return &m_CargoDataValue;
                     }
    sint32           GetShieldCost() const { return m_ShieldCost; }
    sint32           GetPowerPoints() const { return m_PowerPoints; }
    sint32           GetMaxHP() const { return m_MaxHP; }
    double           GetMaxHPr() const { return m_MaxHPr; }
    double           GetAttack() const { return m_Attack; }
    double           GetDefense() const { return m_Defense; }
    sint32           GetFirepower() const { return m_Firepower; }
    sint32           GetZBRangeAttack() const { return m_ZBRangeAttack; }
    double           GetArmor() const { return m_Armor; }
    bool             GetBRange() const { return (m_flags3 & k_Unit_BRange_Bit) != 0; }
    bool             GetBRange(sint32 &value) const {
                         if((m_flags3 & k_Unit_BRange_Bit) == 0) return false;
                         value = m_BRangeValue;
                         return true;
                     }
    bool             GetBRadius() const { return (m_flags3 & k_Unit_BRadius_Bit) != 0; }
    bool             GetBRadius(sint32 &value) const {
                         if((m_flags3 & k_Unit_BRadius_Bit) == 0) return false;
                         value = m_BRadiusValue;
                         return true;
                     }
    sint32           GetVisionRange() const { return m_VisionRange; }
    sint32           GetActiveDefenseRange() const { return m_ActiveDefenseRange; }
    bool             GetElectronicCombatFactor() const { return (m_flags3 & k_Unit_ElectronicCombatFactor_Bit) != 0; }
    bool             GetElectronicCombatFactor(sint32 &value) const {
                         if((m_flags3 & k_Unit_ElectronicCombatFactor_Bit) == 0) return false;
                         value = m_ElectronicCombatFactorValue;
                         return true;
                     }
    double           GetMaxMovePoints() const { return m_MaxMovePoints; }
    sint32           GetMaxFuel() const { return m_MaxFuel; }
    bool             GetTransType() const { return (m_flags3 & k_Unit_TransType_Bit) != 0; }
    bool             GetTransType(sint32 &value) const {
                         if((m_flags3 & k_Unit_TransType_Bit) == 0) return false;
                         value = m_TransTypeValue;
                         return true;
                     }
    bool             GetProbOfBombHit() const { return (m_flags3 & k_Unit_ProbOfBombHit_Bit) != 0; }
    bool             GetProbOfBombHit(sint32 &value) const {
                         if((m_flags3 & k_Unit_ProbOfBombHit_Bit) == 0) return false;
                         value = m_ProbOfBombHitValue;
                         return true;
                     }
    bool             GetBombRounds() const { return (m_flags3 & k_Unit_BombRounds_Bit) != 0; }
    bool             GetBombRounds(sint32 &value) const {
                         if((m_flags3 & k_Unit_BombRounds_Bit) == 0) return false;
                         value = m_BombRoundsValue;
                         return true;
                     }
    sint32           GetShieldHunger() const { return m_ShieldHunger; }
    sint32           GetFoodHunger() const { return m_FoodHunger; }
    sint32           GetDefaultSpriteIndex() const { return m_DefaultSprite; }
    const SpriteRecord *GetDefaultSprite() const;
    bool             GetLaunchPollution() const { return (m_flags3 & k_Unit_LaunchPollution_Bit) != 0; }
    bool             GetLaunchPollution(sint32 &value) const {
                         if((m_flags3 & k_Unit_LaunchPollution_Bit) == 0) return false;
                         value = m_LaunchPollutionValue;
                         return true;
                     }
    bool             GetDeathPollution() const { return (m_flags3 & k_Unit_DeathPollution_Bit) != 0; }
    bool             GetDeathPollution(sint32 &value) const {
                         if((m_flags3 & k_Unit_DeathPollution_Bit) == 0) return false;
                         value = m_DeathPollutionValue;
                         return true;
                     }
    bool             GetMountedBonus() const { return (m_flags3 & k_Unit_MountedBonus_Bit) != 0; }
    bool             GetMountedBonus(double &value) const {
                         if((m_flags3 & k_Unit_MountedBonus_Bit) == 0) return false;
                         value = m_MountedBonusValue;
                         return true;
                     }
    bool             GetAirBonus() const { return (m_flags3 & k_Unit_AirBonus_Bit) != 0; }
    bool             GetAirBonus(double &value) const {
                         if((m_flags3 & k_Unit_AirBonus_Bit) == 0) return false;
                         value = m_AirBonusValue;
                         return true;
                     }
    bool             GetWoodenShipBonus() const { return (m_flags3 & k_Unit_WoodenShipBonus_Bit) != 0; }
    bool             GetWoodenShipBonus(double &value) const {
                         if((m_flags3 & k_Unit_WoodenShipBonus_Bit) == 0) return false;
                         value = m_WoodenShipBonusValue;
                         return true;
                     }
    bool             GetAttackCityBonus() const { return (m_flags3 & k_Unit_AttackCityBonus_Bit) != 0; }
    bool             GetAttackCityBonus(double &value) const {
                         if((m_flags3 & k_Unit_AttackCityBonus_Bit) == 0) return false;
                         value = m_AttackCityBonusValue;
                         return true;
                     }
    bool             GetAttackBonusSubmarine() const { return (m_flags3 & k_Unit_AttackBonusSubmarine_Bit) != 0; }
    bool             GetAttackBonusSubmarine(double &value) const {
                         if((m_flags3 & k_Unit_AttackBonusSubmarine_Bit) == 0) return false;
                         value = m_AttackBonusSubmarineValue;
                         return true;
                     }
    bool             GetCargoModule() const { return (m_flags3 & k_Unit_CargoModule_Bit) != 0; }
    bool             GetCargoModule(sint32 &value) const {
                         if((m_flags3 & k_Unit_CargoModule_Bit) == 0) return false;
                         value = m_CargoModuleValue;
                         return true;
                     }
    bool             GetSpyVsSpy() const { return (m_flags3 & k_Unit_SpyVsSpy_Bit) != 0; }
    bool             GetSpyVsSpy(double &value) const {
                         if((m_flags3 & k_Unit_SpyVsSpy_Bit) == 0) return false;
                         value = m_SpyVsSpyValue;
                         return true;
                     }
    bool             GetInvestigateCity() const { return (m_flags3 & k_Unit_InvestigateCity_Bit) != 0; }
    bool             GetInvestigateCity(const InvestigateCityData *&ptr) const {
                         if((m_flags3 & k_Unit_InvestigateCity_Bit) == 0) return false;
                         ptr = &m_InvestigateCityValue;
                         return true;
                     }
    const InvestigateCityData        *GetInvestigateCityPtr() const {
                         if((m_flags3 & k_Unit_InvestigateCity_Bit) == 0) return NULL;
                         return &m_InvestigateCityValue;
                     }
    bool             GetBonusFood() const { return (m_flags3 & k_Unit_BonusFood_Bit) != 0; }
    bool             GetBonusFood(sint32 &value) const {
                         if((m_flags3 & k_Unit_BonusFood_Bit) == 0) return false;
                         value = m_BonusFoodValue;
                         return true;
                     }
    bool             GetBombardRange() const { return (m_flags3 & k_Unit_BombardRange_Bit) != 0; }
    bool             GetBombardRange(sint32 &value) const {
                         if((m_flags3 & k_Unit_BombardRange_Bit) == 0) return false;
                         value = m_BombardRangeValue;
                         return true;
                     }
    bool             GetRevolution() const { return (m_flags3 & k_Unit_Revolution_Bit) != 0; }
    bool             GetRevolution(const RevolutionData *&ptr) const {
                         if((m_flags3 & k_Unit_Revolution_Bit) == 0) return false;
                         ptr = &m_RevolutionValue;
                         return true;
                     }
    const RevolutionData        *GetRevolutionPtr() const {
                         if((m_flags3 & k_Unit_Revolution_Bit) == 0) return NULL;
                         return &m_RevolutionValue;
                     }
    sint32           GetSoundSelect1Index() const { return m_SoundSelect1; }
    const SoundRecord *GetSoundSelect1() const;
    sint32           GetSoundSelect2Index() const { return m_SoundSelect2; }
    const SoundRecord *GetSoundSelect2() const;
    sint32           GetSoundMoveIndex() const { return m_SoundMove; }
    const SoundRecord *GetSoundMove() const;
    sint32           GetSoundAcknowledgeIndex() const { return m_SoundAcknowledge; }
    const SoundRecord *GetSoundAcknowledge() const;
    sint32           GetSoundCantMoveIndex() const { return m_SoundCantMove; }
    const SoundRecord *GetSoundCantMove() const;
    sint32           GetSoundAttackIndex() const { return m_SoundAttack; }
    const SoundRecord *GetSoundAttack() const;
    sint32           GetSoundWorkIndex() const { return m_SoundWork; }
    const SoundRecord *GetSoundWork() const;
    sint32           GetSoundVictoryIndex() const { return m_SoundVictory; }
    const SoundRecord *GetSoundVictory() const;
    sint32           GetSoundDeathIndex() const { return m_SoundDeath; }
    const SoundRecord *GetSoundDeath() const;
    sint32           GetSoundLoadIndex() const { return m_SoundLoad; }
    const SoundRecord *GetSoundLoad() const;
    sint32           GetSoundUnloadIndex() const { return m_SoundUnload; }
    const SoundRecord *GetSoundUnload() const;
    sint32           GetSpecialAttacksIndex(sint32 index) const;
    const SpecialAttackInfoRecord *GetSpecialAttacks(sint32 index) const;
    sint32           GetNumSpecialAttacks() const { return m_numSpecialAttacks;}
    bool             GetCityGrowthCoefficient() const { return (m_flags4 & k_Unit_CityGrowthCoefficient_Bit) != 0; }
    bool             GetCityGrowthCoefficient(double &value) const {
                         if((m_flags4 & k_Unit_CityGrowthCoefficient_Bit) == 0) return false;
                         value = m_CityGrowthCoefficientValue;
                         return true;
                     }

    //
    // UserFlags flag group
    uint32           GetUserFlags() const { return m_UserFlags; }
    bool             GetUserFlagsUF1() const { return (m_UserFlags & k_Unit_UserFlags_UF1_Bit) != 0; }
    bool             GetUserFlagsUF2() const { return (m_UserFlags & k_Unit_UserFlags_UF2_Bit) != 0; }
    bool             GetUserFlagsUF3() const { return (m_UserFlags & k_Unit_UserFlags_UF3_Bit) != 0; }
    bool             GetUserFlagsUF4() const { return (m_UserFlags & k_Unit_UserFlags_UF4_Bit) != 0; }
    bool             GetUserFlagsUF5() const { return (m_UserFlags & k_Unit_UserFlags_UF5_Bit) != 0; }
    bool             GetUserFlagsUF6() const { return (m_UserFlags & k_Unit_UserFlags_UF6_Bit) != 0; }
    bool             GetUserFlagsUF7() const { return (m_UserFlags & k_Unit_UserFlags_UF7_Bit) != 0; }
    bool             GetUserFlagsUF8() const { return (m_UserFlags & k_Unit_UserFlags_UF8_Bit) != 0; }
    bool             GetUserFlagsUF9() const { return (m_UserFlags & k_Unit_UserFlags_UF9_Bit) != 0; }
    bool             GetUserFlagsUF10() const { return (m_UserFlags & k_Unit_UserFlags_UF10_Bit) != 0; }
    bool             GetUserFlagsUF11() const { return (m_UserFlags & k_Unit_UserFlags_UF11_Bit) != 0; }
    bool             GetUserFlagsUF12() const { return (m_UserFlags & k_Unit_UserFlags_UF12_Bit) != 0; }
    bool             GetUserFlagsUF13() const { return (m_UserFlags & k_Unit_UserFlags_UF13_Bit) != 0; }
    bool             GetUserFlagsUF14() const { return (m_UserFlags & k_Unit_UserFlags_UF14_Bit) != 0; }
    bool             GetUserFlagsUF15() const { return (m_UserFlags & k_Unit_UserFlags_UF15_Bit) != 0; }
    bool             GetUserFlagsUF16() const { return (m_UserFlags & k_Unit_UserFlags_UF16_Bit) != 0; }
    bool             GetUserFlagsUF17() const { return (m_UserFlags & k_Unit_UserFlags_UF17_Bit) != 0; }
    bool             GetUserFlagsUF18() const { return (m_UserFlags & k_Unit_UserFlags_UF18_Bit) != 0; }
    bool             GetUserFlagsUF19() const { return (m_UserFlags & k_Unit_UserFlags_UF19_Bit) != 0; }
    bool             GetUserFlagsUF20() const { return (m_UserFlags & k_Unit_UserFlags_UF20_Bit) != 0; }
    bool             GetUserFlagsUF21() const { return (m_UserFlags & k_Unit_UserFlags_UF21_Bit) != 0; }
    bool             GetUserFlagsUF22() const { return (m_UserFlags & k_Unit_UserFlags_UF22_Bit) != 0; }
    bool             GetUserFlagsUF23() const { return (m_UserFlags & k_Unit_UserFlags_UF23_Bit) != 0; }
    bool             GetUserFlagsUF24() const { return (m_UserFlags & k_Unit_UserFlags_UF24_Bit) != 0; }
    bool             GetUserFlagsUF25() const { return (m_UserFlags & k_Unit_UserFlags_UF25_Bit) != 0; }
    bool             GetUserFlagsUF26() const { return (m_UserFlags & k_Unit_UserFlags_UF26_Bit) != 0; }
    bool             GetUserFlagsUF27() const { return (m_UserFlags & k_Unit_UserFlags_UF27_Bit) != 0; }
    bool             GetUserFlagsUF28() const { return (m_UserFlags & k_Unit_UserFlags_UF28_Bit) != 0; }
    bool             GetUserFlagsUF29() const { return (m_UserFlags & k_Unit_UserFlags_UF29_Bit) != 0; }
    bool             GetUserFlagsUF30() const { return (m_UserFlags & k_Unit_UserFlags_UF30_Bit) != 0; }
    bool             GetUserFlagsUF31() const { return (m_UserFlags & k_Unit_UserFlags_UF31_Bit) != 0; }
    // End UserFlags flag group
    //
    sint32           GetDefaultIconIndex() const { return m_DefaultIcon; }
    const IconRecord *GetDefaultIcon() const;
    bool             GetNoIndex() const { return (m_flags4 & k_Unit_NoIndex_Bit) != 0; }
    bool             GetCheatIndex() const { return (m_flags4 & k_Unit_CheatIndex_Bit) != 0; }
    bool             GetCheatIndex(sint32 &value) const {
                         if((m_flags4 & k_Unit_CheatIndex_Bit) == 0) return false;
                         value = m_CheatIndexValue;
                         return true;
                     }
    sint32           GetDescription() const { return m_Description; }
    bool             GetAdvice() const { return (m_flags4 & k_Unit_Advice_Bit) != 0; }
    bool             GetAdvice(sint32 &value) const {
                         if((m_flags4 & k_Unit_Advice_Bit) == 0) return false;
                         value = m_AdviceValue;
                         return true;
                     }
    sint32           GetCategory() const { return m_Category; }
    bool             GetGLHidden() const { return (m_flags4 & k_Unit_GLHidden_Bit) != 0; }
    bool             GetCantMove() const { return (m_flags4 & k_Unit_CantMove_Bit) != 0; }
    bool             GetCivilian() const { return (m_flags4 & k_Unit_Civilian_Bit) != 0; }
}; /* UnitRecord */

struct UnitRecordAccessorInfo {
    UnitRecord::IntAccessor m_intAccessor;
    UnitRecord::BoolAccessor m_boolAccessor;
    UnitRecord::FloatAccessor m_floatAccessor;
    UnitRecord::BitIntAccessor m_bitIntAccessor;
    UnitRecord::BitFloatAccessor m_bitFloatAccessor;
};
extern UnitRecordAccessorInfo g_UnitRecord_Accessors[];
extern char *g_Unit_Tokens[];
#define k_Num_UnitRecord_Tokens 230

template <class T> class CTPDatabase;
extern CTPDatabase<UnitRecord> *g_theUnitDB;

#endif /* ifndef __Unit_RECORD_H__ */
