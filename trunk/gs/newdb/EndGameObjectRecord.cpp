
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "EndGameObjectRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "WonderRecord.h"
#include "BuildingRecord.h"
#include "TerrainImprovementRecord.h"
#include "EndGameObjectRecord.h"

CTPDatabase<EndGameObjectRecord> *g_theEndGameObjectDB = NULL;

EndGameObjectRecord::Init()
{
    m_flags0 = 0;
    m_WonderValue = 0;
    m_BuildingValue = 0;
    m_TerrainImprovementValue = 0;
    m_MinNeededValue = 0;
    m_MaxNeededValue = 0;
    m_PowerSourceValue = 0;
    m_MinRadiusValue = 0;
    m_MaxRadiusValue = 0;
    m_MinCoverageValue = 0.0;
    m_TurnsToActivateValue = 0;
}

EndGameObjectRecord::~EndGameObjectRecord()
{
	int index = 0;
}

void EndGameObjectRecord::operator=(const EndGameObjectRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_flags0 = rval.m_flags0; 
		m_WonderValue = rval.m_WonderValue; 

	m_flags0 = rval.m_flags0; 
		m_BuildingValue = rval.m_BuildingValue; 

	m_flags0 = rval.m_flags0; 
		m_TerrainImprovementValue = rval.m_TerrainImprovementValue; 

	m_flags0 = rval.m_flags0; 
		m_MinNeededValue = rval.m_MinNeededValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxNeededValue = rval.m_MaxNeededValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
		m_PowerSourceValue = rval.m_PowerSourceValue; 

	m_flags0 = rval.m_flags0; 
		m_MinRadiusValue = rval.m_MinRadiusValue; 

	m_flags0 = rval.m_flags0; 
		m_MaxRadiusValue = rval.m_MaxRadiusValue; 

	m_flags0 = rval.m_flags0; 
		m_MinCoverageValue = rval.m_MinCoverageValue; 

	m_flags0 = rval.m_flags0; 
		m_TurnsToActivateValue = rval.m_TurnsToActivateValue; 

}

char *g_EndGameObject_Tokens[] =
{
    "Wonder",
    "WonderValue",
    "Building",
    "BuildingValue",
    "TerrainImprovement",
    "TerrainImprovementValue",
    "MinNeeded",
    "MinNeededValue",
    "MaxNeeded",
    "MaxNeededValue",
    "IsSatellite",
    "PowerSource",
    "PowerSourceValue",
    "MinRadius",
    "MinRadiusValue",
    "MaxRadius",
    "MaxRadiusValue",
    "MinCoverage",
    "MinCoverageValue",
    "TurnsToActivate",
    "TurnsToActivateValue",
};

EndGameObjectRecordAccessorInfo g_EndGameObjectRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Wonder */
    { NULL, NULL, NULL, NULL, NULL}, /* Wonder */
    { NULL, NULL, NULL, NULL, NULL}, /* Building */
    { NULL, NULL, NULL, NULL, NULL}, /* Building */
    { NULL, NULL, NULL, NULL, NULL}, /* TerrainImprovement */
    { NULL, NULL, NULL, NULL, NULL}, /* TerrainImprovement */
    { NULL, NULL, NULL, EndGameObjectRecord::GetMinNeeded, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinNeeded */
    { NULL, NULL, NULL, EndGameObjectRecord::GetMaxNeeded, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxNeeded */
    { NULL, EndGameObjectRecord::GetIsSatellite, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PowerSource */
    { NULL, NULL, NULL, NULL, NULL}, /* PowerSource */
    { NULL, NULL, NULL, EndGameObjectRecord::GetMinRadius, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MinRadius */
    { NULL, NULL, NULL, EndGameObjectRecord::GetMaxRadius, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* MaxRadius */
    { NULL, NULL, NULL, NULL, EndGameObjectRecord::GetMinCoverage},
    { NULL, NULL, NULL, NULL, NULL}, /* MinCoverage */
    { NULL, NULL, NULL, EndGameObjectRecord::GetTurnsToActivate, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* TurnsToActivate */
};

#define k_Token_EndGameObject_Wonder             ((k_Token_Custom_Base) + 0)
#define k_Token_EndGameObject_Wonder_Value       ((k_Token_Custom_Base) + 1)
#define k_Token_EndGameObject_Building           ((k_Token_Custom_Base) + 2)
#define k_Token_EndGameObject_Building_Value     ((k_Token_Custom_Base) + 3)
#define k_Token_EndGameObject_TerrainImprovement ((k_Token_Custom_Base) + 4)
#define k_Token_EndGameObject_TerrainImprovement_Value ((k_Token_Custom_Base) + 5)
#define k_Token_EndGameObject_MinNeeded          ((k_Token_Custom_Base) + 6)
#define k_Token_EndGameObject_MinNeeded_Value    ((k_Token_Custom_Base) + 7)
#define k_Token_EndGameObject_MaxNeeded          ((k_Token_Custom_Base) + 8)
#define k_Token_EndGameObject_MaxNeeded_Value    ((k_Token_Custom_Base) + 9)
#define k_Token_EndGameObject_IsSatellite        ((k_Token_Custom_Base) + 10)
#define k_Token_EndGameObject_PowerSource        ((k_Token_Custom_Base) + 11)
#define k_Token_EndGameObject_PowerSource_Value  ((k_Token_Custom_Base) + 12)
#define k_Token_EndGameObject_MinRadius          ((k_Token_Custom_Base) + 13)
#define k_Token_EndGameObject_MinRadius_Value    ((k_Token_Custom_Base) + 14)
#define k_Token_EndGameObject_MaxRadius          ((k_Token_Custom_Base) + 15)
#define k_Token_EndGameObject_MaxRadius_Value    ((k_Token_Custom_Base) + 16)
#define k_Token_EndGameObject_MinCoverage        ((k_Token_Custom_Base) + 17)
#define k_Token_EndGameObject_MinCoverage_Value  ((k_Token_Custom_Base) + 18)
#define k_Token_EndGameObject_TurnsToActivate    ((k_Token_Custom_Base) + 19)
#define k_Token_EndGameObject_TurnsToActivate_Value ((k_Token_Custom_Base) + 20)
#define k_Token_EndGameObject_Max                ((k_Token_Custom_Base) + 21)


static BitArray s_ParsedTokens(21);
void EndGameObjectRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 EndGameObjectRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_EndGameObject_Tokens, k_Token_EndGameObject_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_EndGameObject_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_EndGameObject_Wonder:
                m_flags0 |= k_EndGameObject_Wonder_Bit;
                if(!g_theWonderDB->GetRecordFromLexer(lex, m_WonderValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_Building:
                m_flags0 |= k_EndGameObject_Building_Bit;
                if(!g_theBuildingDB->GetRecordFromLexer(lex, m_BuildingValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_TerrainImprovement:
                m_flags0 |= k_EndGameObject_TerrainImprovement_Bit;
                if(!g_theTerrainImprovementDB->GetRecordFromLexer(lex, m_TerrainImprovementValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_MinNeeded:
                m_flags0 |= k_EndGameObject_MinNeeded_Bit;
                if(!lex->GetIntAssignment(m_MinNeededValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_MaxNeeded:
                m_flags0 |= k_EndGameObject_MaxNeeded_Bit;
                if(!lex->GetIntAssignment(m_MaxNeededValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_IsSatellite:
                m_flags0 |= k_EndGameObject_IsSatellite_Bit;
                break;
            case k_Token_EndGameObject_PowerSource:
                m_flags0 |= k_EndGameObject_PowerSource_Bit;
                if(!g_theEndGameObjectDB->GetRecordFromLexer(lex, m_PowerSourceValue, err)) {
                    DBERROR(("Expected record"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_MinRadius:
                m_flags0 |= k_EndGameObject_MinRadius_Bit;
                if(!lex->GetIntAssignment(m_MinRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_MaxRadius:
                m_flags0 |= k_EndGameObject_MaxRadius_Bit;
                if(!lex->GetIntAssignment(m_MaxRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_MinCoverage:
                m_flags0 |= k_EndGameObject_MinCoverage_Bit;
                if(!lex->GetFloatAssignment(m_MinCoverageValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_EndGameObject_TurnsToActivate:
                m_flags0 |= k_EndGameObject_TurnsToActivate_Bit;
                if(!lex->GetIntAssignment(m_TurnsToActivateValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void EndGameObjectRecord::ResolveDBReferences()
{
    if(m_WonderValue & 0x80000000) {
        sint32 id = m_WonderValue & 0x7fffffff;
        if(!g_theWonderDB->GetNamedItem(id, m_WonderValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Wonder database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_WonderValue == 0x7fffffff) {
        m_WonderValue = -1;
    }
    if(m_BuildingValue & 0x80000000) {
        sint32 id = m_BuildingValue & 0x7fffffff;
        if(!g_theBuildingDB->GetNamedItem(id, m_BuildingValue)) {
            c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_BuildingValue == 0x7fffffff) {
        m_BuildingValue = -1;
    }
    if(m_TerrainImprovementValue & 0x80000000) {
        sint32 id = m_TerrainImprovementValue & 0x7fffffff;
        if(!g_theTerrainImprovementDB->GetNamedItem(id, m_TerrainImprovementValue)) {
            c3errors_ErrorDialog("DB", "%s not found in TerrainImprovement database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_TerrainImprovementValue == 0x7fffffff) {
        m_TerrainImprovementValue = -1;
    }
    if(m_PowerSourceValue & 0x80000000) {
        sint32 id = m_PowerSourceValue & 0x7fffffff;
        if(!g_theEndGameObjectDB->GetNamedItem(id, m_PowerSourceValue)) {
            c3errors_ErrorDialog("DB", "%s not found in EndGameObject database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_PowerSourceValue == 0x7fffffff) {
        m_PowerSourceValue = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void EndGameObjectRecord::Merge(const EndGameObjectRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_Wonder_Bit) != 0) 
		m_WonderValue = rval.m_WonderValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_Building_Bit) != 0) 
		m_BuildingValue = rval.m_BuildingValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_TerrainImprovement_Bit) != 0) 
		m_TerrainImprovementValue = rval.m_TerrainImprovementValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_MinNeeded_Bit) != 0) 
		m_MinNeededValue = rval.m_MinNeededValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_MaxNeeded_Bit) != 0) 
		m_MaxNeededValue = rval.m_MaxNeededValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_PowerSource_Bit) != 0) 
		m_PowerSourceValue = rval.m_PowerSourceValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_MinRadius_Bit) != 0) 
		m_MinRadiusValue = rval.m_MinRadiusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_MaxRadius_Bit) != 0) 
		m_MaxRadiusValue = rval.m_MaxRadiusValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_MinCoverage_Bit) != 0) 
		m_MinCoverageValue = rval.m_MinCoverageValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_EndGameObject_TurnsToActivate_Bit) != 0) 
		m_TurnsToActivateValue = rval.m_TurnsToActivateValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const WonderRecord *EndGameObjectRecord::GetWonderPtr() const
{
    return g_theWonderDB->Get(m_WonderValue);
}

const BuildingRecord *EndGameObjectRecord::GetBuildingPtr() const
{
    return g_theBuildingDB->Get(m_BuildingValue);
}

const TerrainImprovementRecord *EndGameObjectRecord::GetTerrainImprovementPtr() const
{
    return g_theTerrainImprovementDB->Get(m_TerrainImprovementValue);
}

const EndGameObjectRecord *EndGameObjectRecord::GetPowerSourcePtr() const
{
    return g_theEndGameObjectDB->Get(m_PowerSourceValue);
}

