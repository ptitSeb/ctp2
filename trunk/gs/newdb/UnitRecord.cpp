
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "UnitRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "AdvanceRecord.h"
#include "AdvanceRecord.h"
#include "UnitRecord.h"
#include "BuildingRecord.h"
#include "GovernmentRecord.h"
#include "SpriteRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialAttackInfoRecord.h"
#include "IconRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SoundRecord.h"
#include "SpecialEffectRecord.h"

CTPDatabase<UnitRecord> *g_theUnitDB = NULL;

UnitRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    m_flags2 = 0;
    m_flags3 = 0;
    m_flags4 = 0;
    m_MovementType = 0;
    m_CanCarry = 0;
    m_EnableAdvance = 0x7fffffff;
    memset(m_ObsoleteAdvance, 0, sizeof(m_ObsoleteAdvance));
    m_numObsoleteAdvance = 0;
    m_Size = 0;
    m_CanBombard = 0;
    m_Settle = 0;
    m_SettleCityType = 0x7fffffff;
    m_SettleSize = 1;
    m_SettleBuilding = NULL;
    m_numSettleBuilding = 0;
    m_SpaceLaunchValue = 0;
    m_Defend = 0;
    m_DefendAgainstSpiesValue = 0.0;
    m_ReplaceWithCargoModuleValue = 0;
    memset(&m_NuclearAttackValue, 0, sizeof(m_NuclearAttackValue));
    memset(&m_StealTechnologyValue, 0, sizeof(m_StealTechnologyValue));
    memset(&m_InciteRevolutionValue, 0, sizeof(m_InciteRevolutionValue));
    memset(&m_AssasinateRulerValue, 0, sizeof(m_AssasinateRulerValue));
    memset(&m_InvestigateReadinessValue, 0, sizeof(m_InvestigateReadinessValue));
    memset(&m_CreateFranchiseValue, 0, sizeof(m_CreateFranchiseValue));
    memset(&m_CauseUnhappinessValue, 0, sizeof(m_CauseUnhappinessValue));
    memset(&m_ConductHitsValue, 0, sizeof(m_ConductHitsValue));
    memset(&m_BioTerrorValue, 0, sizeof(m_BioTerrorValue));
    memset(&m_NanoTerrorValue, 0, sizeof(m_NanoTerrorValue));
    memset(&m_PlagueValue, 0, sizeof(m_PlagueValue));
    memset(&m_SlaveRaidsValue, 0, sizeof(m_SlaveRaidsValue));
    memset(&m_SettlerSlaveRaidsValue, 0, sizeof(m_SettlerSlaveRaidsValue));
    memset(&m_SlaveUprisingValue, 0, sizeof(m_SlaveUprisingValue));
    memset(&m_UndergroundRailwayValue, 0, sizeof(m_UndergroundRailwayValue));
    memset(&m_IndulgenceSalesValue, 0, sizeof(m_IndulgenceSalesValue));
    memset(&m_ConvertCitiesValue, 0, sizeof(m_ConvertCitiesValue));
    m_GovernmentType = NULL;
    m_numGovernmentType = 0;
    memset(&m_PlantNukeValue, 0, sizeof(m_PlantNukeValue));
    memset(&m_CanSoothsayValue, 0, sizeof(m_CanSoothsayValue));
    memset(&m_CreateParksValue, 0, sizeof(m_CreateParksValue));
    memset(&m_CanInjoinValue, 0, sizeof(m_CanInjoinValue));
    memset(&m_CanReformValue, 0, sizeof(m_CanReformValue));
    m_VisionClass = 0;
    m_CanSee = 0;
    m_CanAttack = 0;
    memset(&m_CargoDataValue, 0, sizeof(m_CargoDataValue));
    m_ShieldCost = 0;
    m_PowerPoints = 0;
    m_MaxHP = 0;
    m_MaxHPr = 1.000000;
    m_Attack = 0.000000;
    m_Defense = 0.000000;
    m_Firepower = 0;
    m_ZBRangeAttack = 0;
    m_Armor = 0.000000;
    m_BRangeValue = 0;
    m_BRadiusValue = 0;
    m_VisionRange = 0;
    m_ActiveDefenseRange = 0;
    m_ElectronicCombatFactorValue = 0;
    m_MaxMovePoints = 0.000000;
    m_MaxFuel = 0;
    m_TransTypeValue = 0;
    m_ProbOfBombHitValue = 0;
    m_BombRoundsValue = 0;
    m_ShieldHunger = 0;
    m_FoodHunger = 0;
    m_DefaultSprite = 0x7fffffff;
    m_LaunchPollutionValue = 0;
    m_DeathPollutionValue = 0;
    m_MountedBonusValue = 0.0;
    m_AirBonusValue = 0.0;
    m_WoodenShipBonusValue = 0.0;
    m_AttackCityBonusValue = 0.0;
    m_AttackBonusSubmarineValue = 0.0;
    m_CargoModuleValue = 0;
    m_SpyVsSpyValue = 0.0;
    memset(&m_InvestigateCityValue, 0, sizeof(m_InvestigateCityValue));
    m_BonusFoodValue = 0;
    m_BombardRangeValue = 0;
    memset(&m_RevolutionValue, 0, sizeof(m_RevolutionValue));
    m_SoundSelect1 = 0x7fffffff;
    m_SoundSelect2 = 0x7fffffff;
    m_SoundMove = 0x7fffffff;
    m_SoundAcknowledge = 0x7fffffff;
    m_SoundCantMove = 0x7fffffff;
    m_SoundAttack = 0x7fffffff;
    m_SoundWork = 0x7fffffff;
    m_SoundVictory = 0x7fffffff;
    m_SoundDeath = 0x7fffffff;
    m_SoundLoad = 0x7fffffff;
    m_SoundUnload = 0x7fffffff;
    memset(m_SpecialAttacks, 0, sizeof(m_SpecialAttacks));
    m_numSpecialAttacks = 0;
    m_CityGrowthCoefficientValue = 0.0;
    m_UserFlags = 0;
    m_DefaultIcon = 0x7fffffff;
    m_CheatIndexValue = 0;
    m_Description = 0;
    m_AdviceValue = 0;
    m_Category = 0;
}

UnitRecord::~UnitRecord()
{
	int index = 0;
	// free array SettleBuilding 
 	if (m_numSettleBuilding > 0) 
		delete [m_numSettleBuilding] m_SettleBuilding; 
	m_SettleBuilding = NULL; 
	m_numSettleBuilding = 0; 

	// free array GovernmentType 
 	if (m_numGovernmentType > 0) 
		delete [m_numGovernmentType] m_GovernmentType; 
	m_GovernmentType = NULL; 
	m_numGovernmentType = 0; 

}

void UnitRecord::operator=(const UnitRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_MovementType = rval.m_MovementType; 

	m_CanCarry = rval.m_CanCarry; 

	m_EnableAdvance = rval.m_EnableAdvance; 

	// copy fixed sized array ObsoleteAdvance[] 
 		memcpy(m_ObsoleteAdvance, rval.m_ObsoleteAdvance, sizeof(sint32)*rval.m_numObsoleteAdvance); 

	m_Size = rval.m_Size; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_CanBombard = rval.m_CanBombard; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_Settle = rval.m_Settle; 

	m_SettleCityType = rval.m_SettleCityType; 

	m_SettleSize = rval.m_SettleSize; 

	// free array SettleBuilding 
 	if (m_numSettleBuilding > 0) 
	{
		delete [m_numSettleBuilding] m_SettleBuilding; 
		m_SettleBuilding = NULL; 
		m_numSettleBuilding = 0; 
	}
	if (rval.m_numSettleBuilding > 0) 
	{
		m_SettleBuilding = new sint32 [rval.m_numSettleBuilding]; 
		memcpy(m_SettleBuilding, rval.m_SettleBuilding, sizeof(sint32)*rval.m_numSettleBuilding); 

	} 
	m_numSettleBuilding = rval.m_numSettleBuilding;

	m_flags0 = rval.m_flags0; 
		m_SpaceLaunchValue = rval.m_SpaceLaunchValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_Defend = rval.m_Defend; 

	m_flags0 = rval.m_flags0; 
		m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue; 

	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags0 = rval.m_flags0; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
		m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue; 

	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
		m_NuclearAttackValue = rval.m_NuclearAttackValue; 

	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
		m_StealTechnologyValue = rval.m_StealTechnologyValue; 

	m_flags1 = rval.m_flags1; 
		m_InciteRevolutionValue = rval.m_InciteRevolutionValue; 

	m_flags1 = rval.m_flags1; 
		m_AssasinateRulerValue = rval.m_AssasinateRulerValue; 

	m_flags1 = rval.m_flags1; 
		m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue; 

	m_flags1 = rval.m_flags1; 
	m_flags1 = rval.m_flags1; 
		m_CreateFranchiseValue = rval.m_CreateFranchiseValue; 

	m_flags1 = rval.m_flags1; 
		m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue; 

	m_flags1 = rval.m_flags1; 
		m_ConductHitsValue = rval.m_ConductHitsValue; 

	m_flags1 = rval.m_flags1; 
		m_BioTerrorValue = rval.m_BioTerrorValue; 

	m_flags1 = rval.m_flags1; 
		m_NanoTerrorValue = rval.m_NanoTerrorValue; 

	m_flags2 = rval.m_flags2; 
		m_PlagueValue = rval.m_PlagueValue; 

	m_flags2 = rval.m_flags2; 
		m_SlaveRaidsValue = rval.m_SlaveRaidsValue; 

	m_flags2 = rval.m_flags2; 
		m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue; 

	m_flags2 = rval.m_flags2; 
		m_SlaveUprisingValue = rval.m_SlaveUprisingValue; 

	m_flags2 = rval.m_flags2; 
		m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue; 

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
		m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue; 

	m_flags2 = rval.m_flags2; 
		m_ConvertCitiesValue = rval.m_ConvertCitiesValue; 

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	// free array GovernmentType 
 	if (m_numGovernmentType > 0) 
	{
		delete [m_numGovernmentType] m_GovernmentType; 
		m_GovernmentType = NULL; 
		m_numGovernmentType = 0; 
	}
	if (rval.m_numGovernmentType > 0) 
	{
		m_GovernmentType = new sint32 [rval.m_numGovernmentType]; 
		memcpy(m_GovernmentType, rval.m_GovernmentType, sizeof(sint32)*rval.m_numGovernmentType); 

	} 
	m_numGovernmentType = rval.m_numGovernmentType;

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
		m_PlantNukeValue = rval.m_PlantNukeValue; 

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
		m_CanSoothsayValue = rval.m_CanSoothsayValue; 

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
		m_CreateParksValue = rval.m_CreateParksValue; 

	m_flags2 = rval.m_flags2; 
		m_CanInjoinValue = rval.m_CanInjoinValue; 

	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags2 = rval.m_flags2; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
		m_CanReformValue = rval.m_CanReformValue; 

	m_flags3 = rval.m_flags3; 
	m_flags3 = rval.m_flags3; 
	m_VisionClass = rval.m_VisionClass; 

	m_CanSee = rval.m_CanSee; 

	m_CanAttack = rval.m_CanAttack; 

	m_flags3 = rval.m_flags3; 
		m_CargoDataValue = rval.m_CargoDataValue; 

	m_ShieldCost = rval.m_ShieldCost; 

	m_PowerPoints = rval.m_PowerPoints; 

	m_MaxHP = rval.m_MaxHP; 

	m_MaxHPr = rval.m_MaxHPr; 

	m_Attack = rval.m_Attack; 

	m_Defense = rval.m_Defense; 

	m_Firepower = rval.m_Firepower; 

	m_ZBRangeAttack = rval.m_ZBRangeAttack; 

	m_Armor = rval.m_Armor; 

	m_flags3 = rval.m_flags3; 
		m_BRangeValue = rval.m_BRangeValue; 

	m_flags3 = rval.m_flags3; 
		m_BRadiusValue = rval.m_BRadiusValue; 

	m_VisionRange = rval.m_VisionRange; 

	m_ActiveDefenseRange = rval.m_ActiveDefenseRange; 

	m_flags3 = rval.m_flags3; 
		m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue; 

	m_MaxMovePoints = rval.m_MaxMovePoints; 

	m_MaxFuel = rval.m_MaxFuel; 

	m_flags3 = rval.m_flags3; 
		m_TransTypeValue = rval.m_TransTypeValue; 

	m_flags3 = rval.m_flags3; 
		m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue; 

	m_flags3 = rval.m_flags3; 
		m_BombRoundsValue = rval.m_BombRoundsValue; 

	m_ShieldHunger = rval.m_ShieldHunger; 

	m_FoodHunger = rval.m_FoodHunger; 

	m_DefaultSprite = rval.m_DefaultSprite; 

	m_flags3 = rval.m_flags3; 
		m_LaunchPollutionValue = rval.m_LaunchPollutionValue; 

	m_flags3 = rval.m_flags3; 
		m_DeathPollutionValue = rval.m_DeathPollutionValue; 

	m_flags3 = rval.m_flags3; 
		m_MountedBonusValue = rval.m_MountedBonusValue; 

	m_flags3 = rval.m_flags3; 
		m_AirBonusValue = rval.m_AirBonusValue; 

	m_flags3 = rval.m_flags3; 
		m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue; 

	m_flags3 = rval.m_flags3; 
		m_AttackCityBonusValue = rval.m_AttackCityBonusValue; 

	m_flags3 = rval.m_flags3; 
		m_AttackBonusSubmarineValue = rval.m_AttackBonusSubmarineValue; 

	m_flags3 = rval.m_flags3; 
		m_CargoModuleValue = rval.m_CargoModuleValue; 

	m_flags3 = rval.m_flags3; 
		m_SpyVsSpyValue = rval.m_SpyVsSpyValue; 

	m_flags3 = rval.m_flags3; 
		m_InvestigateCityValue = rval.m_InvestigateCityValue; 

	m_flags3 = rval.m_flags3; 
		m_BonusFoodValue = rval.m_BonusFoodValue; 

	m_flags3 = rval.m_flags3; 
		m_BombardRangeValue = rval.m_BombardRangeValue; 

	m_flags3 = rval.m_flags3; 
		m_RevolutionValue = rval.m_RevolutionValue; 

	m_SoundSelect1 = rval.m_SoundSelect1; 

	m_SoundSelect2 = rval.m_SoundSelect2; 

	m_SoundMove = rval.m_SoundMove; 

	m_SoundAcknowledge = rval.m_SoundAcknowledge; 

	m_SoundCantMove = rval.m_SoundCantMove; 

	m_SoundAttack = rval.m_SoundAttack; 

	m_SoundWork = rval.m_SoundWork; 

	m_SoundVictory = rval.m_SoundVictory; 

	m_SoundDeath = rval.m_SoundDeath; 

	m_SoundLoad = rval.m_SoundLoad; 

	m_SoundUnload = rval.m_SoundUnload; 

	// copy fixed sized array SpecialAttacks[] 
 		memcpy(m_SpecialAttacks, rval.m_SpecialAttacks, sizeof(sint32)*rval.m_numSpecialAttacks); 

	m_flags4 = rval.m_flags4; 
		m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue; 

	m_UserFlags = rval.m_UserFlags; 

	m_DefaultIcon = rval.m_DefaultIcon; 

	m_flags4 = rval.m_flags4; 
	m_flags4 = rval.m_flags4; 
		m_CheatIndexValue = rval.m_CheatIndexValue; 

	m_Description = rval.m_Description; 

	m_flags4 = rval.m_flags4; 
		m_AdviceValue = rval.m_AdviceValue; 

	m_Category = rval.m_Category; 

	m_flags4 = rval.m_flags4; 
	m_flags4 = rval.m_flags4; 
	m_flags4 = rval.m_flags4; 
}

char *g_Unit_Tokens[] =
{
    "MovementType",
    "CanCarry",
    "EnableAdvance",
    "ObsoleteAdvance",
    "Size",
    "LossMoveToDmgNone",
    "LossMoveToDmgTwo",
    "NoFuelThenCrash",
    "TransformPartial",
    "IgnoreZOC",
    "NoZoc",
    "CanBombard",
    "CanCounterBombard",
    "CanLiftOff",
    "Settle",
    "SettleCityType",
    "SettleSize",
    "SettleBuilding",
    "SpaceLaunch",
    "SpaceLaunchValue",
    "SpaceLand",
    "CantCaptureCity",
    "HasPopAndCanBuild",
    "IsTrader",
    "ExertsMartialLaw",
    "CanEntrench",
    "CanPatrol",
    "NeedsNoSupport",
    "CanExpelPop",
    "IsFlanker",
    "CanBeachAssault",
    "Defend",
    "DefendAgainstSpies",
    "DefendAgainstSpiesValue",
    "CanBeExpelled",
    "CanBeSued",
    "AttackFromSpaceship",
    "CantBeAttacked",
    "CargoPod",
    "IsMounted",
    "IgnoreCityWalls",
    "IsSubmarine",
    "NoLandAttack",
    "NoSeaAttack",
    "NoAirAttack",
    "NoSpaceAttack",
    "NoUnderwaterAttack",
    "NoMountainAttack",
    "NoShallowWaterAttack",
    "Paratrooper",
    "AssistedDrops",
    "BonusAgainstMounted",
    "SingleUse",
    "BonusAirDefense",
    "WoodenShip",
    "AttackWoodenShipBonus",
    "HasAttackCityBonus",
    "HasAttackBonusSubmarine",
    "ReplaceWithCargoModule",
    "ReplaceWithCargoModuleValue",
    "VisibileAttacking",
    "NuclearAttack",
    "NuclearAttackValue",
    "CanSue",
    "IsStealthy",
    "SeeSurfaceFromSpace",
    "EstablishEmbassy",
    "ThrowParty",
    "HearGossip",
    "StealTechnology",
    "StealTechnologyValue",
    "InciteRevolution",
    "InciteRevolutionValue",
    "AssasinateRuler",
    "AssasinateRulerValue",
    "InvestigateReadiness",
    "InvestigateReadinessValue",
    "NullifyCityWalls",
    "CreateFranchise",
    "CreateFranchiseValue",
    "CauseUnhappiness",
    "CauseUnhappinessValue",
    "ConductHits",
    "ConductHitsValue",
    "BioTerror",
    "BioTerrorValue",
    "NanoTerror",
    "NanoTerrorValue",
    "Plague",
    "PlagueValue",
    "SlaveRaids",
    "SlaveRaidsValue",
    "SettlerSlaveRaids",
    "SettlerSlaveRaidsValue",
    "SlaveUprising",
    "SlaveUprisingValue",
    "UndergroundRailway",
    "UndergroundRailwayValue",
    "VictoryEnslavement",
    "DefuseLandMines",
    "DefuseSeaMines",
    "DefuseXrayMines",
    "IndulgenceSales",
    "IndulgenceSalesValue",
    "ConvertCities",
    "ConvertCitiesValue",
    "BuildXrayMines",
    "BuildWonder",
    "GovernmentType",
    "NoSlaves",
    "CreateRift",
    "CanCloak",
    "ParatrooperTransport",
    "CantBuild",
    "PlantNuke",
    "PlantNukeValue",
    "IsTelevangelist",
    "CanSoothsay",
    "CanSoothsayValue",
    "CanBeRustled",
    "CreateParks",
    "CreateParksValue",
    "CanInjoin",
    "CanInjoinValue",
    "WormholeProbe",
    "HasBonusFood",
    "LandCityCanBuild",
    "SeaCityCanBuild",
    "SpaceCityCanBuild",
    "IsSpecialForces",
    "NotAffectedByLandMines",
    "InternalReserved",
    "DeathEffectsHappy",
    "EnableCarrierDefenses",
    "ActiveDefenseOnlyWhenCarryingEnablers",
    "BuildingRemovesAPop",
    "Explodes",
    "Advertise",
    "CanRustle",
    "OnlyBuildOne",
    "CanExpel",
    "CanReform",
    "CanReformValue",
    "CanPillage",
    "CanPirate",
    "VisionClass",
    "CanSee",
    "CanAttack",
    "CargoData",
    "CargoDataValue",
    "ShieldCost",
    "PowerPoints",
    "MaxHP",
    "MaxHPr",
    "Attack",
    "Defense",
    "Firepower",
    "ZBRangeAttack",
    "Armor",
    "BRange",
    "BRangeValue",
    "BRadius",
    "BRadiusValue",
    "VisionRange",
    "ActiveDefenseRange",
    "ElectronicCombatFactor",
    "ElectronicCombatFactorValue",
    "MaxMovePoints",
    "MaxFuel",
    "TransType",
    "TransTypeValue",
    "ProbOfBombHit",
    "ProbOfBombHitValue",
    "BombRounds",
    "BombRoundsValue",
    "ShieldHunger",
    "FoodHunger",
    "DefaultSprite",
    "LaunchPollution",
    "LaunchPollutionValue",
    "DeathPollution",
    "DeathPollutionValue",
    "MountedBonus",
    "MountedBonusValue",
    "AirBonus",
    "AirBonusValue",
    "WoodenShipBonus",
    "WoodenShipBonusValue",
    "AttackCityBonus",
    "AttackCityBonusValue",
    "AttackBonusSubmarine",
    "AttackBonusSubmarineValue",
    "CargoModule",
    "CargoModuleValue",
    "SpyVsSpy",
    "SpyVsSpyValue",
    "InvestigateCity",
    "InvestigateCityValue",
    "BonusFood",
    "BonusFoodValue",
    "BombardRange",
    "BombardRangeValue",
    "Revolution",
    "RevolutionValue",
    "SoundSelect1",
    "SoundSelect2",
    "SoundMove",
    "SoundAcknowledge",
    "SoundCantMove",
    "SoundAttack",
    "SoundWork",
    "SoundVictory",
    "SoundDeath",
    "SoundLoad",
    "SoundUnload",
    "SpecialAttacks",
    "CityGrowthCoefficient",
    "CityGrowthCoefficientValue",
    "UserFlags",
    "DefaultIcon",
    "NoIndex",
    "CheatIndex",
    "CheatIndexValue",
    "Description",
    "Advice",
    "AdviceValue",
    "Category",
    "GLHidden",
    "CantMove",
    "Civilian",
};

UnitRecordAccessorInfo g_UnitRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* MovementType */
    { NULL, NULL, NULL, NULL, NULL}, /* CanCarry */
    {UnitRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ObsoleteAdvance (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* Size */
    { NULL, UnitRecord::GetLossMoveToDmgNone, NULL, NULL, NULL },
    { NULL, UnitRecord::GetLossMoveToDmgTwo, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoFuelThenCrash, NULL, NULL, NULL },
    { NULL, UnitRecord::GetTransformPartial, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIgnoreZOC, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoZoc, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CanBombard */
    { NULL, UnitRecord::GetCanCounterBombard, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanLiftOff, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Settle */
    {UnitRecord::GetSettleCityTypeIndex, NULL, NULL, NULL, NULL },
    { UnitRecord::GetSettleSize, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SettleBuilding (array) */
    { NULL, NULL, NULL, UnitRecord::GetSpaceLaunch, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SpaceLaunch */
    { NULL, UnitRecord::GetSpaceLand, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCantCaptureCity, NULL, NULL, NULL },
    { NULL, UnitRecord::GetHasPopAndCanBuild, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsTrader, NULL, NULL, NULL },
    { NULL, UnitRecord::GetExertsMartialLaw, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanEntrench, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanPatrol, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNeedsNoSupport, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanExpelPop, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsFlanker, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanBeachAssault, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Defend */
    { NULL, NULL, NULL, NULL, UnitRecord::GetDefendAgainstSpies},
    { NULL, NULL, NULL, NULL, NULL}, /* DefendAgainstSpies */
    { NULL, UnitRecord::GetCanBeExpelled, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanBeSued, NULL, NULL, NULL },
    { NULL, UnitRecord::GetAttackFromSpaceship, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCantBeAttacked, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCargoPod, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsMounted, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIgnoreCityWalls, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsSubmarine, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoLandAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoSeaAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoAirAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoSpaceAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoUnderwaterAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoMountainAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoShallowWaterAttack, NULL, NULL, NULL },
    { NULL, UnitRecord::GetParatrooper, NULL, NULL, NULL },
    { NULL, UnitRecord::GetAssistedDrops, NULL, NULL, NULL },
    { NULL, UnitRecord::GetBonusAgainstMounted, NULL, NULL, NULL },
    { NULL, UnitRecord::GetSingleUse, NULL, NULL, NULL },
    { NULL, UnitRecord::GetBonusAirDefense, NULL, NULL, NULL },
    { NULL, UnitRecord::GetWoodenShip, NULL, NULL, NULL },
    { NULL, UnitRecord::GetAttackWoodenShipBonus, NULL, NULL, NULL },
    { NULL, UnitRecord::GetHasAttackCityBonus, NULL, NULL, NULL },
    { NULL, UnitRecord::GetHasAttackBonusSubmarine, NULL, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetReplaceWithCargoModule, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ReplaceWithCargoModule */
    { NULL, UnitRecord::GetVisibileAttacking, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* NuclearAttack */
    { NULL, NULL, NULL, NULL, NULL}, /* NuclearAttack */
    { NULL, UnitRecord::GetCanSue, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsStealthy, NULL, NULL, NULL },
    { NULL, UnitRecord::GetSeeSurfaceFromSpace, NULL, NULL, NULL },
    { NULL, UnitRecord::GetEstablishEmbassy, NULL, NULL, NULL },
    { NULL, UnitRecord::GetThrowParty, NULL, NULL, NULL },
    { NULL, UnitRecord::GetHearGossip, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL}, /* StealTechnology */
    { NULL, NULL, NULL, NULL, NULL}, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL}, /* InciteRevolution */
    { NULL, NULL, NULL, NULL, NULL}, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL}, /* AssasinateRuler */
    { NULL, NULL, NULL, NULL, NULL}, /* InvestigateReadiness */
    { NULL, NULL, NULL, NULL, NULL}, /* InvestigateReadiness */
    { NULL, UnitRecord::GetNullifyCityWalls, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL}, /* CreateFranchise */
    { NULL, NULL, NULL, NULL, NULL}, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL}, /* CauseUnhappiness */
    { NULL, NULL, NULL, NULL, NULL}, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL}, /* ConductHits */
    { NULL, NULL, NULL, NULL, NULL}, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL}, /* BioTerror */
    { NULL, NULL, NULL, NULL, NULL}, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL}, /* NanoTerror */
    { NULL, NULL, NULL, NULL, NULL}, /* Plague */
    { NULL, NULL, NULL, NULL, NULL}, /* Plague */
    { NULL, NULL, NULL, NULL, NULL}, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL}, /* SlaveRaids */
    { NULL, NULL, NULL, NULL, NULL}, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL}, /* SettlerSlaveRaids */
    { NULL, NULL, NULL, NULL, NULL}, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL}, /* SlaveUprising */
    { NULL, NULL, NULL, NULL, NULL}, /* UndergroundRailway */
    { NULL, NULL, NULL, NULL, NULL}, /* UndergroundRailway */
    { NULL, UnitRecord::GetVictoryEnslavement, NULL, NULL, NULL },
    { NULL, UnitRecord::GetDefuseLandMines, NULL, NULL, NULL },
    { NULL, UnitRecord::GetDefuseSeaMines, NULL, NULL, NULL },
    { NULL, UnitRecord::GetDefuseXrayMines, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL}, /* IndulgenceSales */
    { NULL, NULL, NULL, NULL, NULL}, /* ConvertCities */
    { NULL, NULL, NULL, NULL, NULL}, /* ConvertCities */
    { NULL, UnitRecord::GetBuildXrayMines, NULL, NULL, NULL },
    { NULL, UnitRecord::GetBuildWonder, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* GovernmentType (array) */
    { NULL, UnitRecord::GetNoSlaves, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCreateRift, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanCloak, NULL, NULL, NULL },
    { NULL, UnitRecord::GetParatrooperTransport, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCantBuild, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PlantNuke */
    { NULL, NULL, NULL, NULL, NULL}, /* PlantNuke */
    { NULL, UnitRecord::GetIsTelevangelist, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CanSoothsay */
    { NULL, NULL, NULL, NULL, NULL}, /* CanSoothsay */
    { NULL, UnitRecord::GetCanBeRustled, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL}, /* CreateParks */
    { NULL, NULL, NULL, NULL, NULL}, /* CanInjoin */
    { NULL, NULL, NULL, NULL, NULL}, /* CanInjoin */
    { NULL, UnitRecord::GetWormholeProbe, NULL, NULL, NULL },
    { NULL, UnitRecord::GetHasBonusFood, NULL, NULL, NULL },
    { NULL, UnitRecord::GetLandCityCanBuild, NULL, NULL, NULL },
    { NULL, UnitRecord::GetSeaCityCanBuild, NULL, NULL, NULL },
    { NULL, UnitRecord::GetSpaceCityCanBuild, NULL, NULL, NULL },
    { NULL, UnitRecord::GetIsSpecialForces, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNotAffectedByLandMines, NULL, NULL, NULL },
    { NULL, UnitRecord::GetInternalReserved, NULL, NULL, NULL },
    { NULL, UnitRecord::GetDeathEffectsHappy, NULL, NULL, NULL },
    { NULL, UnitRecord::GetEnableCarrierDefenses, NULL, NULL, NULL },
    { NULL, UnitRecord::GetActiveDefenseOnlyWhenCarryingEnablers, NULL, NULL, NULL },
    { NULL, UnitRecord::GetBuildingRemovesAPop, NULL, NULL, NULL },
    { NULL, UnitRecord::GetExplodes, NULL, NULL, NULL },
    { NULL, UnitRecord::GetAdvertise, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanRustle, NULL, NULL, NULL },
    { NULL, UnitRecord::GetOnlyBuildOne, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanExpel, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CanReform */
    { NULL, NULL, NULL, NULL, NULL}, /* CanReform */
    { NULL, UnitRecord::GetCanPillage, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCanPirate, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* VisionClass */
    { NULL, NULL, NULL, NULL, NULL}, /* CanSee */
    { NULL, NULL, NULL, NULL, NULL}, /* CanAttack */
    { NULL, NULL, NULL, NULL, NULL}, /* CargoData */
    { NULL, NULL, NULL, NULL, NULL}, /* CargoData */
    { UnitRecord::GetShieldCost, NULL, NULL, NULL, NULL },
    { UnitRecord::GetPowerPoints, NULL, NULL, NULL, NULL },
    { UnitRecord::GetMaxHP, NULL, NULL, NULL, NULL },
    { NULL, NULL, UnitRecord::GetMaxHPr, NULL, NULL },
    { NULL, NULL, UnitRecord::GetAttack, NULL, NULL },
    { NULL, NULL, UnitRecord::GetDefense, NULL, NULL },
    { UnitRecord::GetFirepower, NULL, NULL, NULL, NULL },
    { UnitRecord::GetZBRangeAttack, NULL, NULL, NULL, NULL },
    { NULL, NULL, UnitRecord::GetArmor, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetBRange, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BRange */
    { NULL, NULL, NULL, UnitRecord::GetBRadius, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BRadius */
    { UnitRecord::GetVisionRange, NULL, NULL, NULL, NULL },
    { UnitRecord::GetActiveDefenseRange, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetElectronicCombatFactor, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ElectronicCombatFactor */
    { NULL, NULL, UnitRecord::GetMaxMovePoints, NULL, NULL },
    { UnitRecord::GetMaxFuel, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetTransType, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* TransType */
    { NULL, NULL, NULL, UnitRecord::GetProbOfBombHit, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ProbOfBombHit */
    { NULL, NULL, NULL, UnitRecord::GetBombRounds, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BombRounds */
    { UnitRecord::GetShieldHunger, NULL, NULL, NULL, NULL },
    { UnitRecord::GetFoodHunger, NULL, NULL, NULL, NULL },
    {UnitRecord::GetDefaultSpriteIndex, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetLaunchPollution, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* LaunchPollution */
    { NULL, NULL, NULL, UnitRecord::GetDeathPollution, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* DeathPollution */
    { NULL, NULL, NULL, NULL, UnitRecord::GetMountedBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* MountedBonus */
    { NULL, NULL, NULL, NULL, UnitRecord::GetAirBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* AirBonus */
    { NULL, NULL, NULL, NULL, UnitRecord::GetWoodenShipBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* WoodenShipBonus */
    { NULL, NULL, NULL, NULL, UnitRecord::GetAttackCityBonus},
    { NULL, NULL, NULL, NULL, NULL}, /* AttackCityBonus */
    { NULL, NULL, NULL, NULL, UnitRecord::GetAttackBonusSubmarine},
    { NULL, NULL, NULL, NULL, NULL}, /* AttackBonusSubmarine */
    { NULL, NULL, NULL, UnitRecord::GetCargoModule, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CargoModule */
    { NULL, NULL, NULL, NULL, UnitRecord::GetSpyVsSpy},
    { NULL, NULL, NULL, NULL, NULL}, /* SpyVsSpy */
    { NULL, NULL, NULL, NULL, NULL}, /* InvestigateCity */
    { NULL, NULL, NULL, NULL, NULL}, /* InvestigateCity */
    { NULL, NULL, NULL, UnitRecord::GetBonusFood, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BonusFood */
    { NULL, NULL, NULL, UnitRecord::GetBombardRange, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BombardRange */
    { NULL, NULL, NULL, NULL, NULL}, /* Revolution */
    { NULL, NULL, NULL, NULL, NULL}, /* Revolution */
    {UnitRecord::GetSoundSelect1Index, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundSelect2Index, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundMoveIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundAcknowledgeIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundCantMoveIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundAttackIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundWorkIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundVictoryIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundDeathIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundLoadIndex, NULL, NULL, NULL, NULL },
    {UnitRecord::GetSoundUnloadIndex, NULL, NULL, NULL, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SpecialAttacks (array) */
    { NULL, NULL, NULL, NULL, UnitRecord::GetCityGrowthCoefficient},
    { NULL, NULL, NULL, NULL, NULL}, /* CityGrowthCoefficient */
    { NULL, NULL, NULL, NULL, NULL}, /* UserFlags */
    {UnitRecord::GetDefaultIconIndex, NULL, NULL, NULL, NULL },
    { NULL, UnitRecord::GetNoIndex, NULL, NULL, NULL },
    { NULL, NULL, NULL, UnitRecord::GetCheatIndex, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CheatIndex */
    { NULL, NULL, NULL, NULL, NULL}, /* Description */
    { NULL, NULL, NULL, NULL, NULL}, /* Advice */
    { NULL, NULL, NULL, NULL, NULL}, /* Advice */
    { NULL, NULL, NULL, NULL, NULL}, /* Category */
    { NULL, UnitRecord::GetGLHidden, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCantMove, NULL, NULL, NULL },
    { NULL, UnitRecord::GetCivilian, NULL, NULL, NULL },
};

#define k_Token_Unit_MovementType                ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CanCarry                    ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_EnableAdvance               ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_ObsoleteAdvance             ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_Size                        ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_LossMoveToDmgNone           ((k_Token_Custom_Base) + 5)
#define k_Token_Unit_LossMoveToDmgTwo            ((k_Token_Custom_Base) + 6)
#define k_Token_Unit_NoFuelThenCrash             ((k_Token_Custom_Base) + 7)
#define k_Token_Unit_TransformPartial            ((k_Token_Custom_Base) + 8)
#define k_Token_Unit_IgnoreZOC                   ((k_Token_Custom_Base) + 9)
#define k_Token_Unit_NoZoc                       ((k_Token_Custom_Base) + 10)
#define k_Token_Unit_CanBombard                  ((k_Token_Custom_Base) + 11)
#define k_Token_Unit_CanCounterBombard           ((k_Token_Custom_Base) + 12)
#define k_Token_Unit_CanLiftOff                  ((k_Token_Custom_Base) + 13)
#define k_Token_Unit_Settle                      ((k_Token_Custom_Base) + 14)
#define k_Token_Unit_SettleCityType              ((k_Token_Custom_Base) + 15)
#define k_Token_Unit_SettleSize                  ((k_Token_Custom_Base) + 16)
#define k_Token_Unit_SettleBuilding              ((k_Token_Custom_Base) + 17)
#define k_Token_Unit_SpaceLaunch                 ((k_Token_Custom_Base) + 18)
#define k_Token_Unit_SpaceLaunch_Value           ((k_Token_Custom_Base) + 19)
#define k_Token_Unit_SpaceLand                   ((k_Token_Custom_Base) + 20)
#define k_Token_Unit_CantCaptureCity             ((k_Token_Custom_Base) + 21)
#define k_Token_Unit_HasPopAndCanBuild           ((k_Token_Custom_Base) + 22)
#define k_Token_Unit_IsTrader                    ((k_Token_Custom_Base) + 23)
#define k_Token_Unit_ExertsMartialLaw            ((k_Token_Custom_Base) + 24)
#define k_Token_Unit_CanEntrench                 ((k_Token_Custom_Base) + 25)
#define k_Token_Unit_CanPatrol                   ((k_Token_Custom_Base) + 26)
#define k_Token_Unit_NeedsNoSupport              ((k_Token_Custom_Base) + 27)
#define k_Token_Unit_CanExpelPop                 ((k_Token_Custom_Base) + 28)
#define k_Token_Unit_IsFlanker                   ((k_Token_Custom_Base) + 29)
#define k_Token_Unit_CanBeachAssault             ((k_Token_Custom_Base) + 30)
#define k_Token_Unit_Defend                      ((k_Token_Custom_Base) + 31)
#define k_Token_Unit_DefendAgainstSpies          ((k_Token_Custom_Base) + 32)
#define k_Token_Unit_DefendAgainstSpies_Value    ((k_Token_Custom_Base) + 33)
#define k_Token_Unit_CanBeExpelled               ((k_Token_Custom_Base) + 34)
#define k_Token_Unit_CanBeSued                   ((k_Token_Custom_Base) + 35)
#define k_Token_Unit_AttackFromSpaceship         ((k_Token_Custom_Base) + 36)
#define k_Token_Unit_CantBeAttacked              ((k_Token_Custom_Base) + 37)
#define k_Token_Unit_CargoPod                    ((k_Token_Custom_Base) + 38)
#define k_Token_Unit_IsMounted                   ((k_Token_Custom_Base) + 39)
#define k_Token_Unit_IgnoreCityWalls             ((k_Token_Custom_Base) + 40)
#define k_Token_Unit_IsSubmarine                 ((k_Token_Custom_Base) + 41)
#define k_Token_Unit_NoLandAttack                ((k_Token_Custom_Base) + 42)
#define k_Token_Unit_NoSeaAttack                 ((k_Token_Custom_Base) + 43)
#define k_Token_Unit_NoAirAttack                 ((k_Token_Custom_Base) + 44)
#define k_Token_Unit_NoSpaceAttack               ((k_Token_Custom_Base) + 45)
#define k_Token_Unit_NoUnderwaterAttack          ((k_Token_Custom_Base) + 46)
#define k_Token_Unit_NoMountainAttack            ((k_Token_Custom_Base) + 47)
#define k_Token_Unit_NoShallowWaterAttack        ((k_Token_Custom_Base) + 48)
#define k_Token_Unit_Paratrooper                 ((k_Token_Custom_Base) + 49)
#define k_Token_Unit_AssistedDrops               ((k_Token_Custom_Base) + 50)
#define k_Token_Unit_BonusAgainstMounted         ((k_Token_Custom_Base) + 51)
#define k_Token_Unit_SingleUse                   ((k_Token_Custom_Base) + 52)
#define k_Token_Unit_BonusAirDefense             ((k_Token_Custom_Base) + 53)
#define k_Token_Unit_WoodenShip                  ((k_Token_Custom_Base) + 54)
#define k_Token_Unit_AttackWoodenShipBonus       ((k_Token_Custom_Base) + 55)
#define k_Token_Unit_HasAttackCityBonus          ((k_Token_Custom_Base) + 56)
#define k_Token_Unit_HasAttackBonusSubmarine     ((k_Token_Custom_Base) + 57)
#define k_Token_Unit_ReplaceWithCargoModule      ((k_Token_Custom_Base) + 58)
#define k_Token_Unit_ReplaceWithCargoModule_Value ((k_Token_Custom_Base) + 59)
#define k_Token_Unit_VisibileAttacking           ((k_Token_Custom_Base) + 60)
#define k_Token_Unit_NuclearAttack               ((k_Token_Custom_Base) + 61)
#define k_Token_Unit_NuclearAttack_Value         ((k_Token_Custom_Base) + 62)
#define k_Token_Unit_CanSue                      ((k_Token_Custom_Base) + 63)
#define k_Token_Unit_IsStealthy                  ((k_Token_Custom_Base) + 64)
#define k_Token_Unit_SeeSurfaceFromSpace         ((k_Token_Custom_Base) + 65)
#define k_Token_Unit_EstablishEmbassy            ((k_Token_Custom_Base) + 66)
#define k_Token_Unit_ThrowParty                  ((k_Token_Custom_Base) + 67)
#define k_Token_Unit_HearGossip                  ((k_Token_Custom_Base) + 68)
#define k_Token_Unit_StealTechnology             ((k_Token_Custom_Base) + 69)
#define k_Token_Unit_StealTechnology_Value       ((k_Token_Custom_Base) + 70)
#define k_Token_Unit_InciteRevolution            ((k_Token_Custom_Base) + 71)
#define k_Token_Unit_InciteRevolution_Value      ((k_Token_Custom_Base) + 72)
#define k_Token_Unit_AssasinateRuler             ((k_Token_Custom_Base) + 73)
#define k_Token_Unit_AssasinateRuler_Value       ((k_Token_Custom_Base) + 74)
#define k_Token_Unit_InvestigateReadiness        ((k_Token_Custom_Base) + 75)
#define k_Token_Unit_InvestigateReadiness_Value  ((k_Token_Custom_Base) + 76)
#define k_Token_Unit_NullifyCityWalls            ((k_Token_Custom_Base) + 77)
#define k_Token_Unit_CreateFranchise             ((k_Token_Custom_Base) + 78)
#define k_Token_Unit_CreateFranchise_Value       ((k_Token_Custom_Base) + 79)
#define k_Token_Unit_CauseUnhappiness            ((k_Token_Custom_Base) + 80)
#define k_Token_Unit_CauseUnhappiness_Value      ((k_Token_Custom_Base) + 81)
#define k_Token_Unit_ConductHits                 ((k_Token_Custom_Base) + 82)
#define k_Token_Unit_ConductHits_Value           ((k_Token_Custom_Base) + 83)
#define k_Token_Unit_BioTerror                   ((k_Token_Custom_Base) + 84)
#define k_Token_Unit_BioTerror_Value             ((k_Token_Custom_Base) + 85)
#define k_Token_Unit_NanoTerror                  ((k_Token_Custom_Base) + 86)
#define k_Token_Unit_NanoTerror_Value            ((k_Token_Custom_Base) + 87)
#define k_Token_Unit_Plague                      ((k_Token_Custom_Base) + 88)
#define k_Token_Unit_Plague_Value                ((k_Token_Custom_Base) + 89)
#define k_Token_Unit_SlaveRaids                  ((k_Token_Custom_Base) + 90)
#define k_Token_Unit_SlaveRaids_Value            ((k_Token_Custom_Base) + 91)
#define k_Token_Unit_SettlerSlaveRaids           ((k_Token_Custom_Base) + 92)
#define k_Token_Unit_SettlerSlaveRaids_Value     ((k_Token_Custom_Base) + 93)
#define k_Token_Unit_SlaveUprising               ((k_Token_Custom_Base) + 94)
#define k_Token_Unit_SlaveUprising_Value         ((k_Token_Custom_Base) + 95)
#define k_Token_Unit_UndergroundRailway          ((k_Token_Custom_Base) + 96)
#define k_Token_Unit_UndergroundRailway_Value    ((k_Token_Custom_Base) + 97)
#define k_Token_Unit_VictoryEnslavement          ((k_Token_Custom_Base) + 98)
#define k_Token_Unit_DefuseLandMines             ((k_Token_Custom_Base) + 99)
#define k_Token_Unit_DefuseSeaMines              ((k_Token_Custom_Base) + 100)
#define k_Token_Unit_DefuseXrayMines             ((k_Token_Custom_Base) + 101)
#define k_Token_Unit_IndulgenceSales             ((k_Token_Custom_Base) + 102)
#define k_Token_Unit_IndulgenceSales_Value       ((k_Token_Custom_Base) + 103)
#define k_Token_Unit_ConvertCities               ((k_Token_Custom_Base) + 104)
#define k_Token_Unit_ConvertCities_Value         ((k_Token_Custom_Base) + 105)
#define k_Token_Unit_BuildXrayMines              ((k_Token_Custom_Base) + 106)
#define k_Token_Unit_BuildWonder                 ((k_Token_Custom_Base) + 107)
#define k_Token_Unit_GovernmentType              ((k_Token_Custom_Base) + 108)
#define k_Token_Unit_NoSlaves                    ((k_Token_Custom_Base) + 109)
#define k_Token_Unit_CreateRift                  ((k_Token_Custom_Base) + 110)
#define k_Token_Unit_CanCloak                    ((k_Token_Custom_Base) + 111)
#define k_Token_Unit_ParatrooperTransport        ((k_Token_Custom_Base) + 112)
#define k_Token_Unit_CantBuild                   ((k_Token_Custom_Base) + 113)
#define k_Token_Unit_PlantNuke                   ((k_Token_Custom_Base) + 114)
#define k_Token_Unit_PlantNuke_Value             ((k_Token_Custom_Base) + 115)
#define k_Token_Unit_IsTelevangelist             ((k_Token_Custom_Base) + 116)
#define k_Token_Unit_CanSoothsay                 ((k_Token_Custom_Base) + 117)
#define k_Token_Unit_CanSoothsay_Value           ((k_Token_Custom_Base) + 118)
#define k_Token_Unit_CanBeRustled                ((k_Token_Custom_Base) + 119)
#define k_Token_Unit_CreateParks                 ((k_Token_Custom_Base) + 120)
#define k_Token_Unit_CreateParks_Value           ((k_Token_Custom_Base) + 121)
#define k_Token_Unit_CanInjoin                   ((k_Token_Custom_Base) + 122)
#define k_Token_Unit_CanInjoin_Value             ((k_Token_Custom_Base) + 123)
#define k_Token_Unit_WormholeProbe               ((k_Token_Custom_Base) + 124)
#define k_Token_Unit_HasBonusFood                ((k_Token_Custom_Base) + 125)
#define k_Token_Unit_LandCityCanBuild            ((k_Token_Custom_Base) + 126)
#define k_Token_Unit_SeaCityCanBuild             ((k_Token_Custom_Base) + 127)
#define k_Token_Unit_SpaceCityCanBuild           ((k_Token_Custom_Base) + 128)
#define k_Token_Unit_IsSpecialForces             ((k_Token_Custom_Base) + 129)
#define k_Token_Unit_NotAffectedByLandMines      ((k_Token_Custom_Base) + 130)
#define k_Token_Unit_InternalReserved            ((k_Token_Custom_Base) + 131)
#define k_Token_Unit_DeathEffectsHappy           ((k_Token_Custom_Base) + 132)
#define k_Token_Unit_EnableCarrierDefenses       ((k_Token_Custom_Base) + 133)
#define k_Token_Unit_ActiveDefenseOnlyWhenCarryingEnablers ((k_Token_Custom_Base) + 134)
#define k_Token_Unit_BuildingRemovesAPop         ((k_Token_Custom_Base) + 135)
#define k_Token_Unit_Explodes                    ((k_Token_Custom_Base) + 136)
#define k_Token_Unit_Advertise                   ((k_Token_Custom_Base) + 137)
#define k_Token_Unit_CanRustle                   ((k_Token_Custom_Base) + 138)
#define k_Token_Unit_OnlyBuildOne                ((k_Token_Custom_Base) + 139)
#define k_Token_Unit_CanExpel                    ((k_Token_Custom_Base) + 140)
#define k_Token_Unit_CanReform                   ((k_Token_Custom_Base) + 141)
#define k_Token_Unit_CanReform_Value             ((k_Token_Custom_Base) + 142)
#define k_Token_Unit_CanPillage                  ((k_Token_Custom_Base) + 143)
#define k_Token_Unit_CanPirate                   ((k_Token_Custom_Base) + 144)
#define k_Token_Unit_VisionClass                 ((k_Token_Custom_Base) + 145)
#define k_Token_Unit_CanSee                      ((k_Token_Custom_Base) + 146)
#define k_Token_Unit_CanAttack                   ((k_Token_Custom_Base) + 147)
#define k_Token_Unit_CargoData                   ((k_Token_Custom_Base) + 148)
#define k_Token_Unit_CargoData_Value             ((k_Token_Custom_Base) + 149)
#define k_Token_Unit_ShieldCost                  ((k_Token_Custom_Base) + 150)
#define k_Token_Unit_PowerPoints                 ((k_Token_Custom_Base) + 151)
#define k_Token_Unit_MaxHP                       ((k_Token_Custom_Base) + 152)
#define k_Token_Unit_MaxHPr                      ((k_Token_Custom_Base) + 153)
#define k_Token_Unit_Attack                      ((k_Token_Custom_Base) + 154)
#define k_Token_Unit_Defense                     ((k_Token_Custom_Base) + 155)
#define k_Token_Unit_Firepower                   ((k_Token_Custom_Base) + 156)
#define k_Token_Unit_ZBRangeAttack               ((k_Token_Custom_Base) + 157)
#define k_Token_Unit_Armor                       ((k_Token_Custom_Base) + 158)
#define k_Token_Unit_BRange                      ((k_Token_Custom_Base) + 159)
#define k_Token_Unit_BRange_Value                ((k_Token_Custom_Base) + 160)
#define k_Token_Unit_BRadius                     ((k_Token_Custom_Base) + 161)
#define k_Token_Unit_BRadius_Value               ((k_Token_Custom_Base) + 162)
#define k_Token_Unit_VisionRange                 ((k_Token_Custom_Base) + 163)
#define k_Token_Unit_ActiveDefenseRange          ((k_Token_Custom_Base) + 164)
#define k_Token_Unit_ElectronicCombatFactor      ((k_Token_Custom_Base) + 165)
#define k_Token_Unit_ElectronicCombatFactor_Value ((k_Token_Custom_Base) + 166)
#define k_Token_Unit_MaxMovePoints               ((k_Token_Custom_Base) + 167)
#define k_Token_Unit_MaxFuel                     ((k_Token_Custom_Base) + 168)
#define k_Token_Unit_TransType                   ((k_Token_Custom_Base) + 169)
#define k_Token_Unit_TransType_Value             ((k_Token_Custom_Base) + 170)
#define k_Token_Unit_ProbOfBombHit               ((k_Token_Custom_Base) + 171)
#define k_Token_Unit_ProbOfBombHit_Value         ((k_Token_Custom_Base) + 172)
#define k_Token_Unit_BombRounds                  ((k_Token_Custom_Base) + 173)
#define k_Token_Unit_BombRounds_Value            ((k_Token_Custom_Base) + 174)
#define k_Token_Unit_ShieldHunger                ((k_Token_Custom_Base) + 175)
#define k_Token_Unit_FoodHunger                  ((k_Token_Custom_Base) + 176)
#define k_Token_Unit_DefaultSprite               ((k_Token_Custom_Base) + 177)
#define k_Token_Unit_LaunchPollution             ((k_Token_Custom_Base) + 178)
#define k_Token_Unit_LaunchPollution_Value       ((k_Token_Custom_Base) + 179)
#define k_Token_Unit_DeathPollution              ((k_Token_Custom_Base) + 180)
#define k_Token_Unit_DeathPollution_Value        ((k_Token_Custom_Base) + 181)
#define k_Token_Unit_MountedBonus                ((k_Token_Custom_Base) + 182)
#define k_Token_Unit_MountedBonus_Value          ((k_Token_Custom_Base) + 183)
#define k_Token_Unit_AirBonus                    ((k_Token_Custom_Base) + 184)
#define k_Token_Unit_AirBonus_Value              ((k_Token_Custom_Base) + 185)
#define k_Token_Unit_WoodenShipBonus             ((k_Token_Custom_Base) + 186)
#define k_Token_Unit_WoodenShipBonus_Value       ((k_Token_Custom_Base) + 187)
#define k_Token_Unit_AttackCityBonus             ((k_Token_Custom_Base) + 188)
#define k_Token_Unit_AttackCityBonus_Value       ((k_Token_Custom_Base) + 189)
#define k_Token_Unit_AttackBonusSubmarine        ((k_Token_Custom_Base) + 190)
#define k_Token_Unit_AttackBonusSubmarine_Value  ((k_Token_Custom_Base) + 191)
#define k_Token_Unit_CargoModule                 ((k_Token_Custom_Base) + 192)
#define k_Token_Unit_CargoModule_Value           ((k_Token_Custom_Base) + 193)
#define k_Token_Unit_SpyVsSpy                    ((k_Token_Custom_Base) + 194)
#define k_Token_Unit_SpyVsSpy_Value              ((k_Token_Custom_Base) + 195)
#define k_Token_Unit_InvestigateCity             ((k_Token_Custom_Base) + 196)
#define k_Token_Unit_InvestigateCity_Value       ((k_Token_Custom_Base) + 197)
#define k_Token_Unit_BonusFood                   ((k_Token_Custom_Base) + 198)
#define k_Token_Unit_BonusFood_Value             ((k_Token_Custom_Base) + 199)
#define k_Token_Unit_BombardRange                ((k_Token_Custom_Base) + 200)
#define k_Token_Unit_BombardRange_Value          ((k_Token_Custom_Base) + 201)
#define k_Token_Unit_Revolution                  ((k_Token_Custom_Base) + 202)
#define k_Token_Unit_Revolution_Value            ((k_Token_Custom_Base) + 203)
#define k_Token_Unit_SoundSelect1                ((k_Token_Custom_Base) + 204)
#define k_Token_Unit_SoundSelect2                ((k_Token_Custom_Base) + 205)
#define k_Token_Unit_SoundMove                   ((k_Token_Custom_Base) + 206)
#define k_Token_Unit_SoundAcknowledge            ((k_Token_Custom_Base) + 207)
#define k_Token_Unit_SoundCantMove               ((k_Token_Custom_Base) + 208)
#define k_Token_Unit_SoundAttack                 ((k_Token_Custom_Base) + 209)
#define k_Token_Unit_SoundWork                   ((k_Token_Custom_Base) + 210)
#define k_Token_Unit_SoundVictory                ((k_Token_Custom_Base) + 211)
#define k_Token_Unit_SoundDeath                  ((k_Token_Custom_Base) + 212)
#define k_Token_Unit_SoundLoad                   ((k_Token_Custom_Base) + 213)
#define k_Token_Unit_SoundUnload                 ((k_Token_Custom_Base) + 214)
#define k_Token_Unit_SpecialAttacks              ((k_Token_Custom_Base) + 215)
#define k_Token_Unit_CityGrowthCoefficient       ((k_Token_Custom_Base) + 216)
#define k_Token_Unit_CityGrowthCoefficient_Value ((k_Token_Custom_Base) + 217)
#define k_Token_Unit_UserFlags                   ((k_Token_Custom_Base) + 218)
#define k_Token_Unit_DefaultIcon                 ((k_Token_Custom_Base) + 219)
#define k_Token_Unit_NoIndex                     ((k_Token_Custom_Base) + 220)
#define k_Token_Unit_CheatIndex                  ((k_Token_Custom_Base) + 221)
#define k_Token_Unit_CheatIndex_Value            ((k_Token_Custom_Base) + 222)
#define k_Token_Unit_Description                 ((k_Token_Custom_Base) + 223)
#define k_Token_Unit_Advice                      ((k_Token_Custom_Base) + 224)
#define k_Token_Unit_Advice_Value                ((k_Token_Custom_Base) + 225)
#define k_Token_Unit_Category                    ((k_Token_Custom_Base) + 226)
#define k_Token_Unit_GLHidden                    ((k_Token_Custom_Base) + 227)
#define k_Token_Unit_CantMove                    ((k_Token_Custom_Base) + 228)
#define k_Token_Unit_Civilian                    ((k_Token_Custom_Base) + 229)
#define k_Token_Unit_Max                         ((k_Token_Custom_Base) + 230)


static BitArray s_ParsedTokens(230);
void UnitRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Unit_ShieldCost - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldCost missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_PowerPoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field PowerPoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxHP - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxHP missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Attack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Attack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Defense - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Defense missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Firepower - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Firepower missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ZBRangeAttack - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ZBRangeAttack missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Armor - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Armor missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_VisionRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field VisionRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ActiveDefenseRange - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ActiveDefenseRange missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxMovePoints - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxMovePoints missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_MaxFuel - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field MaxFuel missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_ShieldHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field ShieldHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_FoodHunger - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field FoodHunger missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Description - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Description missing"));
    }
    if(!s_ParsedTokens.Bit(k_Token_Unit_Category - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Category missing"));
    }
}
    
sint32 UnitRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Unit_Tokens, k_Token_Unit_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Unit_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Unit_MovementType:
                if(!ParseMovementTypeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanCarry:
                if(!ParseCanCarryBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_EnableAdvance:
                if(!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ObsoleteAdvance:
                if(!g_theAdvanceDB->ParseRecordInArray(lex, (sint32 *)m_ObsoleteAdvance, &m_numObsoleteAdvance, k_MAX_ObsoleteAdvance, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_Size:
                if(!ParseSizeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_LossMoveToDmgNone:
                m_flags0 |= k_Unit_LossMoveToDmgNone_Bit;
                break;
            case k_Token_Unit_LossMoveToDmgTwo:
                m_flags0 |= k_Unit_LossMoveToDmgTwo_Bit;
                break;
            case k_Token_Unit_NoFuelThenCrash:
                m_flags0 |= k_Unit_NoFuelThenCrash_Bit;
                break;
            case k_Token_Unit_TransformPartial:
                m_flags0 |= k_Unit_TransformPartial_Bit;
                break;
            case k_Token_Unit_IgnoreZOC:
                m_flags0 |= k_Unit_IgnoreZOC_Bit;
                break;
            case k_Token_Unit_NoZoc:
                m_flags0 |= k_Unit_NoZoc_Bit;
                break;
            case k_Token_Unit_CanBombard:
                if(!ParseCanBombardBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanCounterBombard:
                m_flags0 |= k_Unit_CanCounterBombard_Bit;
                break;
            case k_Token_Unit_CanLiftOff:
                m_flags0 |= k_Unit_CanLiftOff_Bit;
                break;
            case k_Token_Unit_Settle:
                if(!ParseSettleBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleCityType:
                if(!g_theUnitDB->GetRecordFromLexer(lex, m_SettleCityType, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleSize:
                if(!lex->GetIntAssignment(m_SettleSize)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettleBuilding:
                if(!g_theBuildingDB->ParseRecordInArray(lex, (sint32 **)&m_SettleBuilding, &m_numSettleBuilding, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpaceLaunch:
                m_flags0 |= k_Unit_SpaceLaunch_Bit;
                if(!lex->GetIntAssignment(m_SpaceLaunchValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpaceLand:
                m_flags0 |= k_Unit_SpaceLand_Bit;
                break;
            case k_Token_Unit_CantCaptureCity:
                m_flags0 |= k_Unit_CantCaptureCity_Bit;
                break;
            case k_Token_Unit_HasPopAndCanBuild:
                m_flags0 |= k_Unit_HasPopAndCanBuild_Bit;
                break;
            case k_Token_Unit_IsTrader:
                m_flags0 |= k_Unit_IsTrader_Bit;
                break;
            case k_Token_Unit_ExertsMartialLaw:
                m_flags0 |= k_Unit_ExertsMartialLaw_Bit;
                break;
            case k_Token_Unit_CanEntrench:
                m_flags0 |= k_Unit_CanEntrench_Bit;
                break;
            case k_Token_Unit_CanPatrol:
                m_flags0 |= k_Unit_CanPatrol_Bit;
                break;
            case k_Token_Unit_NeedsNoSupport:
                m_flags0 |= k_Unit_NeedsNoSupport_Bit;
                break;
            case k_Token_Unit_CanExpelPop:
                m_flags0 |= k_Unit_CanExpelPop_Bit;
                break;
            case k_Token_Unit_IsFlanker:
                m_flags0 |= k_Unit_IsFlanker_Bit;
                break;
            case k_Token_Unit_CanBeachAssault:
                m_flags0 |= k_Unit_CanBeachAssault_Bit;
                break;
            case k_Token_Unit_Defend:
                if(!ParseDefendBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefendAgainstSpies:
                m_flags0 |= k_Unit_DefendAgainstSpies_Bit;
                if(!lex->GetFloatAssignment(m_DefendAgainstSpiesValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanBeExpelled:
                m_flags0 |= k_Unit_CanBeExpelled_Bit;
                break;
            case k_Token_Unit_CanBeSued:
                m_flags0 |= k_Unit_CanBeSued_Bit;
                break;
            case k_Token_Unit_AttackFromSpaceship:
                m_flags0 |= k_Unit_AttackFromSpaceship_Bit;
                break;
            case k_Token_Unit_CantBeAttacked:
                m_flags0 |= k_Unit_CantBeAttacked_Bit;
                break;
            case k_Token_Unit_CargoPod:
                m_flags0 |= k_Unit_CargoPod_Bit;
                break;
            case k_Token_Unit_IsMounted:
                m_flags0 |= k_Unit_IsMounted_Bit;
                break;
            case k_Token_Unit_IgnoreCityWalls:
                m_flags0 |= k_Unit_IgnoreCityWalls_Bit;
                break;
            case k_Token_Unit_IsSubmarine:
                m_flags0 |= k_Unit_IsSubmarine_Bit;
                break;
            case k_Token_Unit_NoLandAttack:
                m_flags0 |= k_Unit_NoLandAttack_Bit;
                break;
            case k_Token_Unit_NoSeaAttack:
                m_flags0 |= k_Unit_NoSeaAttack_Bit;
                break;
            case k_Token_Unit_NoAirAttack:
                m_flags0 |= k_Unit_NoAirAttack_Bit;
                break;
            case k_Token_Unit_NoSpaceAttack:
                m_flags1 |= k_Unit_NoSpaceAttack_Bit;
                break;
            case k_Token_Unit_NoUnderwaterAttack:
                m_flags1 |= k_Unit_NoUnderwaterAttack_Bit;
                break;
            case k_Token_Unit_NoMountainAttack:
                m_flags1 |= k_Unit_NoMountainAttack_Bit;
                break;
            case k_Token_Unit_NoShallowWaterAttack:
                m_flags1 |= k_Unit_NoShallowWaterAttack_Bit;
                break;
            case k_Token_Unit_Paratrooper:
                m_flags1 |= k_Unit_Paratrooper_Bit;
                break;
            case k_Token_Unit_AssistedDrops:
                m_flags1 |= k_Unit_AssistedDrops_Bit;
                break;
            case k_Token_Unit_BonusAgainstMounted:
                m_flags1 |= k_Unit_BonusAgainstMounted_Bit;
                break;
            case k_Token_Unit_SingleUse:
                m_flags1 |= k_Unit_SingleUse_Bit;
                break;
            case k_Token_Unit_BonusAirDefense:
                m_flags1 |= k_Unit_BonusAirDefense_Bit;
                break;
            case k_Token_Unit_WoodenShip:
                m_flags1 |= k_Unit_WoodenShip_Bit;
                break;
            case k_Token_Unit_AttackWoodenShipBonus:
                m_flags1 |= k_Unit_AttackWoodenShipBonus_Bit;
                break;
            case k_Token_Unit_HasAttackCityBonus:
                m_flags1 |= k_Unit_HasAttackCityBonus_Bit;
                break;
            case k_Token_Unit_HasAttackBonusSubmarine:
                m_flags1 |= k_Unit_HasAttackBonusSubmarine_Bit;
                break;
            case k_Token_Unit_ReplaceWithCargoModule:
                m_flags1 |= k_Unit_ReplaceWithCargoModule_Bit;
                if(!lex->GetIntAssignment(m_ReplaceWithCargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VisibileAttacking:
                m_flags1 |= k_Unit_VisibileAttacking_Bit;
                break;
            case k_Token_Unit_NuclearAttack:
                m_flags1 |= k_Unit_NuclearAttack_Bit;
                if(!m_NuclearAttackValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanSue:
                m_flags1 |= k_Unit_CanSue_Bit;
                break;
            case k_Token_Unit_IsStealthy:
                m_flags1 |= k_Unit_IsStealthy_Bit;
                break;
            case k_Token_Unit_SeeSurfaceFromSpace:
                m_flags1 |= k_Unit_SeeSurfaceFromSpace_Bit;
                break;
            case k_Token_Unit_EstablishEmbassy:
                m_flags1 |= k_Unit_EstablishEmbassy_Bit;
                break;
            case k_Token_Unit_ThrowParty:
                m_flags1 |= k_Unit_ThrowParty_Bit;
                break;
            case k_Token_Unit_HearGossip:
                m_flags1 |= k_Unit_HearGossip_Bit;
                break;
            case k_Token_Unit_StealTechnology:
                m_flags1 |= k_Unit_StealTechnology_Bit;
                if(!m_StealTechnologyValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolution:
                m_flags1 |= k_Unit_InciteRevolution_Bit;
                if(!m_InciteRevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRuler:
                m_flags1 |= k_Unit_AssasinateRuler_Bit;
                if(!m_AssasinateRulerValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadiness:
                m_flags1 |= k_Unit_InvestigateReadiness_Bit;
                if(!m_InvestigateReadinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_NullifyCityWalls:
                m_flags1 |= k_Unit_NullifyCityWalls_Bit;
                break;
            case k_Token_Unit_CreateFranchise:
                m_flags1 |= k_Unit_CreateFranchise_Bit;
                if(!m_CreateFranchiseValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappiness:
                m_flags1 |= k_Unit_CauseUnhappiness_Bit;
                if(!m_CauseUnhappinessValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ConductHits:
                m_flags1 |= k_Unit_ConductHits_Bit;
                if(!m_ConductHitsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BioTerror:
                m_flags1 |= k_Unit_BioTerror_Bit;
                if(!m_BioTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_NanoTerror:
                m_flags1 |= k_Unit_NanoTerror_Bit;
                if(!m_NanoTerrorValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Plague:
                m_flags2 |= k_Unit_Plague_Bit;
                if(!m_PlagueValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaids:
                m_flags2 |= k_Unit_SlaveRaids_Bit;
                if(!m_SlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SettlerSlaveRaids:
                m_flags2 |= k_Unit_SettlerSlaveRaids_Bit;
                if(!m_SettlerSlaveRaidsValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveUprising:
                m_flags2 |= k_Unit_SlaveUprising_Bit;
                if(!m_SlaveUprisingValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_UndergroundRailway:
                m_flags2 |= k_Unit_UndergroundRailway_Bit;
                if(!m_UndergroundRailwayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VictoryEnslavement:
                m_flags2 |= k_Unit_VictoryEnslavement_Bit;
                break;
            case k_Token_Unit_DefuseLandMines:
                m_flags2 |= k_Unit_DefuseLandMines_Bit;
                break;
            case k_Token_Unit_DefuseSeaMines:
                m_flags2 |= k_Unit_DefuseSeaMines_Bit;
                break;
            case k_Token_Unit_DefuseXrayMines:
                m_flags2 |= k_Unit_DefuseXrayMines_Bit;
                break;
            case k_Token_Unit_IndulgenceSales:
                m_flags2 |= k_Unit_IndulgenceSales_Bit;
                if(!m_IndulgenceSalesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ConvertCities:
                m_flags2 |= k_Unit_ConvertCities_Bit;
                if(!m_ConvertCitiesValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BuildXrayMines:
                m_flags2 |= k_Unit_BuildXrayMines_Bit;
                break;
            case k_Token_Unit_BuildWonder:
                m_flags2 |= k_Unit_BuildWonder_Bit;
                break;
            case k_Token_Unit_GovernmentType:
                if(!g_theGovernmentDB->ParseRecordInArray(lex, (sint32 **)&m_GovernmentType, &m_numGovernmentType, err)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NoSlaves:
                m_flags2 |= k_Unit_NoSlaves_Bit;
                break;
            case k_Token_Unit_CreateRift:
                m_flags2 |= k_Unit_CreateRift_Bit;
                break;
            case k_Token_Unit_CanCloak:
                m_flags2 |= k_Unit_CanCloak_Bit;
                break;
            case k_Token_Unit_ParatrooperTransport:
                m_flags2 |= k_Unit_ParatrooperTransport_Bit;
                break;
            case k_Token_Unit_CantBuild:
                m_flags2 |= k_Unit_CantBuild_Bit;
                break;
            case k_Token_Unit_PlantNuke:
                m_flags2 |= k_Unit_PlantNuke_Bit;
                if(!m_PlantNukeValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_IsTelevangelist:
                m_flags2 |= k_Unit_IsTelevangelist_Bit;
                break;
            case k_Token_Unit_CanSoothsay:
                m_flags2 |= k_Unit_CanSoothsay_Bit;
                if(!m_CanSoothsayValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanBeRustled:
                m_flags2 |= k_Unit_CanBeRustled_Bit;
                break;
            case k_Token_Unit_CreateParks:
                m_flags2 |= k_Unit_CreateParks_Bit;
                if(!m_CreateParksValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanInjoin:
                m_flags2 |= k_Unit_CanInjoin_Bit;
                if(!m_CanInjoinValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_WormholeProbe:
                m_flags2 |= k_Unit_WormholeProbe_Bit;
                break;
            case k_Token_Unit_HasBonusFood:
                m_flags2 |= k_Unit_HasBonusFood_Bit;
                break;
            case k_Token_Unit_LandCityCanBuild:
                m_flags2 |= k_Unit_LandCityCanBuild_Bit;
                break;
            case k_Token_Unit_SeaCityCanBuild:
                m_flags2 |= k_Unit_SeaCityCanBuild_Bit;
                break;
            case k_Token_Unit_SpaceCityCanBuild:
                m_flags2 |= k_Unit_SpaceCityCanBuild_Bit;
                break;
            case k_Token_Unit_IsSpecialForces:
                m_flags2 |= k_Unit_IsSpecialForces_Bit;
                break;
            case k_Token_Unit_NotAffectedByLandMines:
                m_flags2 |= k_Unit_NotAffectedByLandMines_Bit;
                break;
            case k_Token_Unit_InternalReserved:
                m_flags2 |= k_Unit_InternalReserved_Bit;
                break;
            case k_Token_Unit_DeathEffectsHappy:
                m_flags3 |= k_Unit_DeathEffectsHappy_Bit;
                break;
            case k_Token_Unit_EnableCarrierDefenses:
                m_flags3 |= k_Unit_EnableCarrierDefenses_Bit;
                break;
            case k_Token_Unit_ActiveDefenseOnlyWhenCarryingEnablers:
                m_flags3 |= k_Unit_ActiveDefenseOnlyWhenCarryingEnablers_Bit;
                break;
            case k_Token_Unit_BuildingRemovesAPop:
                m_flags3 |= k_Unit_BuildingRemovesAPop_Bit;
                break;
            case k_Token_Unit_Explodes:
                m_flags3 |= k_Unit_Explodes_Bit;
                break;
            case k_Token_Unit_Advertise:
                m_flags3 |= k_Unit_Advertise_Bit;
                break;
            case k_Token_Unit_CanRustle:
                m_flags3 |= k_Unit_CanRustle_Bit;
                break;
            case k_Token_Unit_OnlyBuildOne:
                m_flags3 |= k_Unit_OnlyBuildOne_Bit;
                break;
            case k_Token_Unit_CanExpel:
                m_flags3 |= k_Unit_CanExpel_Bit;
                break;
            case k_Token_Unit_CanReform:
                m_flags3 |= k_Unit_CanReform_Bit;
                if(!m_CanReformValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanPillage:
                m_flags3 |= k_Unit_CanPillage_Bit;
                break;
            case k_Token_Unit_CanPirate:
                m_flags3 |= k_Unit_CanPirate_Bit;
                break;
            case k_Token_Unit_VisionClass:
                if(!ParseVisionClassBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanSee:
                if(!ParseCanSeeBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CanAttack:
                if(!ParseCanAttackBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData:
                m_flags3 |= k_Unit_CargoData_Bit;
                if(!m_CargoDataValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ShieldCost:
                if(!lex->GetIntAssignment(m_ShieldCost)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_PowerPoints:
                if(!lex->GetIntAssignment(m_PowerPoints)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxHP:
                if(!lex->GetIntAssignment(m_MaxHP)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxHPr:
                if(!lex->GetFloatAssignment(m_MaxHPr)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Attack:
                if(!lex->GetFloatAssignment(m_Attack)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Defense:
                if(!lex->GetFloatAssignment(m_Defense)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Firepower:
                if(!lex->GetIntAssignment(m_Firepower)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ZBRangeAttack:
                if(!lex->GetIntAssignment(m_ZBRangeAttack)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Armor:
                if(!lex->GetFloatAssignment(m_Armor)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BRange:
                m_flags3 |= k_Unit_BRange_Bit;
                if(!lex->GetIntAssignment(m_BRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BRadius:
                m_flags3 |= k_Unit_BRadius_Bit;
                if(!lex->GetIntAssignment(m_BRadiusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_VisionRange:
                if(!lex->GetIntAssignment(m_VisionRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ActiveDefenseRange:
                if(!lex->GetIntAssignment(m_ActiveDefenseRange)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ElectronicCombatFactor:
                m_flags3 |= k_Unit_ElectronicCombatFactor_Bit;
                if(!lex->GetIntAssignment(m_ElectronicCombatFactorValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxMovePoints:
                if(!lex->GetFloatAssignment(m_MaxMovePoints)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MaxFuel:
                if(!lex->GetIntAssignment(m_MaxFuel)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_TransType:
                m_flags3 |= k_Unit_TransType_Bit;
                if(!lex->GetIntAssignment(m_TransTypeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ProbOfBombHit:
                m_flags3 |= k_Unit_ProbOfBombHit_Bit;
                if(!lex->GetIntAssignment(m_ProbOfBombHitValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BombRounds:
                m_flags3 |= k_Unit_BombRounds_Bit;
                if(!lex->GetIntAssignment(m_BombRoundsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_ShieldHunger:
                if(!lex->GetIntAssignment(m_ShieldHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_FoodHunger:
                if(!lex->GetIntAssignment(m_FoodHunger)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefaultSprite:
                if(!g_theSpriteDB->GetRecordFromLexer(lex, m_DefaultSprite, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_LaunchPollution:
                m_flags3 |= k_Unit_LaunchPollution_Bit;
                if(!lex->GetIntAssignment(m_LaunchPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_DeathPollution:
                m_flags3 |= k_Unit_DeathPollution_Bit;
                if(!lex->GetIntAssignment(m_DeathPollutionValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_MountedBonus:
                m_flags3 |= k_Unit_MountedBonus_Bit;
                if(!lex->GetFloatAssignment(m_MountedBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AirBonus:
                m_flags3 |= k_Unit_AirBonus_Bit;
                if(!lex->GetFloatAssignment(m_AirBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_WoodenShipBonus:
                m_flags3 |= k_Unit_WoodenShipBonus_Bit;
                if(!lex->GetFloatAssignment(m_WoodenShipBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackCityBonus:
                m_flags3 |= k_Unit_AttackCityBonus_Bit;
                if(!lex->GetFloatAssignment(m_AttackCityBonusValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_AttackBonusSubmarine:
                m_flags3 |= k_Unit_AttackBonusSubmarine_Bit;
                if(!lex->GetFloatAssignment(m_AttackBonusSubmarineValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoModule:
                m_flags3 |= k_Unit_CargoModule_Bit;
                if(!lex->GetIntAssignment(m_CargoModuleValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpyVsSpy:
                m_flags3 |= k_Unit_SpyVsSpy_Bit;
                if(!lex->GetFloatAssignment(m_SpyVsSpyValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCity:
                m_flags3 |= k_Unit_InvestigateCity_Bit;
                if(!m_InvestigateCityValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BonusFood:
                m_flags3 |= k_Unit_BonusFood_Bit;
                if(!lex->GetIntAssignment(m_BonusFoodValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_BombardRange:
                m_flags3 |= k_Unit_BombardRange_Bit;
                if(!lex->GetIntAssignment(m_BombardRangeValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Revolution:
                m_flags3 |= k_Unit_Revolution_Bit;
                if(!m_RevolutionValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundSelect1:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect1, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundSelect2:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundSelect2, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundMove:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundMove, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAcknowledge:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAcknowledge, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundCantMove:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundCantMove, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAttack:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundAttack, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundWork:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundWork, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundVictory:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundVictory, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundDeath:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundDeath, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundLoad:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundLoad, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundUnload:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_SoundUnload, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SpecialAttacks:
                if(!g_theSpecialAttackInfoDB->ParseRecordInArray(lex, (sint32 *)m_SpecialAttacks, &m_numSpecialAttacks, k_MAX_SpecialAttacks, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CityGrowthCoefficient:
                m_flags4 |= k_Unit_CityGrowthCoefficient_Bit;
                if(!lex->GetFloatAssignment(m_CityGrowthCoefficientValue)) {
                    DBERROR(("Expected number"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_UserFlags:
                if(!ParseUserFlagsBit(lex)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_DefaultIcon:
                if(!g_theIconDB->GetRecordFromLexer(lex, m_DefaultIcon, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_NoIndex:
                m_flags4 |= k_Unit_NoIndex_Bit;
                break;
            case k_Token_Unit_CheatIndex:
                m_flags4 |= k_Unit_CheatIndex_Bit;
                if(!lex->GetIntAssignment(m_CheatIndexValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Description:
                if(!lex->GetStringIdAssignment(m_Description)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Advice:
                m_flags4 |= k_Unit_Advice_Bit;
                if(!lex->GetStringIdAssignment(m_AdviceValue)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_Category:
                if(!lex->GetStringIdAssignment(m_Category)) {
                    DBERROR(("Expected string ID"));
                    done = true; break;
                }
                break;
            case k_Token_Unit_GLHidden:
                m_flags4 |= k_Unit_GLHidden_Bit;
                break;
            case k_Token_Unit_CantMove:
                m_flags4 |= k_Unit_CantMove_Bit;
                break;
            case k_Token_Unit_Civilian:
                m_flags4 |= k_Unit_Civilian_Bit;
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void UnitRecord::ResolveDBReferences()
{
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numObsoleteAdvance; i++) {
            if(m_ObsoleteAdvance[i] & 0x80000000) {
                sint32 id = m_ObsoleteAdvance[i] & 0x7fffffff;
                if(!g_theAdvanceDB->GetNamedItem(id, m_ObsoleteAdvance[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_ObsoleteAdvance[i] == 0x7fffffff){
                m_ObsoleteAdvance[i] = -1;
            }
        }
    }
    if(m_SettleCityType & 0x80000000) {
        sint32 id = m_SettleCityType & 0x7fffffff;
        if(!g_theUnitDB->GetNamedItem(id, m_SettleCityType)) {
            c3errors_ErrorDialog("DB", "%s not found in Unit database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SettleCityType == 0x7fffffff) {
        m_SettleCityType = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSettleBuilding; i++) {
            if(m_SettleBuilding[i] & 0x80000000) {
                sint32 id = m_SettleBuilding[i] & 0x7fffffff;
                if(!g_theBuildingDB->GetNamedItem(id, m_SettleBuilding[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Building database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SettleBuilding[i] == 0x7fffffff){
                m_SettleBuilding[i] = -1;
            }
        }
    }
    m_NuclearAttackValue.ResolveDBReferences();
    m_StealTechnologyValue.ResolveDBReferences();
    m_InciteRevolutionValue.ResolveDBReferences();
    m_AssasinateRulerValue.ResolveDBReferences();
    m_InvestigateReadinessValue.ResolveDBReferences();
    m_CreateFranchiseValue.ResolveDBReferences();
    m_CauseUnhappinessValue.ResolveDBReferences();
    m_ConductHitsValue.ResolveDBReferences();
    m_BioTerrorValue.ResolveDBReferences();
    m_NanoTerrorValue.ResolveDBReferences();
    m_PlagueValue.ResolveDBReferences();
    m_SlaveRaidsValue.ResolveDBReferences();
    m_SettlerSlaveRaidsValue.ResolveDBReferences();
    m_SlaveUprisingValue.ResolveDBReferences();
    m_UndergroundRailwayValue.ResolveDBReferences();
    m_IndulgenceSalesValue.ResolveDBReferences();
    m_ConvertCitiesValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numGovernmentType; i++) {
            if(m_GovernmentType[i] & 0x80000000) {
                sint32 id = m_GovernmentType[i] & 0x7fffffff;
                if(!g_theGovernmentDB->GetNamedItem(id, m_GovernmentType[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Government database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_GovernmentType[i] == 0x7fffffff){
                m_GovernmentType[i] = -1;
            }
        }
    }
    m_PlantNukeValue.ResolveDBReferences();
    m_CanSoothsayValue.ResolveDBReferences();
    m_CreateParksValue.ResolveDBReferences();
    m_CanInjoinValue.ResolveDBReferences();
    m_CanReformValue.ResolveDBReferences();
    m_CargoDataValue.ResolveDBReferences();
    if(m_DefaultSprite & 0x80000000) {
        sint32 id = m_DefaultSprite & 0x7fffffff;
        if(!g_theSpriteDB->GetNamedItem(id, m_DefaultSprite)) {
            c3errors_ErrorDialog("DB", "%s not found in Sprite database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultSprite == 0x7fffffff) {
        m_DefaultSprite = -1;
    }
    m_InvestigateCityValue.ResolveDBReferences();
    m_RevolutionValue.ResolveDBReferences();
    if(m_SoundSelect1 & 0x80000000) {
        sint32 id = m_SoundSelect1 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect1)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect1 == 0x7fffffff) {
        m_SoundSelect1 = -1;
    }
    if(m_SoundSelect2 & 0x80000000) {
        sint32 id = m_SoundSelect2 & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundSelect2)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundSelect2 == 0x7fffffff) {
        m_SoundSelect2 = -1;
    }
    if(m_SoundMove & 0x80000000) {
        sint32 id = m_SoundMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundMove == 0x7fffffff) {
        m_SoundMove = -1;
    }
    if(m_SoundAcknowledge & 0x80000000) {
        sint32 id = m_SoundAcknowledge & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAcknowledge)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAcknowledge == 0x7fffffff) {
        m_SoundAcknowledge = -1;
    }
    if(m_SoundCantMove & 0x80000000) {
        sint32 id = m_SoundCantMove & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundCantMove)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundCantMove == 0x7fffffff) {
        m_SoundCantMove = -1;
    }
    if(m_SoundAttack & 0x80000000) {
        sint32 id = m_SoundAttack & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundAttack)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundAttack == 0x7fffffff) {
        m_SoundAttack = -1;
    }
    if(m_SoundWork & 0x80000000) {
        sint32 id = m_SoundWork & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundWork)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundWork == 0x7fffffff) {
        m_SoundWork = -1;
    }
    if(m_SoundVictory & 0x80000000) {
        sint32 id = m_SoundVictory & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundVictory)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundVictory == 0x7fffffff) {
        m_SoundVictory = -1;
    }
    if(m_SoundDeath & 0x80000000) {
        sint32 id = m_SoundDeath & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundDeath)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundDeath == 0x7fffffff) {
        m_SoundDeath = -1;
    }
    if(m_SoundLoad & 0x80000000) {
        sint32 id = m_SoundLoad & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundLoad)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundLoad == 0x7fffffff) {
        m_SoundLoad = -1;
    }
    if(m_SoundUnload & 0x80000000) {
        sint32 id = m_SoundUnload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_SoundUnload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_SoundUnload == 0x7fffffff) {
        m_SoundUnload = -1;
    }
    {
        sint32 i;
        for(i = 0; i < m_numSpecialAttacks; i++) {
            if(m_SpecialAttacks[i] & 0x80000000) {
                sint32 id = m_SpecialAttacks[i] & 0x7fffffff;
                if(!g_theSpecialAttackInfoDB->GetNamedItem(id, m_SpecialAttacks[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in SpecialAttackInfo database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_SpecialAttacks[i] == 0x7fffffff){
                m_SpecialAttacks[i] = -1;
            }
        }
    }
    if(m_DefaultIcon & 0x80000000) {
        sint32 id = m_DefaultIcon & 0x7fffffff;
        if(!g_theIconDB->GetNamedItem(id, m_DefaultIcon)) {
            c3errors_ErrorDialog("DB", "%s not found in Icon database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_DefaultIcon == 0x7fffffff) {
        m_DefaultIcon = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
UnitRecord::SuccessDeath::SuccessDeath()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
}
UnitRecord::SuccessDeath::~SuccessDeath()
{
}
void UnitRecord::SuccessDeath::operator=(const SuccessDeath & rval)
{
	m_Chance = rval.m_Chance; 

	m_DeathChance = rval.m_DeathChance; 

}
static char *s_Unit_SuccessDeath_Tokens[] = {
    "Chance",
    "DeathChance",
};
#define k_Token_Unit_SuccessDeath_Chance         ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SuccessDeath_DeathChance    ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SuccessDeath_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::SuccessDeath::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::SuccessDeath::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for SuccessDeath"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_SuccessDeath_Tokens, k_Token_Unit_SuccessDeath_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SuccessDeath_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeath_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeath *oldArray = *array;
        *array = new SuccessDeath[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeath[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::SuccessDeath::ParseInArray(DBLexer *lex, SuccessDeath *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::SuccessDeath::ResolveDBReferences()
{
}
UnitRecord::SuccessDeathEffect::SuccessDeathEffect()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::SuccessDeathEffect::~SuccessDeathEffect()
{
}
void UnitRecord::SuccessDeathEffect::operator=(const SuccessDeathEffect & rval)
{
	m_Chance = rval.m_Chance; 

	m_DeathChance = rval.m_DeathChance; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_SuccessDeathEffect_Tokens[] = {
    "Chance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_SuccessDeathEffect_Chance   ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SuccessDeathEffect_DeathChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SuccessDeathEffect_Sound    ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_SuccessDeathEffect_Effect   ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_SuccessDeathEffect_Max ((k_Token_Custom_Base) + 4)
sint32 UnitRecord::SuccessDeathEffect::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::SuccessDeathEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for SuccessDeathEffect"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_SuccessDeathEffect_Tokens, k_Token_Unit_SuccessDeathEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SuccessDeathEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SuccessDeathEffect_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SuccessDeathEffect *oldArray = *array;
        *array = new SuccessDeathEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SuccessDeathEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::SuccessDeathEffect::ParseInArray(DBLexer *lex, SuccessDeathEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::SuccessDeathEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::StealTechnologyData::StealTechnologyData()
{
    m_RandomChance = 0.000000;
    m_SpecificChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::StealTechnologyData::~StealTechnologyData()
{
}
void UnitRecord::StealTechnologyData::operator=(const StealTechnologyData & rval)
{
	m_RandomChance = rval.m_RandomChance; 

	m_SpecificChance = rval.m_SpecificChance; 

	m_DeathChance = rval.m_DeathChance; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_StealTechnologyData_Tokens[] = {
    "RandomChance",
    "SpecificChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_StealTechnologyData_RandomChance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_StealTechnologyData_SpecificChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_StealTechnologyData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_StealTechnologyData_Sound   ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_StealTechnologyData_Effect  ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_StealTechnologyData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::StealTechnologyData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_RandomChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_SpecificChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::StealTechnologyData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for StealTechnologyData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_StealTechnologyData_Tokens, k_Token_Unit_StealTechnologyData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_StealTechnologyData_RandomChance:
                if(!lex->GetFloatAssignment(m_RandomChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_SpecificChance:
                if(!lex->GetFloatAssignment(m_SpecificChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_StealTechnologyData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        StealTechnologyData *oldArray = *array;
        *array = new StealTechnologyData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new StealTechnologyData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::StealTechnologyData::ParseInArray(DBLexer *lex, StealTechnologyData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::StealTechnologyData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::InciteRevolutionData::InciteRevolutionData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::InciteRevolutionData::~InciteRevolutionData()
{
}
void UnitRecord::InciteRevolutionData::operator=(const InciteRevolutionData & rval)
{
	m_Chance = rval.m_Chance; 

	m_EliteChance = rval.m_EliteChance; 

	m_DeathChance = rval.m_DeathChance; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_InciteRevolutionData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_InciteRevolutionData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InciteRevolutionData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InciteRevolutionData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InciteRevolutionData_Sound  ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_InciteRevolutionData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_InciteRevolutionData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::InciteRevolutionData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::InciteRevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for InciteRevolutionData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_InciteRevolutionData_Tokens, k_Token_Unit_InciteRevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InciteRevolutionData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InciteRevolutionData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InciteRevolutionData *oldArray = *array;
        *array = new InciteRevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InciteRevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::InciteRevolutionData::ParseInArray(DBLexer *lex, InciteRevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::InciteRevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::AssasinateRulerData::AssasinateRulerData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}
UnitRecord::AssasinateRulerData::~AssasinateRulerData()
{
}
void UnitRecord::AssasinateRulerData::operator=(const AssasinateRulerData & rval)
{
	m_Chance = rval.m_Chance; 

	m_EliteChance = rval.m_EliteChance; 

	m_DeathChance = rval.m_DeathChance; 

}
static char *s_Unit_AssasinateRulerData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_AssasinateRulerData_Chance  ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_AssasinateRulerData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_AssasinateRulerData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_AssasinateRulerData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::AssasinateRulerData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::AssasinateRulerData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for AssasinateRulerData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_AssasinateRulerData_Tokens, k_Token_Unit_AssasinateRulerData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_AssasinateRulerData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRulerData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_AssasinateRulerData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        AssasinateRulerData *oldArray = *array;
        *array = new AssasinateRulerData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new AssasinateRulerData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::AssasinateRulerData::ParseInArray(DBLexer *lex, AssasinateRulerData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::AssasinateRulerData::ResolveDBReferences()
{
}
UnitRecord::InvestigateReadinessData::InvestigateReadinessData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}
UnitRecord::InvestigateReadinessData::~InvestigateReadinessData()
{
}
void UnitRecord::InvestigateReadinessData::operator=(const InvestigateReadinessData & rval)
{
	m_Chance = rval.m_Chance; 

	m_EliteChance = rval.m_EliteChance; 

	m_DeathChance = rval.m_DeathChance; 

}
static char *s_Unit_InvestigateReadinessData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_InvestigateReadinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InvestigateReadinessData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InvestigateReadinessData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InvestigateReadinessData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::InvestigateReadinessData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::InvestigateReadinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for InvestigateReadinessData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_InvestigateReadinessData_Tokens, k_Token_Unit_InvestigateReadinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InvestigateReadinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadinessData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateReadinessData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateReadinessData *oldArray = *array;
        *array = new InvestigateReadinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateReadinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::InvestigateReadinessData::ParseInArray(DBLexer *lex, InvestigateReadinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::InvestigateReadinessData::ResolveDBReferences()
{
}
UnitRecord::ChanceEffect::ChanceEffect()
{
    m_Chance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::ChanceEffect::~ChanceEffect()
{
}
void UnitRecord::ChanceEffect::operator=(const ChanceEffect & rval)
{
	m_Chance = rval.m_Chance; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_ChanceEffect_Tokens[] = {
    "Chance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_ChanceEffect_Chance         ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_ChanceEffect_Sound          ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_ChanceEffect_Effect         ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_ChanceEffect_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::ChanceEffect::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::ChanceEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for ChanceEffect"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_ChanceEffect_Tokens, k_Token_Unit_ChanceEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_ChanceEffect_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ChanceEffect_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_ChanceEffect_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ChanceEffect *oldArray = *array;
        *array = new ChanceEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ChanceEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::ChanceEffect::ParseInArray(DBLexer *lex, ChanceEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::ChanceEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::CauseUnhappinessData::CauseUnhappinessData()
{
    m_Chance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::CauseUnhappinessData::~CauseUnhappinessData()
{
}
void UnitRecord::CauseUnhappinessData::operator=(const CauseUnhappinessData & rval)
{
	m_Chance = rval.m_Chance; 

	m_Timer = rval.m_Timer; 

	m_Amount = rval.m_Amount; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_CauseUnhappinessData_Tokens[] = {
    "Chance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unit_CauseUnhappinessData_Chance ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CauseUnhappinessData_Timer  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_CauseUnhappinessData_Amount ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_CauseUnhappinessData_Sound  ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_CauseUnhappinessData_Effect ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_CauseUnhappinessData_Max ((k_Token_Custom_Base) + 5)
sint32 UnitRecord::CauseUnhappinessData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::CauseUnhappinessData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for CauseUnhappinessData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_CauseUnhappinessData_Tokens, k_Token_Unit_CauseUnhappinessData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_CauseUnhappinessData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CauseUnhappinessData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CauseUnhappinessData *oldArray = *array;
        *array = new CauseUnhappinessData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CauseUnhappinessData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::CauseUnhappinessData::ParseInArray(DBLexer *lex, CauseUnhappinessData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::CauseUnhappinessData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::SlaveRaidsData::SlaveRaidsData()
{
    m_Chance = 0.000000;
    m_DeathChance = 0.000000;
    m_Timer = 0;
    m_Amount = 0;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::SlaveRaidsData::~SlaveRaidsData()
{
}
void UnitRecord::SlaveRaidsData::operator=(const SlaveRaidsData & rval)
{
	m_Chance = rval.m_Chance; 

	m_DeathChance = rval.m_DeathChance; 

	m_Timer = rval.m_Timer; 

	m_Amount = rval.m_Amount; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_SlaveRaidsData_Tokens[] = {
    "Chance",
    "DeathChance",
    "Timer",
    "Amount",
    "Sound",
    "Effect",
};
#define k_Token_Unit_SlaveRaidsData_Chance       ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SlaveRaidsData_DeathChance  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SlaveRaidsData_Timer        ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_SlaveRaidsData_Amount       ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_SlaveRaidsData_Sound        ((k_Token_Custom_Base) + 4)
#define k_Token_Unit_SlaveRaidsData_Effect       ((k_Token_Custom_Base) + 5)
#define k_Token_Unit_SlaveRaidsData_Max ((k_Token_Custom_Base) + 6)
sint32 UnitRecord::SlaveRaidsData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Timer)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!lex->GetIntAssignment(m_Amount)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::SlaveRaidsData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for SlaveRaidsData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_SlaveRaidsData_Tokens, k_Token_Unit_SlaveRaidsData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SlaveRaidsData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Timer:
                if(!lex->GetIntAssignment(m_Timer)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Amount:
                if(!lex->GetIntAssignment(m_Amount)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SlaveRaidsData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SlaveRaidsData *oldArray = *array;
        *array = new SlaveRaidsData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SlaveRaidsData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::SlaveRaidsData::ParseInArray(DBLexer *lex, SlaveRaidsData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::SlaveRaidsData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::SoundAndEffect::SoundAndEffect()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::SoundAndEffect::~SoundAndEffect()
{
}
void UnitRecord::SoundAndEffect::operator=(const SoundAndEffect & rval)
{
	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_SoundAndEffect_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unit_SoundAndEffect_Sound        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_SoundAndEffect_Effect       ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_SoundAndEffect_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::SoundAndEffect::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::SoundAndEffect::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for SoundAndEffect"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_SoundAndEffect_Tokens, k_Token_Unit_SoundAndEffect_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_SoundAndEffect_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_SoundAndEffect_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect **array, sint32 *numElements)
{
    if(*numElements > 0) {
        SoundAndEffect *oldArray = *array;
        *array = new SoundAndEffect[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new SoundAndEffect[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::SoundAndEffect::ParseInArray(DBLexer *lex, SoundAndEffect *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::SoundAndEffect::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::PlantNukeData::PlantNukeData()
{
    m_Chance = 0.000000;
    m_EscapeChance = 0.000000;
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::PlantNukeData::~PlantNukeData()
{
}
void UnitRecord::PlantNukeData::operator=(const PlantNukeData & rval)
{
	m_Chance = rval.m_Chance; 

	m_EscapeChance = rval.m_EscapeChance; 

	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_PlantNukeData_Tokens[] = {
    "Chance",
    "EscapeChance",
    "Sound",
    "Effect",
};
#define k_Token_Unit_PlantNukeData_Chance        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_PlantNukeData_EscapeChance  ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_PlantNukeData_Sound         ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_PlantNukeData_Effect        ((k_Token_Custom_Base) + 3)
#define k_Token_Unit_PlantNukeData_Max ((k_Token_Custom_Base) + 4)
sint32 UnitRecord::PlantNukeData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EscapeChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::PlantNukeData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for PlantNukeData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_PlantNukeData_Tokens, k_Token_Unit_PlantNukeData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_PlantNukeData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_EscapeChance:
                if(!lex->GetFloatAssignment(m_EscapeChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_PlantNukeData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        PlantNukeData *oldArray = *array;
        *array = new PlantNukeData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new PlantNukeData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::PlantNukeData::ParseInArray(DBLexer *lex, PlantNukeData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::PlantNukeData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
UnitRecord::CargoData::CargoData()
{
    m_MaxCargo = 0;
    m_Load = 0x7fffffff;
    m_Unload = 0x7fffffff;
}
UnitRecord::CargoData::~CargoData()
{
}
void UnitRecord::CargoData::operator=(const CargoData & rval)
{
	m_MaxCargo = rval.m_MaxCargo; 

	m_Load = rval.m_Load; 

	m_Unload = rval.m_Unload; 

}
static char *s_Unit_CargoData_Tokens[] = {
    "MaxCargo",
    "Load",
    "Unload",
};
#define k_Token_Unit_CargoData_MaxCargo          ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_CargoData_Load              ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_CargoData_Unload            ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_CargoData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::CargoData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetIntAssignment(m_MaxCargo)) {
        DBERROR(("Expected integer"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Load, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Unload, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::CargoData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for CargoData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_CargoData_Tokens, k_Token_Unit_CargoData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_CargoData_MaxCargo:
                if(!lex->GetIntAssignment(m_MaxCargo)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData_Load:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Load, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_CargoData_Unload:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Unload, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::CargoData::ParseInArray(DBLexer *lex, CargoData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        CargoData *oldArray = *array;
        *array = new CargoData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new CargoData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::CargoData::ParseInArray(DBLexer *lex, CargoData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::CargoData::ResolveDBReferences()
{
    if(m_Load & 0x80000000) {
        sint32 id = m_Load & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Load)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Load == 0x7fffffff) {
        m_Load = -1;
    }
    if(m_Unload & 0x80000000) {
        sint32 id = m_Unload & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Unload)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Unload == 0x7fffffff) {
        m_Unload = -1;
    }
}
UnitRecord::InvestigateCityData::InvestigateCityData()
{
    m_Chance = 0.000000;
    m_EliteChance = 0.000000;
    m_DeathChance = 0.000000;
}
UnitRecord::InvestigateCityData::~InvestigateCityData()
{
}
void UnitRecord::InvestigateCityData::operator=(const InvestigateCityData & rval)
{
	m_Chance = rval.m_Chance; 

	m_EliteChance = rval.m_EliteChance; 

	m_DeathChance = rval.m_DeathChance; 

}
static char *s_Unit_InvestigateCityData_Tokens[] = {
    "Chance",
    "EliteChance",
    "DeathChance",
};
#define k_Token_Unit_InvestigateCityData_Chance  ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_InvestigateCityData_EliteChance ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_InvestigateCityData_DeathChance ((k_Token_Custom_Base) + 2)
#define k_Token_Unit_InvestigateCityData_Max ((k_Token_Custom_Base) + 3)
sint32 UnitRecord::InvestigateCityData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_Chance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_EliteChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_DeathChance)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::InvestigateCityData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for InvestigateCityData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_InvestigateCityData_Tokens, k_Token_Unit_InvestigateCityData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_InvestigateCityData_Chance:
                if(!lex->GetFloatAssignment(m_Chance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCityData_EliteChance:
                if(!lex->GetFloatAssignment(m_EliteChance)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_InvestigateCityData_DeathChance:
                if(!lex->GetFloatAssignment(m_DeathChance)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        InvestigateCityData *oldArray = *array;
        *array = new InvestigateCityData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new InvestigateCityData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::InvestigateCityData::ParseInArray(DBLexer *lex, InvestigateCityData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::InvestigateCityData::ResolveDBReferences()
{
}
UnitRecord::RevolutionData::RevolutionData()
{
    m_Sound = 0x7fffffff;
    m_Effect = 0x7fffffff;
}
UnitRecord::RevolutionData::~RevolutionData()
{
}
void UnitRecord::RevolutionData::operator=(const RevolutionData & rval)
{
	m_Sound = rval.m_Sound; 

	m_Effect = rval.m_Effect; 

}
static char *s_Unit_RevolutionData_Tokens[] = {
    "Sound",
    "Effect",
};
#define k_Token_Unit_RevolutionData_Sound        ((k_Token_Custom_Base) + 0)
#define k_Token_Unit_RevolutionData_Effect       ((k_Token_Custom_Base) + 1)
#define k_Token_Unit_RevolutionData_Max ((k_Token_Custom_Base) + 2)
sint32 UnitRecord::RevolutionData::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
        DBERROR(("Expected record from Sound DB"));
        return 0;
    }
    if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
        DBERROR(("Expected record from SpecialEffect DB"));
        return 0;
    }
    return 1;
}
sint32 UnitRecord::RevolutionData::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for RevolutionData"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Unit_RevolutionData_Tokens, k_Token_Unit_RevolutionData_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Unit_RevolutionData_Sound:
                if(!g_theSoundDB->GetRecordFromLexer(lex, m_Sound, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Unit_RevolutionData_Effect:
                if(!g_theSpecialEffectDB->GetRecordFromLexer(lex, m_Effect, err)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 UnitRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RevolutionData *oldArray = *array;
        *array = new RevolutionData[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RevolutionData[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 UnitRecord::RevolutionData::ParseInArray(DBLexer *lex, RevolutionData *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void UnitRecord::RevolutionData::ResolveDBReferences()
{
    if(m_Sound & 0x80000000) {
        sint32 id = m_Sound & 0x7fffffff;
        if(!g_theSoundDB->GetNamedItem(id, m_Sound)) {
            c3errors_ErrorDialog("DB", "%s not found in Sound database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Sound == 0x7fffffff) {
        m_Sound = -1;
    }
    if(m_Effect & 0x80000000) {
        sint32 id = m_Effect & 0x7fffffff;
        if(!g_theSpecialEffectDB->GetNamedItem(id, m_Effect)) {
            c3errors_ErrorDialog("DB", "%s not found in SpecialEffect database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Effect == 0x7fffffff) {
        m_Effect = -1;
    }
}
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
static char *s_Unit_MovementType_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
};
#define k_Unit_MovementType_Num_BitNames 7

sint32 UnitRecord::ParseMovementTypeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_MovementType_BitNames, k_Unit_MovementType_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of MovementType", lex->GetTokenText()));
        return 0;
    }
    m_MovementType |= (1 << bitindex);
    return 1;
}

static char *s_Unit_CanCarry_BitNames[] = {
    "SmallLand",
    "MedLand",
    "LargeLand",
    "SmallAir",
    "MedAir",
    "LargeAir",
    "SmallWater",
    "MedWater",
    "LargeWater",
    "SmallSpace",
    "MedSpace",
    "LargeSpace",
};
#define k_Unit_CanCarry_Num_BitNames 12

sint32 UnitRecord::ParseCanCarryBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanCarry_BitNames, k_Unit_CanCarry_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanCarry", lex->GetTokenText()));
        return 0;
    }
    m_CanCarry |= (1 << bitindex);
    return 1;
}

static char *s_Unit_Size_BitNames[] = {
    "Small",
    "Medium",
    "Large",
};
#define k_Unit_Size_Num_BitNames 3

sint32 UnitRecord::ParseSizeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Size_BitNames, k_Unit_Size_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Size", lex->GetTokenText()));
        return 0;
    }
    m_Size |= (1 << bitindex);
    return 1;
}

static char *s_Unit_CanBombard_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unit_CanBombard_Num_BitNames 5

sint32 UnitRecord::ParseCanBombardBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanBombard_BitNames, k_Unit_CanBombard_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanBombard", lex->GetTokenText()));
        return 0;
    }
    m_CanBombard |= (1 << bitindex);
    return 1;
}

static char *s_Unit_Settle_BitNames[] = {
    "Land",
    "Water",
    "Mountain",
    "Space",
};
#define k_Unit_Settle_Num_BitNames 4

sint32 UnitRecord::ParseSettleBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Settle_BitNames, k_Unit_Settle_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Settle", lex->GetTokenText()));
        return 0;
    }
    m_Settle |= (1 << bitindex);
    return 1;
}

static char *s_Unit_Defend_BitNames[] = {
    "Land",
    "Air",
    "Water",
    "Space",
    "Mountain",
};
#define k_Unit_Defend_Num_BitNames 5

sint32 UnitRecord::ParseDefendBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_Defend_BitNames, k_Unit_Defend_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of Defend", lex->GetTokenText()));
        return 0;
    }
    m_Defend |= (1 << bitindex);
    return 1;
}

static char *s_Unit_VisionClass_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unit_VisionClass_Num_BitNames 16

sint32 UnitRecord::ParseVisionClassBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_VisionClass_BitNames, k_Unit_VisionClass_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of VisionClass", lex->GetTokenText()));
        return 0;
    }
    m_VisionClass |= (1 << bitindex);
    return 1;
}

static char *s_Unit_CanSee_BitNames[] = {
    "Standard",
    "Underwater",
    "Stealth",
    "UnusedBit3",
    "UnusedBit4",
    "UnusedBit5",
    "UnusedBit6",
    "UnusedBit7",
    "UnusedBit8",
    "UnusedBit9",
    "UnusedBit10",
    "UnusedBit11",
    "UnusedBit12",
    "UnusedBit13",
    "UnusedBit14",
    "UnusedBit15",
};
#define k_Unit_CanSee_Num_BitNames 16

sint32 UnitRecord::ParseCanSeeBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanSee_BitNames, k_Unit_CanSee_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanSee", lex->GetTokenText()));
        return 0;
    }
    m_CanSee |= (1 << bitindex);
    return 1;
}

static char *s_Unit_CanAttack_BitNames[] = {
    "Land",
    "Sea",
    "Air",
    "Mountain",
    "Trade",
    "ShallowWater",
    "Space",
    "Underwater",
};
#define k_Unit_CanAttack_Num_BitNames 8

sint32 UnitRecord::ParseCanAttackBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_CanAttack_BitNames, k_Unit_CanAttack_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of CanAttack", lex->GetTokenText()));
        return 0;
    }
    m_CanAttack |= (1 << bitindex);
    return 1;
}

static char *s_Unit_UserFlags_BitNames[] = {
    "UF1",
    "UF2",
    "UF3",
    "UF4",
    "UF5",
    "UF6",
    "UF7",
    "UF8",
    "UF9",
    "UF10",
    "UF11",
    "UF12",
    "UF13",
    "UF14",
    "UF15",
    "UF16",
    "UF17",
    "UF18",
    "UF19",
    "UF20",
    "UF21",
    "UF22",
    "UF23",
    "UF24",
    "UF25",
    "UF26",
    "UF27",
    "UF28",
    "UF29",
    "UF30",
    "UF31",
};
#define k_Unit_UserFlags_Num_BitNames 31

sint32 UnitRecord::ParseUserFlagsBit(DBLexer *lex)
{
    sint32 bitindex;
    if(!lex->GetBitIndex((const char **)s_Unit_UserFlags_BitNames, k_Unit_UserFlags_Num_BitNames, bitindex)) {
        DBERROR(("%s is not a member of UserFlags", lex->GetTokenText()));
        return 0;
    }
    m_UserFlags |= (1 << bitindex);
    return 1;
}

void UnitRecord::Merge(const UnitRecord & rval){
	int index = 0, obj_index = 0;
	// only replace values that have been set
	if(rval.m_MovementType != 0x0) 
		m_MovementType = rval.m_MovementType; 

	// only replace values that have been set
	if(rval.m_CanCarry != 0x0) 
		m_CanCarry = rval.m_CanCarry; 

	// copy values of rval.m_ObsoleteAdvance to m_ObsoleteAdvance
	for (index = 0; index < m_numObsoleteAdvance; index++) 
	{ 
 		if (index < rval.m_numObsoleteAdvance)
 			m_ObsoleteAdvance[index] = rval.m_ObsoleteAdvance[index];
	} 
 	// only replace values that have been set
	if(rval.m_Size != 0x0) 
		m_Size = rval.m_Size; 

	// only replace values that have been set
	if(rval.m_CanBombard != 0x0) 
		m_CanBombard = rval.m_CanBombard; 

	// only replace values that have been set
	if(rval.m_Settle != 0x0) 
		m_Settle = rval.m_Settle; 

	// resize m_SettleBuilding if necessary
	if (rval.m_numSettleBuilding > m_numSettleBuilding)
 	{ 
		delete m_SettleBuilding;
 		m_SettleBuilding = NULL;
 		if (rval.m_numSettleBuilding > 0)
 			m_SettleBuilding = new sint32 [rval.m_numSettleBuilding]; 
		m_numSettleBuilding = rval.m_numSettleBuilding;
 	} 

	// copy values of rval.m_SettleBuilding to m_SettleBuilding
	for (index = 0; index < m_numSettleBuilding; index++) 
	{ 
 		if (index < rval.m_numSettleBuilding)
 			m_SettleBuilding[index] = rval.m_SettleBuilding[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Unit_SpaceLaunch_Bit) != 0) 
		m_SpaceLaunchValue = rval.m_SpaceLaunchValue; 

	// only replace values that have been set
	if(rval.m_Defend != 0x0) 
		m_Defend = rval.m_Defend; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Unit_DefendAgainstSpies_Bit) != 0) 
		m_DefendAgainstSpiesValue = rval.m_DefendAgainstSpiesValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_ReplaceWithCargoModule_Bit) != 0) 
		m_ReplaceWithCargoModuleValue = rval.m_ReplaceWithCargoModuleValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_NuclearAttack_Bit) != 0) 
		m_NuclearAttackValue = rval.m_NuclearAttackValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_StealTechnology_Bit) != 0) 
		m_StealTechnologyValue = rval.m_StealTechnologyValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_InciteRevolution_Bit) != 0) 
		m_InciteRevolutionValue = rval.m_InciteRevolutionValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_AssasinateRuler_Bit) != 0) 
		m_AssasinateRulerValue = rval.m_AssasinateRulerValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_InvestigateReadiness_Bit) != 0) 
		m_InvestigateReadinessValue = rval.m_InvestigateReadinessValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_CreateFranchise_Bit) != 0) 
		m_CreateFranchiseValue = rval.m_CreateFranchiseValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_CauseUnhappiness_Bit) != 0) 
		m_CauseUnhappinessValue = rval.m_CauseUnhappinessValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_ConductHits_Bit) != 0) 
		m_ConductHitsValue = rval.m_ConductHitsValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_BioTerror_Bit) != 0) 
		m_BioTerrorValue = rval.m_BioTerrorValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Unit_NanoTerror_Bit) != 0) 
		m_NanoTerrorValue = rval.m_NanoTerrorValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_Plague_Bit) != 0) 
		m_PlagueValue = rval.m_PlagueValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_SlaveRaids_Bit) != 0) 
		m_SlaveRaidsValue = rval.m_SlaveRaidsValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_SettlerSlaveRaids_Bit) != 0) 
		m_SettlerSlaveRaidsValue = rval.m_SettlerSlaveRaidsValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_SlaveUprising_Bit) != 0) 
		m_SlaveUprisingValue = rval.m_SlaveUprisingValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_UndergroundRailway_Bit) != 0) 
		m_UndergroundRailwayValue = rval.m_UndergroundRailwayValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_IndulgenceSales_Bit) != 0) 
		m_IndulgenceSalesValue = rval.m_IndulgenceSalesValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_ConvertCities_Bit) != 0) 
		m_ConvertCitiesValue = rval.m_ConvertCitiesValue; 

	// resize m_GovernmentType if necessary
	if (rval.m_numGovernmentType > m_numGovernmentType)
 	{ 
		delete m_GovernmentType;
 		m_GovernmentType = NULL;
 		if (rval.m_numGovernmentType > 0)
 			m_GovernmentType = new sint32 [rval.m_numGovernmentType]; 
		m_numGovernmentType = rval.m_numGovernmentType;
 	} 

	// copy values of rval.m_GovernmentType to m_GovernmentType
	for (index = 0; index < m_numGovernmentType; index++) 
	{ 
 		if (index < rval.m_numGovernmentType)
 			m_GovernmentType[index] = rval.m_GovernmentType[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_PlantNuke_Bit) != 0) 
		m_PlantNukeValue = rval.m_PlantNukeValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_CanSoothsay_Bit) != 0) 
		m_CanSoothsayValue = rval.m_CanSoothsayValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_CreateParks_Bit) != 0) 
		m_CreateParksValue = rval.m_CreateParksValue; 

	// only replace values that have been set
	if((rval.m_flags2 & k_Unit_CanInjoin_Bit) != 0) 
		m_CanInjoinValue = rval.m_CanInjoinValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_CanReform_Bit) != 0) 
		m_CanReformValue = rval.m_CanReformValue; 

	// only replace values that have been set
	if(rval.m_VisionClass != 0x0) 
		m_VisionClass = rval.m_VisionClass; 

	// only replace values that have been set
	if(rval.m_CanSee != 0x0) 
		m_CanSee = rval.m_CanSee; 

	// only replace values that have been set
	if(rval.m_CanAttack != 0x0) 
		m_CanAttack = rval.m_CanAttack; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_CargoData_Bit) != 0) 
		m_CargoDataValue = rval.m_CargoDataValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_BRange_Bit) != 0) 
		m_BRangeValue = rval.m_BRangeValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_BRadius_Bit) != 0) 
		m_BRadiusValue = rval.m_BRadiusValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_ElectronicCombatFactor_Bit) != 0) 
		m_ElectronicCombatFactorValue = rval.m_ElectronicCombatFactorValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_TransType_Bit) != 0) 
		m_TransTypeValue = rval.m_TransTypeValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_ProbOfBombHit_Bit) != 0) 
		m_ProbOfBombHitValue = rval.m_ProbOfBombHitValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_BombRounds_Bit) != 0) 
		m_BombRoundsValue = rval.m_BombRoundsValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_LaunchPollution_Bit) != 0) 
		m_LaunchPollutionValue = rval.m_LaunchPollutionValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_DeathPollution_Bit) != 0) 
		m_DeathPollutionValue = rval.m_DeathPollutionValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_MountedBonus_Bit) != 0) 
		m_MountedBonusValue = rval.m_MountedBonusValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_AirBonus_Bit) != 0) 
		m_AirBonusValue = rval.m_AirBonusValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_WoodenShipBonus_Bit) != 0) 
		m_WoodenShipBonusValue = rval.m_WoodenShipBonusValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_AttackCityBonus_Bit) != 0) 
		m_AttackCityBonusValue = rval.m_AttackCityBonusValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_AttackBonusSubmarine_Bit) != 0) 
		m_AttackBonusSubmarineValue = rval.m_AttackBonusSubmarineValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_CargoModule_Bit) != 0) 
		m_CargoModuleValue = rval.m_CargoModuleValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_SpyVsSpy_Bit) != 0) 
		m_SpyVsSpyValue = rval.m_SpyVsSpyValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_InvestigateCity_Bit) != 0) 
		m_InvestigateCityValue = rval.m_InvestigateCityValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_BonusFood_Bit) != 0) 
		m_BonusFoodValue = rval.m_BonusFoodValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_BombardRange_Bit) != 0) 
		m_BombardRangeValue = rval.m_BombardRangeValue; 

	// only replace values that have been set
	if((rval.m_flags3 & k_Unit_Revolution_Bit) != 0) 
		m_RevolutionValue = rval.m_RevolutionValue; 

	// copy values of rval.m_SpecialAttacks to m_SpecialAttacks
	for (index = 0; index < m_numSpecialAttacks; index++) 
	{ 
 		if (index < rval.m_numSpecialAttacks)
 			m_SpecialAttacks[index] = rval.m_SpecialAttacks[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags4 & k_Unit_CityGrowthCoefficient_Bit) != 0) 
		m_CityGrowthCoefficientValue = rval.m_CityGrowthCoefficientValue; 

	// only replace values that have been set
	if(rval.m_UserFlags != 0x0) 
		m_UserFlags = rval.m_UserFlags; 

	// only replace values that have been set
	if((rval.m_flags4 & k_Unit_CheatIndex_Bit) != 0) 
		m_CheatIndexValue = rval.m_CheatIndexValue; 

	// only replace values that have been set
	if((rval.m_flags4 & k_Unit_Advice_Bit) != 0) 
		m_AdviceValue = rval.m_AdviceValue; 

} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const AdvanceRecord *UnitRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

sint32 UnitRecord::GetObsoleteAdvanceIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return m_ObsoleteAdvance[index];
}

const AdvanceRecord *UnitRecord::GetObsoleteAdvance(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numObsoleteAdvance);
    if((index < 0) || (index >= m_numObsoleteAdvance)) {
        return 0;
    }
    return g_theAdvanceDB->Get(m_ObsoleteAdvance[index]);
}

const UnitRecord *UnitRecord::GetSettleCityType() const
{
    return g_theUnitDB->Get(m_SettleCityType);
}

sint32 UnitRecord::GetSettleBuildingIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return m_SettleBuilding[index];
}

const BuildingRecord *UnitRecord::GetSettleBuilding(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSettleBuilding);
    if((index < 0) || (index >= m_numSettleBuilding)) {
        return 0;
    }
    return g_theBuildingDB->Get(m_SettleBuilding[index]);
}

sint32 UnitRecord::GetGovernmentTypeIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return m_GovernmentType[index];
}

const GovernmentRecord *UnitRecord::GetGovernmentType(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numGovernmentType);
    if((index < 0) || (index >= m_numGovernmentType)) {
        return 0;
    }
    return g_theGovernmentDB->Get(m_GovernmentType[index]);
}

const SpriteRecord *UnitRecord::GetDefaultSprite() const
{
    return g_theSpriteDB->Get(m_DefaultSprite);
}

const SoundRecord *UnitRecord::GetSoundSelect1() const
{
    return g_theSoundDB->Get(m_SoundSelect1);
}

const SoundRecord *UnitRecord::GetSoundSelect2() const
{
    return g_theSoundDB->Get(m_SoundSelect2);
}

const SoundRecord *UnitRecord::GetSoundMove() const
{
    return g_theSoundDB->Get(m_SoundMove);
}

const SoundRecord *UnitRecord::GetSoundAcknowledge() const
{
    return g_theSoundDB->Get(m_SoundAcknowledge);
}

const SoundRecord *UnitRecord::GetSoundCantMove() const
{
    return g_theSoundDB->Get(m_SoundCantMove);
}

const SoundRecord *UnitRecord::GetSoundAttack() const
{
    return g_theSoundDB->Get(m_SoundAttack);
}

const SoundRecord *UnitRecord::GetSoundWork() const
{
    return g_theSoundDB->Get(m_SoundWork);
}

const SoundRecord *UnitRecord::GetSoundVictory() const
{
    return g_theSoundDB->Get(m_SoundVictory);
}

const SoundRecord *UnitRecord::GetSoundDeath() const
{
    return g_theSoundDB->Get(m_SoundDeath);
}

const SoundRecord *UnitRecord::GetSoundLoad() const
{
    return g_theSoundDB->Get(m_SoundLoad);
}

const SoundRecord *UnitRecord::GetSoundUnload() const
{
    return g_theSoundDB->Get(m_SoundUnload);
}

sint32 UnitRecord::GetSpecialAttacksIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return m_SpecialAttacks[index];
}

const SpecialAttackInfoRecord *UnitRecord::GetSpecialAttacks(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numSpecialAttacks);
    if((index < 0) || (index >= m_numSpecialAttacks)) {
        return 0;
    }
    return g_theSpecialAttackInfoDB->Get(m_SpecialAttacks[index]);
}

const IconRecord *UnitRecord::GetDefaultIcon() const
{
    return g_theIconDB->Get(m_DefaultIcon);
}

const SoundRecord *UnitRecord::SuccessDeathEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SuccessDeathEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::StealTechnologyData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::StealTechnologyData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::InciteRevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::InciteRevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::ChanceEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::ChanceEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::CauseUnhappinessData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::CauseUnhappinessData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::SlaveRaidsData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SlaveRaidsData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::SoundAndEffect::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::SoundAndEffect::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::PlantNukeData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::PlantNukeData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

const SoundRecord *UnitRecord::CargoData::GetLoad() const
{
    return g_theSoundDB->Get(m_Load);
}

const SoundRecord *UnitRecord::CargoData::GetUnload() const
{
    return g_theSoundDB->Get(m_Unload);
}

const SoundRecord *UnitRecord::RevolutionData::GetSound() const
{
    return g_theSoundDB->Get(m_Sound);
}

const SpecialEffectRecord *UnitRecord::RevolutionData::GetEffect() const
{
    return g_theSpecialEffectDB->Get(m_Effect);
}

