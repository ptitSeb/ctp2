
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#ifndef __SpecialAttackInfo_RECORD_H__
#define __SpecialAttackInfo_RECORD_H__

/*
 * SpecialAttackInfo description
 */
#include "CTPRecord.h"
//
// Range definitions

/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
class SoundRecord;
class SpecialEffectRecord;

class SpecialAttackInfoRecord : public CTPRecord
{
public:
    typedef sint32 (SpecialAttackInfoRecord::*IntAccessor)() const;
    typedef bool (SpecialAttackInfoRecord::*BoolAccessor)() const;
    typedef double (SpecialAttackInfoRecord::*FloatAccessor)() const ;
    typedef bool (SpecialAttackInfoRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool (SpecialAttackInfoRecord::*BitFloatAccessor)(double &val) const;
private:
    sint32            m_SoundID; // Index into Sound database
    sint32            m_SpriteID; // Index into SpecialEffect database

public:
    SpecialAttackInfoRecord() { Init(); };
    ~SpecialAttackInfoRecord();
    Init();
    // These methods are needed for records to conform to
    // 'Orthodox Cannonical Form' and work with resizing STL vectors. 
    SpecialAttackInfoRecord(const SpecialAttackInfoRecord &rval) { Init(); *this = rval; }
    void operator=(const SpecialAttackInfoRecord &rval);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex);

    void ResolveDBReferences();
    void Merge(const SpecialAttackInfoRecord & rval);
    //
    // Accessors
    //
    sint32           GetSoundIDIndex() const { return m_SoundID; }
    const SoundRecord *GetSoundID() const;
    sint32           GetSpriteIDIndex() const { return m_SpriteID; }
    const SpecialEffectRecord *GetSpriteID() const;
}; /* SpecialAttackInfoRecord */

struct SpecialAttackInfoRecordAccessorInfo {
    SpecialAttackInfoRecord::IntAccessor m_intAccessor;
    SpecialAttackInfoRecord::BoolAccessor m_boolAccessor;
    SpecialAttackInfoRecord::FloatAccessor m_floatAccessor;
    SpecialAttackInfoRecord::BitIntAccessor m_bitIntAccessor;
    SpecialAttackInfoRecord::BitFloatAccessor m_bitFloatAccessor;
};
extern SpecialAttackInfoRecordAccessorInfo g_SpecialAttackInfoRecord_Accessors[];
extern char *g_SpecialAttackInfo_Tokens[];
#define k_Num_SpecialAttackInfoRecord_Tokens 2

template <class T> class CTPDatabase;
extern CTPDatabase<SpecialAttackInfoRecord> *g_theSpecialAttackInfoDB;

#endif /* ifndef __SpecialAttackInfo_RECORD_H__ */
