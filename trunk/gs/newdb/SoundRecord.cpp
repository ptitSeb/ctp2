
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "SoundRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"


CTPDatabase<SoundRecord> *g_theSoundDB = NULL;

SoundRecord::Init()
{
    m_Value = NULL;
    m_NameText = NULL;
}

SoundRecord::~SoundRecord()
{
	int index = 0;
	// free string attribute Value
	if (m_Value) 
		delete m_Value; 
	m_Value = NULL; 

	// free string attribute NameText
	if (m_NameText) 
		delete m_NameText; 
	m_NameText = NULL; 

}

void SoundRecord::operator=(const SoundRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	if (m_Value) 
	{ 
	delete m_Value; 

	}

	if (rval.m_Value) 
	{ 
		m_Value = new char [strlen(rval.m_Value)+1]; 
		strcpy(m_Value, rval.m_Value);
	}

	if (m_NameText) 
	{ 
	delete m_NameText; 

	}

	if (rval.m_NameText) 
	{ 
		m_NameText = new char [strlen(rval.m_NameText)+1]; 
		strcpy(m_NameText, rval.m_NameText);
	}

}

char *g_Sound_Tokens[] =
{
    "Value",
    "NameText",
};

SoundRecordAccessorInfo g_SoundRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Value */
    { NULL, NULL, NULL, NULL, NULL}, /* NameText */
};

#define k_Token_Sound_Value                      ((k_Token_Custom_Base) + 0)
#define k_Token_Sound_NameText                   ((k_Token_Custom_Base) + 1)
#define k_Token_Sound_Max                        ((k_Token_Custom_Base) + 2)


static BitArray s_ParsedTokens(2);
void SoundRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
    if(!s_ParsedTokens.Bit(k_Token_Sound_Value - k_Token_Custom_Base)) {
        DBERROR(("Warning: required field Value missing"));
    }
}
    
sint32 SoundRecord::Parse(DBLexer *lex)
{
    sint32 tok;
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record must start with name"));
        return 0;
    }
    m_NameText = new char[strlen(lex->GetTokenText()) + 1];
    strcpy(m_NameText, lex->GetTokenText());
    if(!lex->GetFileAssignment(m_Value)) {
        DBERROR(("Expected string"));
        return 0;
    }
    return 1;
}
void SoundRecord::ResolveDBReferences()
{
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void SoundRecord::Merge(const SoundRecord & rval){
	int index = 0, obj_index = 0;
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
