
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#ifndef __EndGameObject_RECORD_H__
#define __EndGameObject_RECORD_H__

/*
 * EndGameObject description
 */
#include "CTPRecord.h"
//
// m_flags0
#define k_EndGameObject_Wonder_Bit               0x00000001
#define k_EndGameObject_Building_Bit             0x00000002
#define k_EndGameObject_TerrainImprovement_Bit   0x00000004
#define k_EndGameObject_MinNeeded_Bit            0x00000008
#define k_EndGameObject_MaxNeeded_Bit            0x00000010
#define k_EndGameObject_IsSatellite_Bit          0x00000020
#define k_EndGameObject_PowerSource_Bit          0x00000040
#define k_EndGameObject_MinRadius_Bit            0x00000080
#define k_EndGameObject_MaxRadius_Bit            0x00000100
#define k_EndGameObject_MinCoverage_Bit          0x00000200
#define k_EndGameObject_TurnsToActivate_Bit      0x00000400
//
// Range definitions

/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
class WonderRecord;
class BuildingRecord;
class TerrainImprovementRecord;
class EndGameObjectRecord;

class EndGameObjectRecord : public CTPRecord
{
public:
    typedef sint32 (EndGameObjectRecord::*IntAccessor)() const;
    typedef bool (EndGameObjectRecord::*BoolAccessor)() const;
    typedef double (EndGameObjectRecord::*FloatAccessor)() const ;
    typedef bool (EndGameObjectRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool (EndGameObjectRecord::*BitFloatAccessor)(double &val) const;
private:
    uint32 m_flags0;

    sint32            m_WonderValue; // Index into Wonder database
    sint32            m_BuildingValue; // Index into Building database
    sint32            m_TerrainImprovementValue; // Index into TerrainImprovement database
    sint32            m_MinNeededValue;
    sint32            m_MaxNeededValue;
    sint32            m_PowerSourceValue; // Index into EndGameObject database
    sint32            m_MinRadiusValue;
    sint32            m_MaxRadiusValue;
    double            m_MinCoverageValue;
    sint32            m_TurnsToActivateValue;

public:
    EndGameObjectRecord() { Init(); };
    ~EndGameObjectRecord();
    Init();
    // These methods are needed for records to conform to
    // 'Orthodox Cannonical Form' and work with resizing STL vectors. 
    EndGameObjectRecord(const EndGameObjectRecord &rval) { Init(); *this = rval; }
    void operator=(const EndGameObjectRecord &rval);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex);

    void ResolveDBReferences();
    void Merge(const EndGameObjectRecord & rval);
    //
    // Accessors
    //
    bool             GetWonder() const { return (m_flags0 & k_EndGameObject_Wonder_Bit) != 0; }
    bool             GetWonderIndex(sint32 &index) const {
                         if((m_flags0 & k_EndGameObject_Wonder_Bit) == 0) return false;
                         index = m_WonderValue;
                         return true;
                     }
    bool             GetWonder(const WonderRecord *&rec) const;
    const WonderRecord  *GetWonderPtr() const;
    bool             GetBuilding() const { return (m_flags0 & k_EndGameObject_Building_Bit) != 0; }
    bool             GetBuildingIndex(sint32 &index) const {
                         if((m_flags0 & k_EndGameObject_Building_Bit) == 0) return false;
                         index = m_BuildingValue;
                         return true;
                     }
    bool             GetBuilding(const BuildingRecord *&rec) const;
    const BuildingRecord  *GetBuildingPtr() const;
    bool             GetTerrainImprovement() const { return (m_flags0 & k_EndGameObject_TerrainImprovement_Bit) != 0; }
    bool             GetTerrainImprovementIndex(sint32 &index) const {
                         if((m_flags0 & k_EndGameObject_TerrainImprovement_Bit) == 0) return false;
                         index = m_TerrainImprovementValue;
                         return true;
                     }
    bool             GetTerrainImprovement(const TerrainImprovementRecord *&rec) const;
    const TerrainImprovementRecord  *GetTerrainImprovementPtr() const;
    bool             GetMinNeeded() const { return (m_flags0 & k_EndGameObject_MinNeeded_Bit) != 0; }
    bool             GetMinNeeded(sint32 &value) const {
                         if((m_flags0 & k_EndGameObject_MinNeeded_Bit) == 0) return false;
                         value = m_MinNeededValue;
                         return true;
                     }
    bool             GetMaxNeeded() const { return (m_flags0 & k_EndGameObject_MaxNeeded_Bit) != 0; }
    bool             GetMaxNeeded(sint32 &value) const {
                         if((m_flags0 & k_EndGameObject_MaxNeeded_Bit) == 0) return false;
                         value = m_MaxNeededValue;
                         return true;
                     }
    bool             GetIsSatellite() const { return (m_flags0 & k_EndGameObject_IsSatellite_Bit) != 0; }
    bool             GetPowerSource() const { return (m_flags0 & k_EndGameObject_PowerSource_Bit) != 0; }
    bool             GetPowerSourceIndex(sint32 &index) const {
                         if((m_flags0 & k_EndGameObject_PowerSource_Bit) == 0) return false;
                         index = m_PowerSourceValue;
                         return true;
                     }
    bool             GetPowerSource(const EndGameObjectRecord *&rec) const;
    const EndGameObjectRecord  *GetPowerSourcePtr() const;
    bool             GetMinRadius() const { return (m_flags0 & k_EndGameObject_MinRadius_Bit) != 0; }
    bool             GetMinRadius(sint32 &value) const {
                         if((m_flags0 & k_EndGameObject_MinRadius_Bit) == 0) return false;
                         value = m_MinRadiusValue;
                         return true;
                     }
    bool             GetMaxRadius() const { return (m_flags0 & k_EndGameObject_MaxRadius_Bit) != 0; }
    bool             GetMaxRadius(sint32 &value) const {
                         if((m_flags0 & k_EndGameObject_MaxRadius_Bit) == 0) return false;
                         value = m_MaxRadiusValue;
                         return true;
                     }
    bool             GetMinCoverage() const { return (m_flags0 & k_EndGameObject_MinCoverage_Bit) != 0; }
    bool             GetMinCoverage(double &value) const {
                         if((m_flags0 & k_EndGameObject_MinCoverage_Bit) == 0) return false;
                         value = m_MinCoverageValue;
                         return true;
                     }
    bool             GetTurnsToActivate() const { return (m_flags0 & k_EndGameObject_TurnsToActivate_Bit) != 0; }
    bool             GetTurnsToActivate(sint32 &value) const {
                         if((m_flags0 & k_EndGameObject_TurnsToActivate_Bit) == 0) return false;
                         value = m_TurnsToActivateValue;
                         return true;
                     }
}; /* EndGameObjectRecord */

struct EndGameObjectRecordAccessorInfo {
    EndGameObjectRecord::IntAccessor m_intAccessor;
    EndGameObjectRecord::BoolAccessor m_boolAccessor;
    EndGameObjectRecord::FloatAccessor m_floatAccessor;
    EndGameObjectRecord::BitIntAccessor m_bitIntAccessor;
    EndGameObjectRecord::BitFloatAccessor m_bitFloatAccessor;
};
extern EndGameObjectRecordAccessorInfo g_EndGameObjectRecord_Accessors[];
extern char *g_EndGameObject_Tokens[];
#define k_Num_EndGameObjectRecord_Tokens 21

template <class T> class CTPDatabase;
extern CTPDatabase<EndGameObjectRecord> *g_theEndGameObjectDB;

#endif /* ifndef __EndGameObject_RECORD_H__ */
