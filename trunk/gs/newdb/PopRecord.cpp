
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "PopRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "AdvanceRecord.h"

CTPDatabase<PopRecord> *g_thePopDB = NULL;

PopRecord::Init()
{
    m_EnableAdvance = 0x7fffffff;
    m_Science = 0;
    m_Happiness = 0;
    m_Food = 0;
    m_Production = 0;
    m_Commerce = 0;
}

PopRecord::~PopRecord()
{
	int index = 0;
}

void PopRecord::operator=(const PopRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	m_EnableAdvance = rval.m_EnableAdvance; 

	m_Science = rval.m_Science; 

	m_Happiness = rval.m_Happiness; 

	m_Food = rval.m_Food; 

	m_Production = rval.m_Production; 

	m_Commerce = rval.m_Commerce; 

}

char *g_Pop_Tokens[] =
{
    "EnableAdvance",
    "Science",
    "Happiness",
    "Food",
    "Production",
    "Commerce",
};

PopRecordAccessorInfo g_PopRecord_Accessors[] = 
{
    {PopRecord::GetEnableAdvanceIndex, NULL, NULL, NULL, NULL },
    { PopRecord::GetScience, NULL, NULL, NULL, NULL },
    { PopRecord::GetHappiness, NULL, NULL, NULL, NULL },
    { PopRecord::GetFood, NULL, NULL, NULL, NULL },
    { PopRecord::GetProduction, NULL, NULL, NULL, NULL },
    { PopRecord::GetCommerce, NULL, NULL, NULL, NULL },
};

#define k_Token_Pop_EnableAdvance                ((k_Token_Custom_Base) + 0)
#define k_Token_Pop_Science                      ((k_Token_Custom_Base) + 1)
#define k_Token_Pop_Happiness                    ((k_Token_Custom_Base) + 2)
#define k_Token_Pop_Food                         ((k_Token_Custom_Base) + 3)
#define k_Token_Pop_Production                   ((k_Token_Custom_Base) + 4)
#define k_Token_Pop_Commerce                     ((k_Token_Custom_Base) + 5)
#define k_Token_Pop_Max                          ((k_Token_Custom_Base) + 6)


static BitArray s_ParsedTokens(6);
void PopRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 PopRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Pop_Tokens, k_Token_Pop_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Pop_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Pop_EnableAdvance:
                if(!g_theAdvanceDB->GetRecordFromLexer(lex, m_EnableAdvance, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Pop_Science:
                if(!lex->GetIntAssignment(m_Science)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Happiness:
                if(!lex->GetIntAssignment(m_Happiness)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Food:
                if(!lex->GetIntAssignment(m_Food)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Production:
                if(!lex->GetIntAssignment(m_Production)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Pop_Commerce:
                if(!lex->GetIntAssignment(m_Commerce)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void PopRecord::ResolveDBReferences()
{
    if(m_EnableAdvance & 0x80000000) {
        sint32 id = m_EnableAdvance & 0x7fffffff;
        if(!g_theAdvanceDB->GetNamedItem(id, m_EnableAdvance)) {
            c3errors_ErrorDialog("DB", "%s not found in Advance database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_EnableAdvance == 0x7fffffff) {
        m_EnableAdvance = -1;
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void PopRecord::Merge(const PopRecord & rval){
	int index = 0, obj_index = 0;
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
const AdvanceRecord *PopRecord::GetEnableAdvance() const
{
    return g_theAdvanceDB->Get(m_EnableAdvance);
}

