
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#include "c3.h"
#include "c3errors.h"
#include "DiplomacyRecord.h"
#include "DBLexer.h"
#include "DBTokens.h"
#include "CTPDatabase.h"
#include "StrDB.h"
#include "BitArray.h"

#include "DiplomacyRecord.h"
#include "DiplomacyProposalRecord.h"

CTPDatabase<DiplomacyRecord> *g_theDiplomacyDB = NULL;

DiplomacyRecord::Init()
{
    m_flags0 = 0;
    m_flags1 = 0;
    memset(m_Inherit, 0, sizeof(m_Inherit));
    m_numInherit = 0;
    memset(&m_ScenarioEventValue, 0, sizeof(m_ScenarioEventValue));
    memset(&m_MilitaryPowerEventValue, 0, sizeof(m_MilitaryPowerEventValue));
    memset(&m_MilitarySafetyEventValue, 0, sizeof(m_MilitarySafetyEventValue));
    memset(&m_DiplomacyEventValue, 0, sizeof(m_DiplomacyEventValue));
    memset(&m_GoldEventValue, 0, sizeof(m_GoldEventValue));
    memset(&m_KnowledgeEventValue, 0, sizeof(m_KnowledgeEventValue));
    memset(&m_ProductionEventValue, 0, sizeof(m_ProductionEventValue));
    m_ThreatenValue = 0;
    m_IncursionRegardCostValue = 0;
    m_IncursionOfAllieRegardCostValue = 0;
    m_InvaderMovementRegardCostValue = 0;
    m_PerRoutePiracyRegardCostValue = 0;
    m_ShareContinentRegardCostValue = 0;
    m_AttackCivilianRegardCostValue = 0;
    m_PreemptiveAttackRegardCostValue = 0;
    m_EmbargoTradeRegardCostValue = 0;
    m_TakeCityRegardCostValue = 0;
    m_InciteRevolutionRegardCostValue = 0;
    m_AssassinateRulerRegardCostValue = 0;
    m_FranchiseCityRegardCostValue = 0;
    m_PlantNukeRegardCostValue = 0;
    m_SlaveRaidRegardCostValue = 0;
    m_LawsuitRegardCostValue = 0;
    m_ExpelUnitsRegardCostValue = 0;
    m_NukeCityRegardCostValue = 0;
    m_ConvertCityRegardCostValue = 0;
    m_EnslaveSettlerRegardCostValue = 0;
    m_UndergroundRailwayRegardCostValue = 0;
    m_InciteUprisingRegardCostValue = 0;
    m_BioInfectedCityRegardCostValue = 0;
    m_PlagueCityRegardCostValue = 0;
    m_NanoInfectCityRegardCostValue = 0;
    m_CreateParkRegardCostValue = 0;
    m_InjoinCityRegardCostValue = 0;
    m_PillageRegardCostValue = 0;
    m_HoldReceptionRegardBonusValue = 0;
    m_HasPactTrustBonusValue = 0;
    m_NoWarTrustBonusValue = 0;
    m_AttackCivilianTrustCostValue = 0;
    m_PreemptiveAttackTrustCostValue = 0;
    m_FollowThroughTrustBonusValue = 0;
    m_UsedNukesTrustCostValue = 0;
    m_WantMapTurnsValue = 0;
    m_ProposalElement = NULL;
    m_numProposalElement = 0;
}

DiplomacyRecord::~DiplomacyRecord()
{
	int index = 0;
	// free array ProposalElement 
 			// free struct elements
	if (m_numProposalElement > 0) 
		delete [m_numProposalElement] m_ProposalElement; 
	m_ProposalElement = NULL; 
	m_numProposalElement = 0; 

}

void DiplomacyRecord::operator=(const DiplomacyRecord & rval)
{
	int index = 0;
	m_index = rval.m_index;
	// copy fixed sized array Inherit[] 
 		memcpy(m_Inherit, rval.m_Inherit, sizeof(sint32)*rval.m_numInherit); 

	m_flags0 = rval.m_flags0; 
		m_ScenarioEventValue = rval.m_ScenarioEventValue; 

	m_flags0 = rval.m_flags0; 
		m_MilitaryPowerEventValue = rval.m_MilitaryPowerEventValue; 

	m_flags0 = rval.m_flags0; 
		m_MilitarySafetyEventValue = rval.m_MilitarySafetyEventValue; 

	m_flags0 = rval.m_flags0; 
		m_DiplomacyEventValue = rval.m_DiplomacyEventValue; 

	m_flags0 = rval.m_flags0; 
		m_GoldEventValue = rval.m_GoldEventValue; 

	m_flags0 = rval.m_flags0; 
		m_KnowledgeEventValue = rval.m_KnowledgeEventValue; 

	m_flags0 = rval.m_flags0; 
		m_ProductionEventValue = rval.m_ProductionEventValue; 

	m_flags0 = rval.m_flags0; 
		m_ThreatenValue = rval.m_ThreatenValue; 

	m_flags0 = rval.m_flags0; 
		m_IncursionRegardCostValue = rval.m_IncursionRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_IncursionOfAllieRegardCostValue = rval.m_IncursionOfAllieRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_InvaderMovementRegardCostValue = rval.m_InvaderMovementRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_PerRoutePiracyRegardCostValue = rval.m_PerRoutePiracyRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_ShareContinentRegardCostValue = rval.m_ShareContinentRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_AttackCivilianRegardCostValue = rval.m_AttackCivilianRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_PreemptiveAttackRegardCostValue = rval.m_PreemptiveAttackRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_EmbargoTradeRegardCostValue = rval.m_EmbargoTradeRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_TakeCityRegardCostValue = rval.m_TakeCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_InciteRevolutionRegardCostValue = rval.m_InciteRevolutionRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_AssassinateRulerRegardCostValue = rval.m_AssassinateRulerRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_FranchiseCityRegardCostValue = rval.m_FranchiseCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_PlantNukeRegardCostValue = rval.m_PlantNukeRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_SlaveRaidRegardCostValue = rval.m_SlaveRaidRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_LawsuitRegardCostValue = rval.m_LawsuitRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_ExpelUnitsRegardCostValue = rval.m_ExpelUnitsRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_NukeCityRegardCostValue = rval.m_NukeCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_ConvertCityRegardCostValue = rval.m_ConvertCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_EnslaveSettlerRegardCostValue = rval.m_EnslaveSettlerRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_UndergroundRailwayRegardCostValue = rval.m_UndergroundRailwayRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_InciteUprisingRegardCostValue = rval.m_InciteUprisingRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_BioInfectedCityRegardCostValue = rval.m_BioInfectedCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_PlagueCityRegardCostValue = rval.m_PlagueCityRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_NanoInfectCityRegardCostValue = rval.m_NanoInfectCityRegardCostValue; 

	m_flags1 = rval.m_flags1; 
		m_CreateParkRegardCostValue = rval.m_CreateParkRegardCostValue; 

	m_flags1 = rval.m_flags1; 
		m_InjoinCityRegardCostValue = rval.m_InjoinCityRegardCostValue; 

	m_flags1 = rval.m_flags1; 
		m_PillageRegardCostValue = rval.m_PillageRegardCostValue; 

	m_flags1 = rval.m_flags1; 
		m_HoldReceptionRegardBonusValue = rval.m_HoldReceptionRegardBonusValue; 

	m_flags1 = rval.m_flags1; 
		m_HasPactTrustBonusValue = rval.m_HasPactTrustBonusValue; 

	m_flags1 = rval.m_flags1; 
		m_NoWarTrustBonusValue = rval.m_NoWarTrustBonusValue; 

	m_flags1 = rval.m_flags1; 
		m_AttackCivilianTrustCostValue = rval.m_AttackCivilianTrustCostValue; 

	m_flags1 = rval.m_flags1; 
		m_PreemptiveAttackTrustCostValue = rval.m_PreemptiveAttackTrustCostValue; 

	m_flags1 = rval.m_flags1; 
		m_FollowThroughTrustBonusValue = rval.m_FollowThroughTrustBonusValue; 

	m_flags1 = rval.m_flags1; 
		m_UsedNukesTrustCostValue = rval.m_UsedNukesTrustCostValue; 

	m_flags1 = rval.m_flags1; 
		m_WantMapTurnsValue = rval.m_WantMapTurnsValue; 

	// free array ProposalElement 
 	// free struct elements of ProposalElement[]
	if (m_numProposalElement > 0) 
	{
		delete [m_numProposalElement] m_ProposalElement; 
		m_ProposalElement = NULL; 
	}

	if (rval.m_numProposalElement > 0) 
	{
		m_ProposalElement = new ProposalElement [rval.m_numProposalElement];
	}

	// copy struct elements of ProposalElement[]
	for (index = 0; index < rval.m_numProposalElement; index++) 
		{ 
			m_ProposalElement[index] = rval.m_ProposalElement[index]; 
	} 
	m_numProposalElement = rval.m_numProposalElement;

}

char *g_Diplomacy_Tokens[] =
{
    "Inherit",
    "ScenarioEvent",
    "ScenarioEventValue",
    "MilitaryPowerEvent",
    "MilitaryPowerEventValue",
    "MilitarySafetyEvent",
    "MilitarySafetyEventValue",
    "DiplomacyEvent",
    "DiplomacyEventValue",
    "GoldEvent",
    "GoldEventValue",
    "KnowledgeEvent",
    "KnowledgeEventValue",
    "ProductionEvent",
    "ProductionEventValue",
    "Threaten",
    "ThreatenValue",
    "IncursionRegardCost",
    "IncursionRegardCostValue",
    "IncursionOfAllieRegardCost",
    "IncursionOfAllieRegardCostValue",
    "InvaderMovementRegardCost",
    "InvaderMovementRegardCostValue",
    "PerRoutePiracyRegardCost",
    "PerRoutePiracyRegardCostValue",
    "ShareContinentRegardCost",
    "ShareContinentRegardCostValue",
    "AttackCivilianRegardCost",
    "AttackCivilianRegardCostValue",
    "PreemptiveAttackRegardCost",
    "PreemptiveAttackRegardCostValue",
    "EmbargoTradeRegardCost",
    "EmbargoTradeRegardCostValue",
    "TakeCityRegardCost",
    "TakeCityRegardCostValue",
    "InciteRevolutionRegardCost",
    "InciteRevolutionRegardCostValue",
    "AssassinateRulerRegardCost",
    "AssassinateRulerRegardCostValue",
    "FranchiseCityRegardCost",
    "FranchiseCityRegardCostValue",
    "PlantNukeRegardCost",
    "PlantNukeRegardCostValue",
    "SlaveRaidRegardCost",
    "SlaveRaidRegardCostValue",
    "LawsuitRegardCost",
    "LawsuitRegardCostValue",
    "ExpelUnitsRegardCost",
    "ExpelUnitsRegardCostValue",
    "NukeCityRegardCost",
    "NukeCityRegardCostValue",
    "ConvertCityRegardCost",
    "ConvertCityRegardCostValue",
    "EnslaveSettlerRegardCost",
    "EnslaveSettlerRegardCostValue",
    "UndergroundRailwayRegardCost",
    "UndergroundRailwayRegardCostValue",
    "InciteUprisingRegardCost",
    "InciteUprisingRegardCostValue",
    "BioInfectedCityRegardCost",
    "BioInfectedCityRegardCostValue",
    "PlagueCityRegardCost",
    "PlagueCityRegardCostValue",
    "NanoInfectCityRegardCost",
    "NanoInfectCityRegardCostValue",
    "CreateParkRegardCost",
    "CreateParkRegardCostValue",
    "InjoinCityRegardCost",
    "InjoinCityRegardCostValue",
    "PillageRegardCost",
    "PillageRegardCostValue",
    "HoldReceptionRegardBonus",
    "HoldReceptionRegardBonusValue",
    "HasPactTrustBonus",
    "HasPactTrustBonusValue",
    "NoWarTrustBonus",
    "NoWarTrustBonusValue",
    "AttackCivilianTrustCost",
    "AttackCivilianTrustCostValue",
    "PreemptiveAttackTrustCost",
    "PreemptiveAttackTrustCostValue",
    "FollowThroughTrustBonus",
    "FollowThroughTrustBonusValue",
    "UsedNukesTrustCost",
    "UsedNukesTrustCostValue",
    "WantMapTurns",
    "WantMapTurnsValue",
    "ProposalElement",
};

DiplomacyRecordAccessorInfo g_DiplomacyRecord_Accessors[] = 
{
    { NULL, NULL, NULL, NULL, NULL}, /* Inherit (array) */
    { NULL, NULL, NULL, NULL, NULL}, /* ScenarioEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* ScenarioEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* MilitaryPowerEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* MilitaryPowerEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* MilitarySafetyEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* MilitarySafetyEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* DiplomacyEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* DiplomacyEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* GoldEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* GoldEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* KnowledgeEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* KnowledgeEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* ProductionEvent */
    { NULL, NULL, NULL, NULL, NULL}, /* ProductionEvent */
    { NULL, NULL, NULL, DiplomacyRecord::GetThreaten, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* Threaten */
    { NULL, NULL, NULL, DiplomacyRecord::GetIncursionRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* IncursionRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetIncursionOfAllieRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* IncursionOfAllieRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetInvaderMovementRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* InvaderMovementRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPerRoutePiracyRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PerRoutePiracyRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetShareContinentRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ShareContinentRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetAttackCivilianRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* AttackCivilianRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPreemptiveAttackRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PreemptiveAttackRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetEmbargoTradeRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EmbargoTradeRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetTakeCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* TakeCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetInciteRevolutionRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* InciteRevolutionRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetAssassinateRulerRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* AssassinateRulerRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetFranchiseCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FranchiseCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPlantNukeRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PlantNukeRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetSlaveRaidRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* SlaveRaidRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetLawsuitRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* LawsuitRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetExpelUnitsRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ExpelUnitsRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetNukeCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* NukeCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetConvertCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* ConvertCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetEnslaveSettlerRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* EnslaveSettlerRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetUndergroundRailwayRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* UndergroundRailwayRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetInciteUprisingRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* InciteUprisingRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetBioInfectedCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* BioInfectedCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPlagueCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PlagueCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetNanoInfectCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* NanoInfectCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetCreateParkRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* CreateParkRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetInjoinCityRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* InjoinCityRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPillageRegardCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PillageRegardCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetHoldReceptionRegardBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* HoldReceptionRegardBonus */
    { NULL, NULL, NULL, DiplomacyRecord::GetHasPactTrustBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* HasPactTrustBonus */
    { NULL, NULL, NULL, DiplomacyRecord::GetNoWarTrustBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* NoWarTrustBonus */
    { NULL, NULL, NULL, DiplomacyRecord::GetAttackCivilianTrustCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* AttackCivilianTrustCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetPreemptiveAttackTrustCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* PreemptiveAttackTrustCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetFollowThroughTrustBonus, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* FollowThroughTrustBonus */
    { NULL, NULL, NULL, DiplomacyRecord::GetUsedNukesTrustCost, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* UsedNukesTrustCost */
    { NULL, NULL, NULL, DiplomacyRecord::GetWantMapTurns, NULL },
    { NULL, NULL, NULL, NULL, NULL}, /* WantMapTurns */
    { NULL, NULL, NULL, NULL, NULL}, /* ProposalElement */
};

#define k_Token_Diplomacy_Inherit                ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_ScenarioEvent          ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_ScenarioEvent_Value    ((k_Token_Custom_Base) + 2)
#define k_Token_Diplomacy_MilitaryPowerEvent     ((k_Token_Custom_Base) + 3)
#define k_Token_Diplomacy_MilitaryPowerEvent_Value ((k_Token_Custom_Base) + 4)
#define k_Token_Diplomacy_MilitarySafetyEvent    ((k_Token_Custom_Base) + 5)
#define k_Token_Diplomacy_MilitarySafetyEvent_Value ((k_Token_Custom_Base) + 6)
#define k_Token_Diplomacy_DiplomacyEvent         ((k_Token_Custom_Base) + 7)
#define k_Token_Diplomacy_DiplomacyEvent_Value   ((k_Token_Custom_Base) + 8)
#define k_Token_Diplomacy_GoldEvent              ((k_Token_Custom_Base) + 9)
#define k_Token_Diplomacy_GoldEvent_Value        ((k_Token_Custom_Base) + 10)
#define k_Token_Diplomacy_KnowledgeEvent         ((k_Token_Custom_Base) + 11)
#define k_Token_Diplomacy_KnowledgeEvent_Value   ((k_Token_Custom_Base) + 12)
#define k_Token_Diplomacy_ProductionEvent        ((k_Token_Custom_Base) + 13)
#define k_Token_Diplomacy_ProductionEvent_Value  ((k_Token_Custom_Base) + 14)
#define k_Token_Diplomacy_Threaten               ((k_Token_Custom_Base) + 15)
#define k_Token_Diplomacy_Threaten_Value         ((k_Token_Custom_Base) + 16)
#define k_Token_Diplomacy_IncursionRegardCost    ((k_Token_Custom_Base) + 17)
#define k_Token_Diplomacy_IncursionRegardCost_Value ((k_Token_Custom_Base) + 18)
#define k_Token_Diplomacy_IncursionOfAllieRegardCost ((k_Token_Custom_Base) + 19)
#define k_Token_Diplomacy_IncursionOfAllieRegardCost_Value ((k_Token_Custom_Base) + 20)
#define k_Token_Diplomacy_InvaderMovementRegardCost ((k_Token_Custom_Base) + 21)
#define k_Token_Diplomacy_InvaderMovementRegardCost_Value ((k_Token_Custom_Base) + 22)
#define k_Token_Diplomacy_PerRoutePiracyRegardCost ((k_Token_Custom_Base) + 23)
#define k_Token_Diplomacy_PerRoutePiracyRegardCost_Value ((k_Token_Custom_Base) + 24)
#define k_Token_Diplomacy_ShareContinentRegardCost ((k_Token_Custom_Base) + 25)
#define k_Token_Diplomacy_ShareContinentRegardCost_Value ((k_Token_Custom_Base) + 26)
#define k_Token_Diplomacy_AttackCivilianRegardCost ((k_Token_Custom_Base) + 27)
#define k_Token_Diplomacy_AttackCivilianRegardCost_Value ((k_Token_Custom_Base) + 28)
#define k_Token_Diplomacy_PreemptiveAttackRegardCost ((k_Token_Custom_Base) + 29)
#define k_Token_Diplomacy_PreemptiveAttackRegardCost_Value ((k_Token_Custom_Base) + 30)
#define k_Token_Diplomacy_EmbargoTradeRegardCost ((k_Token_Custom_Base) + 31)
#define k_Token_Diplomacy_EmbargoTradeRegardCost_Value ((k_Token_Custom_Base) + 32)
#define k_Token_Diplomacy_TakeCityRegardCost     ((k_Token_Custom_Base) + 33)
#define k_Token_Diplomacy_TakeCityRegardCost_Value ((k_Token_Custom_Base) + 34)
#define k_Token_Diplomacy_InciteRevolutionRegardCost ((k_Token_Custom_Base) + 35)
#define k_Token_Diplomacy_InciteRevolutionRegardCost_Value ((k_Token_Custom_Base) + 36)
#define k_Token_Diplomacy_AssassinateRulerRegardCost ((k_Token_Custom_Base) + 37)
#define k_Token_Diplomacy_AssassinateRulerRegardCost_Value ((k_Token_Custom_Base) + 38)
#define k_Token_Diplomacy_FranchiseCityRegardCost ((k_Token_Custom_Base) + 39)
#define k_Token_Diplomacy_FranchiseCityRegardCost_Value ((k_Token_Custom_Base) + 40)
#define k_Token_Diplomacy_PlantNukeRegardCost    ((k_Token_Custom_Base) + 41)
#define k_Token_Diplomacy_PlantNukeRegardCost_Value ((k_Token_Custom_Base) + 42)
#define k_Token_Diplomacy_SlaveRaidRegardCost    ((k_Token_Custom_Base) + 43)
#define k_Token_Diplomacy_SlaveRaidRegardCost_Value ((k_Token_Custom_Base) + 44)
#define k_Token_Diplomacy_LawsuitRegardCost      ((k_Token_Custom_Base) + 45)
#define k_Token_Diplomacy_LawsuitRegardCost_Value ((k_Token_Custom_Base) + 46)
#define k_Token_Diplomacy_ExpelUnitsRegardCost   ((k_Token_Custom_Base) + 47)
#define k_Token_Diplomacy_ExpelUnitsRegardCost_Value ((k_Token_Custom_Base) + 48)
#define k_Token_Diplomacy_NukeCityRegardCost     ((k_Token_Custom_Base) + 49)
#define k_Token_Diplomacy_NukeCityRegardCost_Value ((k_Token_Custom_Base) + 50)
#define k_Token_Diplomacy_ConvertCityRegardCost  ((k_Token_Custom_Base) + 51)
#define k_Token_Diplomacy_ConvertCityRegardCost_Value ((k_Token_Custom_Base) + 52)
#define k_Token_Diplomacy_EnslaveSettlerRegardCost ((k_Token_Custom_Base) + 53)
#define k_Token_Diplomacy_EnslaveSettlerRegardCost_Value ((k_Token_Custom_Base) + 54)
#define k_Token_Diplomacy_UndergroundRailwayRegardCost ((k_Token_Custom_Base) + 55)
#define k_Token_Diplomacy_UndergroundRailwayRegardCost_Value ((k_Token_Custom_Base) + 56)
#define k_Token_Diplomacy_InciteUprisingRegardCost ((k_Token_Custom_Base) + 57)
#define k_Token_Diplomacy_InciteUprisingRegardCost_Value ((k_Token_Custom_Base) + 58)
#define k_Token_Diplomacy_BioInfectedCityRegardCost ((k_Token_Custom_Base) + 59)
#define k_Token_Diplomacy_BioInfectedCityRegardCost_Value ((k_Token_Custom_Base) + 60)
#define k_Token_Diplomacy_PlagueCityRegardCost   ((k_Token_Custom_Base) + 61)
#define k_Token_Diplomacy_PlagueCityRegardCost_Value ((k_Token_Custom_Base) + 62)
#define k_Token_Diplomacy_NanoInfectCityRegardCost ((k_Token_Custom_Base) + 63)
#define k_Token_Diplomacy_NanoInfectCityRegardCost_Value ((k_Token_Custom_Base) + 64)
#define k_Token_Diplomacy_CreateParkRegardCost   ((k_Token_Custom_Base) + 65)
#define k_Token_Diplomacy_CreateParkRegardCost_Value ((k_Token_Custom_Base) + 66)
#define k_Token_Diplomacy_InjoinCityRegardCost   ((k_Token_Custom_Base) + 67)
#define k_Token_Diplomacy_InjoinCityRegardCost_Value ((k_Token_Custom_Base) + 68)
#define k_Token_Diplomacy_PillageRegardCost      ((k_Token_Custom_Base) + 69)
#define k_Token_Diplomacy_PillageRegardCost_Value ((k_Token_Custom_Base) + 70)
#define k_Token_Diplomacy_HoldReceptionRegardBonus ((k_Token_Custom_Base) + 71)
#define k_Token_Diplomacy_HoldReceptionRegardBonus_Value ((k_Token_Custom_Base) + 72)
#define k_Token_Diplomacy_HasPactTrustBonus      ((k_Token_Custom_Base) + 73)
#define k_Token_Diplomacy_HasPactTrustBonus_Value ((k_Token_Custom_Base) + 74)
#define k_Token_Diplomacy_NoWarTrustBonus        ((k_Token_Custom_Base) + 75)
#define k_Token_Diplomacy_NoWarTrustBonus_Value  ((k_Token_Custom_Base) + 76)
#define k_Token_Diplomacy_AttackCivilianTrustCost ((k_Token_Custom_Base) + 77)
#define k_Token_Diplomacy_AttackCivilianTrustCost_Value ((k_Token_Custom_Base) + 78)
#define k_Token_Diplomacy_PreemptiveAttackTrustCost ((k_Token_Custom_Base) + 79)
#define k_Token_Diplomacy_PreemptiveAttackTrustCost_Value ((k_Token_Custom_Base) + 80)
#define k_Token_Diplomacy_FollowThroughTrustBonus ((k_Token_Custom_Base) + 81)
#define k_Token_Diplomacy_FollowThroughTrustBonus_Value ((k_Token_Custom_Base) + 82)
#define k_Token_Diplomacy_UsedNukesTrustCost     ((k_Token_Custom_Base) + 83)
#define k_Token_Diplomacy_UsedNukesTrustCost_Value ((k_Token_Custom_Base) + 84)
#define k_Token_Diplomacy_WantMapTurns           ((k_Token_Custom_Base) + 85)
#define k_Token_Diplomacy_WantMapTurns_Value     ((k_Token_Custom_Base) + 86)
#define k_Token_Diplomacy_ProposalElement        ((k_Token_Custom_Base) + 87)
#define k_Token_Diplomacy_Max                    ((k_Token_Custom_Base) + 88)


static BitArray s_ParsedTokens(88);
void DiplomacyRecord::CheckRequiredFields(DBLexer *lex)
{
    // Ick.
}
    
sint32 DiplomacyRecord::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 result = 0;
    sint32 tok;
    DBPARSE_ERROR err = DBPARSE_OK;
    s_ParsedTokens.Clear();
    lex->SetTokens(g_Diplomacy_Tokens, k_Token_Diplomacy_Max);
    tok = lex->GetToken();
    if(tok != k_Token_Name) {
        DBERROR(("Record does not start with name"));
        return 0;
    }
    if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name)) {
        g_theStringDB->InsertStr(lex->GetTokenText(), lex->GetTokenText());
        if(!g_theStringDB->GetStringID(lex->GetTokenText(), m_name))
            SetTextName(lex->GetTokenText());
    }

    tok = lex->GetToken();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Missing open brace"));
        return 0;
    }

    while(!done) {
        tok = lex->GetToken();
        if(tok >= k_Token_Custom_Base && tok < k_Token_Diplomacy_Max) { 
            s_ParsedTokens.SetBit(tok - k_Token_Custom_Base);
        }
        switch(tok) {
            case k_Token_Diplomacy_Inherit:
                if(!g_theDiplomacyDB->ParseRecordInArray(lex, (sint32 *)m_Inherit, &m_numInherit, k_MAX_Inherit, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ScenarioEvent:
                m_flags0 |= k_Diplomacy_ScenarioEvent_Bit;
                if(!m_ScenarioEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_MilitaryPowerEvent:
                m_flags0 |= k_Diplomacy_MilitaryPowerEvent_Bit;
                if(!m_MilitaryPowerEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_MilitarySafetyEvent:
                m_flags0 |= k_Diplomacy_MilitarySafetyEvent_Bit;
                if(!m_MilitarySafetyEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_DiplomacyEvent:
                m_flags0 |= k_Diplomacy_DiplomacyEvent_Bit;
                if(!m_DiplomacyEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_GoldEvent:
                m_flags0 |= k_Diplomacy_GoldEvent_Bit;
                if(!m_GoldEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_KnowledgeEvent:
                m_flags0 |= k_Diplomacy_KnowledgeEvent_Bit;
                if(!m_KnowledgeEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProductionEvent:
                m_flags0 |= k_Diplomacy_ProductionEvent_Bit;
                if(!m_ProductionEventValue.Parse(lex)) {
                    DBERROR(("Expected struct"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_Threaten:
                m_flags0 |= k_Diplomacy_Threaten_Bit;
                if(!lex->GetIntAssignment(m_ThreatenValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_IncursionRegardCost:
                m_flags0 |= k_Diplomacy_IncursionRegardCost_Bit;
                if(!lex->GetIntAssignment(m_IncursionRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_IncursionOfAllieRegardCost:
                m_flags0 |= k_Diplomacy_IncursionOfAllieRegardCost_Bit;
                if(!lex->GetIntAssignment(m_IncursionOfAllieRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InvaderMovementRegardCost:
                m_flags0 |= k_Diplomacy_InvaderMovementRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InvaderMovementRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PerRoutePiracyRegardCost:
                m_flags0 |= k_Diplomacy_PerRoutePiracyRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PerRoutePiracyRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ShareContinentRegardCost:
                m_flags0 |= k_Diplomacy_ShareContinentRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ShareContinentRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AttackCivilianRegardCost:
                m_flags0 |= k_Diplomacy_AttackCivilianRegardCost_Bit;
                if(!lex->GetIntAssignment(m_AttackCivilianRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PreemptiveAttackRegardCost:
                m_flags0 |= k_Diplomacy_PreemptiveAttackRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveAttackRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_EmbargoTradeRegardCost:
                m_flags0 |= k_Diplomacy_EmbargoTradeRegardCost_Bit;
                if(!lex->GetIntAssignment(m_EmbargoTradeRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_TakeCityRegardCost:
                m_flags0 |= k_Diplomacy_TakeCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_TakeCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InciteRevolutionRegardCost:
                m_flags0 |= k_Diplomacy_InciteRevolutionRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InciteRevolutionRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AssassinateRulerRegardCost:
                m_flags0 |= k_Diplomacy_AssassinateRulerRegardCost_Bit;
                if(!lex->GetIntAssignment(m_AssassinateRulerRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_FranchiseCityRegardCost:
                m_flags0 |= k_Diplomacy_FranchiseCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_FranchiseCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PlantNukeRegardCost:
                m_flags0 |= k_Diplomacy_PlantNukeRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PlantNukeRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_SlaveRaidRegardCost:
                m_flags0 |= k_Diplomacy_SlaveRaidRegardCost_Bit;
                if(!lex->GetIntAssignment(m_SlaveRaidRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_LawsuitRegardCost:
                m_flags0 |= k_Diplomacy_LawsuitRegardCost_Bit;
                if(!lex->GetIntAssignment(m_LawsuitRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ExpelUnitsRegardCost:
                m_flags0 |= k_Diplomacy_ExpelUnitsRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ExpelUnitsRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NukeCityRegardCost:
                m_flags0 |= k_Diplomacy_NukeCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_NukeCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ConvertCityRegardCost:
                m_flags0 |= k_Diplomacy_ConvertCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ConvertCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_EnslaveSettlerRegardCost:
                m_flags0 |= k_Diplomacy_EnslaveSettlerRegardCost_Bit;
                if(!lex->GetIntAssignment(m_EnslaveSettlerRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_UndergroundRailwayRegardCost:
                m_flags0 |= k_Diplomacy_UndergroundRailwayRegardCost_Bit;
                if(!lex->GetIntAssignment(m_UndergroundRailwayRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InciteUprisingRegardCost:
                m_flags0 |= k_Diplomacy_InciteUprisingRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InciteUprisingRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_BioInfectedCityRegardCost:
                m_flags0 |= k_Diplomacy_BioInfectedCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_BioInfectedCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PlagueCityRegardCost:
                m_flags0 |= k_Diplomacy_PlagueCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PlagueCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NanoInfectCityRegardCost:
                m_flags0 |= k_Diplomacy_NanoInfectCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_NanoInfectCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_CreateParkRegardCost:
                m_flags1 |= k_Diplomacy_CreateParkRegardCost_Bit;
                if(!lex->GetIntAssignment(m_CreateParkRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_InjoinCityRegardCost:
                m_flags1 |= k_Diplomacy_InjoinCityRegardCost_Bit;
                if(!lex->GetIntAssignment(m_InjoinCityRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PillageRegardCost:
                m_flags1 |= k_Diplomacy_PillageRegardCost_Bit;
                if(!lex->GetIntAssignment(m_PillageRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_HoldReceptionRegardBonus:
                m_flags1 |= k_Diplomacy_HoldReceptionRegardBonus_Bit;
                if(!lex->GetIntAssignment(m_HoldReceptionRegardBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_HasPactTrustBonus:
                m_flags1 |= k_Diplomacy_HasPactTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_HasPactTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_NoWarTrustBonus:
                m_flags1 |= k_Diplomacy_NoWarTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_NoWarTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_AttackCivilianTrustCost:
                m_flags1 |= k_Diplomacy_AttackCivilianTrustCost_Bit;
                if(!lex->GetIntAssignment(m_AttackCivilianTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_PreemptiveAttackTrustCost:
                m_flags1 |= k_Diplomacy_PreemptiveAttackTrustCost_Bit;
                if(!lex->GetIntAssignment(m_PreemptiveAttackTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_FollowThroughTrustBonus:
                m_flags1 |= k_Diplomacy_FollowThroughTrustBonus_Bit;
                if(!lex->GetIntAssignment(m_FollowThroughTrustBonusValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_UsedNukesTrustCost:
                m_flags1 |= k_Diplomacy_UsedNukesTrustCost_Bit;
                if(!lex->GetIntAssignment(m_UsedNukesTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_WantMapTurns:
                m_flags1 |= k_Diplomacy_WantMapTurns_Bit;
                if(!lex->GetIntAssignment(m_WantMapTurnsValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement:
                if(!DiplomacyRecord::ProposalElement::ParseInArray(lex, &m_ProposalElement, &m_numProposalElement)) 
                {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                DBERROR(("Unknown token"));
                done = true;
                break;
        }
    }
    CheckRequiredFields(lex);
    lex->RestoreTokens();
    return result;
}

void DiplomacyRecord::ResolveDBReferences()
{
    {
        sint32 i;
        for(i = 0; i < m_numInherit; i++) {
            if(m_Inherit[i] & 0x80000000) {
                sint32 id = m_Inherit[i] & 0x7fffffff;
                if(!g_theDiplomacyDB->GetNamedItem(id, m_Inherit[i])) {
                    c3errors_ErrorDialog("DB", "%s not found in Diplomacy database", g_theStringDB->GetNameStr(id));
                }
            } else if(m_Inherit[i] == 0x7fffffff){
                m_Inherit[i] = -1;
            }
        }
    }
    m_ScenarioEventValue.ResolveDBReferences();
    m_MilitaryPowerEventValue.ResolveDBReferences();
    m_MilitarySafetyEventValue.ResolveDBReferences();
    m_DiplomacyEventValue.ResolveDBReferences();
    m_GoldEventValue.ResolveDBReferences();
    m_KnowledgeEventValue.ResolveDBReferences();
    m_ProductionEventValue.ResolveDBReferences();
    {
        sint32 i;
        for(i = 0; i < m_numProposalElement; i++) {
            m_ProposalElement[i].ResolveDBReferences();
        }
    }
}
/*
 * Member class Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
DiplomacyRecord::RegardDecay::RegardDecay()
{
    m_PositiveDecay = 0.000000;
    m_NegativeDecay = 0.000000;
}
DiplomacyRecord::RegardDecay::~RegardDecay()
{
}
void DiplomacyRecord::RegardDecay::operator=(const RegardDecay & rval)
{
	m_PositiveDecay = rval.m_PositiveDecay; 

	m_NegativeDecay = rval.m_NegativeDecay; 

}
static char *s_Diplomacy_RegardDecay_Tokens[] = {
    "PositiveDecay",
    "NegativeDecay",
};
#define k_Token_Diplomacy_RegardDecay_PositiveDecay ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_RegardDecay_NegativeDecay ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_RegardDecay_Max ((k_Token_Custom_Base) + 2)
sint32 DiplomacyRecord::RegardDecay::ParseSequential(DBLexer *lex)
{
    DBPARSE_ERROR err = DBPARSE_OK;
    if(!lex->GetFloatAssignment(m_PositiveDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    if(!lex->GetFloatAssignment(m_NegativeDecay)) {
        DBERROR(("Expected number"));
        return 0;
    }
    return 1;
}
sint32 DiplomacyRecord::RegardDecay::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        if(ParseSequential(lex)) {
            return 1;
        }
        DBERROR(("Expected open brace for RegardDecay"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Diplomacy_RegardDecay_Tokens, k_Token_Diplomacy_RegardDecay_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Diplomacy_RegardDecay_PositiveDecay:
                if(!lex->GetFloatAssignment(m_PositiveDecay)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_RegardDecay_NegativeDecay:
                if(!lex->GetFloatAssignment(m_NegativeDecay)) {
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DiplomacyRecord::RegardDecay::ParseInArray(DBLexer *lex, RegardDecay **array, sint32 *numElements)
{
    if(*numElements > 0) {
        RegardDecay *oldArray = *array;
        *array = new RegardDecay[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new RegardDecay[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 DiplomacyRecord::RegardDecay::ParseInArray(DBLexer *lex, RegardDecay *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void DiplomacyRecord::RegardDecay::ResolveDBReferences()
{
}
DiplomacyRecord::ProposalElement::ProposalElement()
{
    m_flags0 = 0;
    m_Proposal = 0x7fffffff;
    m_SendPriorityValue = 0;
    m_AcceptPriorityValue = 0;
    m_RejectPriorityValue = 0;
    m_SenderRegardResultValue = 0;
    m_ReceiverRegardResultValue = 0;
    m_ViolationRegardCostValue = 0;
    m_ViolationTrustCostValue = 0;
}
DiplomacyRecord::ProposalElement::~ProposalElement()
{
}
void DiplomacyRecord::ProposalElement::operator=(const ProposalElement & rval)
{
	m_Proposal = rval.m_Proposal; 

	m_flags0 = rval.m_flags0; 
		m_SendPriorityValue = rval.m_SendPriorityValue; 

	m_flags0 = rval.m_flags0; 
		m_AcceptPriorityValue = rval.m_AcceptPriorityValue; 

	m_flags0 = rval.m_flags0; 
		m_RejectPriorityValue = rval.m_RejectPriorityValue; 

	m_flags0 = rval.m_flags0; 
		m_SenderRegardResultValue = rval.m_SenderRegardResultValue; 

	m_flags0 = rval.m_flags0; 
		m_ReceiverRegardResultValue = rval.m_ReceiverRegardResultValue; 

	m_flags0 = rval.m_flags0; 
		m_ViolationRegardCostValue = rval.m_ViolationRegardCostValue; 

	m_flags0 = rval.m_flags0; 
		m_ViolationTrustCostValue = rval.m_ViolationTrustCostValue; 

}
static char *s_Diplomacy_ProposalElement_Tokens[] = {
    "Proposal",
    "SendPriority",
    "AcceptPriority",
    "RejectPriority",
    "SenderRegardResult",
    "ReceiverRegardResult",
    "ViolationRegardCost",
    "ViolationTrustCost",
};
#define k_Token_Diplomacy_ProposalElement_Proposal ((k_Token_Custom_Base) + 0)
#define k_Token_Diplomacy_ProposalElement_SendPriority ((k_Token_Custom_Base) + 1)
#define k_Token_Diplomacy_ProposalElement_AcceptPriority ((k_Token_Custom_Base) + 2)
#define k_Token_Diplomacy_ProposalElement_RejectPriority ((k_Token_Custom_Base) + 3)
#define k_Token_Diplomacy_ProposalElement_SenderRegardResult ((k_Token_Custom_Base) + 4)
#define k_Token_Diplomacy_ProposalElement_ReceiverRegardResult ((k_Token_Custom_Base) + 5)
#define k_Token_Diplomacy_ProposalElement_ViolationRegardCost ((k_Token_Custom_Base) + 6)
#define k_Token_Diplomacy_ProposalElement_ViolationTrustCost ((k_Token_Custom_Base) + 7)
#define k_Token_Diplomacy_ProposalElement_Max ((k_Token_Custom_Base) + 8)
sint32 DiplomacyRecord::ProposalElement::Parse(DBLexer *lex)
{
    bool done = false;
    sint32 tok;
    sint32 result = 0;
    DBPARSE_ERROR err = DBPARSE_OK;
    tok = lex->PeekAhead();
    if(tok != k_Token_OpenBrace) {
        DBERROR(("Expected open brace for ProposalElement"));
        return 0;
    }
    tok = lex->GetToken();
    lex->SetTokens(s_Diplomacy_ProposalElement_Tokens, k_Token_Diplomacy_ProposalElement_Max);
    while(!done) {
        tok = lex->GetToken();
        switch(tok) {
            case k_Token_Diplomacy_ProposalElement_Proposal:
                if(!g_theDiplomacyProposalDB->GetRecordFromLexer(lex, m_Proposal, err)) {
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_SendPriority:
                m_flags0 |= k_ProposalElement_SendPriority_Bit;
                if(!lex->GetIntAssignment(m_SendPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_AcceptPriority:
                m_flags0 |= k_ProposalElement_AcceptPriority_Bit;
                if(!lex->GetIntAssignment(m_AcceptPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_RejectPriority:
                m_flags0 |= k_ProposalElement_RejectPriority_Bit;
                if(!lex->GetIntAssignment(m_RejectPriorityValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_SenderRegardResult:
                m_flags0 |= k_ProposalElement_SenderRegardResult_Bit;
                if(!lex->GetIntAssignment(m_SenderRegardResultValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ReceiverRegardResult:
                m_flags0 |= k_ProposalElement_ReceiverRegardResult_Bit;
                if(!lex->GetIntAssignment(m_ReceiverRegardResultValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ViolationRegardCost:
                m_flags0 |= k_ProposalElement_ViolationRegardCost_Bit;
                if(!lex->GetIntAssignment(m_ViolationRegardCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_Diplomacy_ProposalElement_ViolationTrustCost:
                m_flags0 |= k_ProposalElement_ViolationTrustCost_Bit;
                if(!lex->GetIntAssignment(m_ViolationTrustCostValue)) {
                    DBERROR(("Expected integer"));
                    done = true; break;
                }
                break;
            case k_Token_CloseBrace:
                done = true;
                result = 1;
                break;
            default:
                Assert(FALSE);
                done = true;
                break;
        }
    }
    lex->RestoreTokens();
    return result;
}

sint32 DiplomacyRecord::ProposalElement::ParseInArray(DBLexer *lex, ProposalElement **array, sint32 *numElements)
{
    if(*numElements > 0) {
        ProposalElement *oldArray = *array;
        *array = new ProposalElement[(*numElements) + 1];
        for (int i=0; i < (*numElements); i++) 
             (*array)[i] = oldArray[i];
        delete [] oldArray;
    } else {
        *array = new ProposalElement[1];
    }
    (*array)[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
sint32 DiplomacyRecord::ProposalElement::ParseInArray(DBLexer *lex, ProposalElement *array, sint32 *numElements, sint32 maxSize)
{
    if(*numElements >= maxSize) {
        return 0;
    }
    array[*numElements].Parse(lex);
    *numElements += 1;
    return 1;
}
void DiplomacyRecord::ProposalElement::ResolveDBReferences()
{
    if(m_Proposal & 0x80000000) {
        sint32 id = m_Proposal & 0x7fffffff;
        if(!g_theDiplomacyProposalDB->GetNamedItem(id, m_Proposal)) {
            c3errors_ErrorDialog("DB", "%s not found in DiplomacyProposal database", g_theStringDB->GetNameStr(id));
        }
    } else if(m_Proposal == 0x7fffffff) {
        m_Proposal = -1;
    }
}
/*
 * Data Parsers
 * (DO NOT EDIT!  Automatically generated file)
 */
void DiplomacyRecord::Merge(const DiplomacyRecord & rval){
	int index = 0, obj_index = 0;
	// copy values of rval.m_Inherit to m_Inherit
	for (index = 0; index < m_numInherit; index++) 
	{ 
 		if (index < rval.m_numInherit)
 			m_Inherit[index] = rval.m_Inherit[index];
	} 
 	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_ScenarioEvent_Bit) != 0) 
		m_ScenarioEventValue = rval.m_ScenarioEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_MilitaryPowerEvent_Bit) != 0) 
		m_MilitaryPowerEventValue = rval.m_MilitaryPowerEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_MilitarySafetyEvent_Bit) != 0) 
		m_MilitarySafetyEventValue = rval.m_MilitarySafetyEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_DiplomacyEvent_Bit) != 0) 
		m_DiplomacyEventValue = rval.m_DiplomacyEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_GoldEvent_Bit) != 0) 
		m_GoldEventValue = rval.m_GoldEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_KnowledgeEvent_Bit) != 0) 
		m_KnowledgeEventValue = rval.m_KnowledgeEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_ProductionEvent_Bit) != 0) 
		m_ProductionEventValue = rval.m_ProductionEventValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_Threaten_Bit) != 0) 
		m_ThreatenValue = rval.m_ThreatenValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_IncursionRegardCost_Bit) != 0) 
		m_IncursionRegardCostValue = rval.m_IncursionRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_IncursionOfAllieRegardCost_Bit) != 0) 
		m_IncursionOfAllieRegardCostValue = rval.m_IncursionOfAllieRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_InvaderMovementRegardCost_Bit) != 0) 
		m_InvaderMovementRegardCostValue = rval.m_InvaderMovementRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_PerRoutePiracyRegardCost_Bit) != 0) 
		m_PerRoutePiracyRegardCostValue = rval.m_PerRoutePiracyRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_ShareContinentRegardCost_Bit) != 0) 
		m_ShareContinentRegardCostValue = rval.m_ShareContinentRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_AttackCivilianRegardCost_Bit) != 0) 
		m_AttackCivilianRegardCostValue = rval.m_AttackCivilianRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_PreemptiveAttackRegardCost_Bit) != 0) 
		m_PreemptiveAttackRegardCostValue = rval.m_PreemptiveAttackRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_EmbargoTradeRegardCost_Bit) != 0) 
		m_EmbargoTradeRegardCostValue = rval.m_EmbargoTradeRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_TakeCityRegardCost_Bit) != 0) 
		m_TakeCityRegardCostValue = rval.m_TakeCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_InciteRevolutionRegardCost_Bit) != 0) 
		m_InciteRevolutionRegardCostValue = rval.m_InciteRevolutionRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_AssassinateRulerRegardCost_Bit) != 0) 
		m_AssassinateRulerRegardCostValue = rval.m_AssassinateRulerRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_FranchiseCityRegardCost_Bit) != 0) 
		m_FranchiseCityRegardCostValue = rval.m_FranchiseCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_PlantNukeRegardCost_Bit) != 0) 
		m_PlantNukeRegardCostValue = rval.m_PlantNukeRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_SlaveRaidRegardCost_Bit) != 0) 
		m_SlaveRaidRegardCostValue = rval.m_SlaveRaidRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_LawsuitRegardCost_Bit) != 0) 
		m_LawsuitRegardCostValue = rval.m_LawsuitRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_ExpelUnitsRegardCost_Bit) != 0) 
		m_ExpelUnitsRegardCostValue = rval.m_ExpelUnitsRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_NukeCityRegardCost_Bit) != 0) 
		m_NukeCityRegardCostValue = rval.m_NukeCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_ConvertCityRegardCost_Bit) != 0) 
		m_ConvertCityRegardCostValue = rval.m_ConvertCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_EnslaveSettlerRegardCost_Bit) != 0) 
		m_EnslaveSettlerRegardCostValue = rval.m_EnslaveSettlerRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_UndergroundRailwayRegardCost_Bit) != 0) 
		m_UndergroundRailwayRegardCostValue = rval.m_UndergroundRailwayRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_InciteUprisingRegardCost_Bit) != 0) 
		m_InciteUprisingRegardCostValue = rval.m_InciteUprisingRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_BioInfectedCityRegardCost_Bit) != 0) 
		m_BioInfectedCityRegardCostValue = rval.m_BioInfectedCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_PlagueCityRegardCost_Bit) != 0) 
		m_PlagueCityRegardCostValue = rval.m_PlagueCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags0 & k_Diplomacy_NanoInfectCityRegardCost_Bit) != 0) 
		m_NanoInfectCityRegardCostValue = rval.m_NanoInfectCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_CreateParkRegardCost_Bit) != 0) 
		m_CreateParkRegardCostValue = rval.m_CreateParkRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_InjoinCityRegardCost_Bit) != 0) 
		m_InjoinCityRegardCostValue = rval.m_InjoinCityRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_PillageRegardCost_Bit) != 0) 
		m_PillageRegardCostValue = rval.m_PillageRegardCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_HoldReceptionRegardBonus_Bit) != 0) 
		m_HoldReceptionRegardBonusValue = rval.m_HoldReceptionRegardBonusValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_HasPactTrustBonus_Bit) != 0) 
		m_HasPactTrustBonusValue = rval.m_HasPactTrustBonusValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_NoWarTrustBonus_Bit) != 0) 
		m_NoWarTrustBonusValue = rval.m_NoWarTrustBonusValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_AttackCivilianTrustCost_Bit) != 0) 
		m_AttackCivilianTrustCostValue = rval.m_AttackCivilianTrustCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_PreemptiveAttackTrustCost_Bit) != 0) 
		m_PreemptiveAttackTrustCostValue = rval.m_PreemptiveAttackTrustCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_FollowThroughTrustBonus_Bit) != 0) 
		m_FollowThroughTrustBonusValue = rval.m_FollowThroughTrustBonusValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_UsedNukesTrustCost_Bit) != 0) 
		m_UsedNukesTrustCostValue = rval.m_UsedNukesTrustCostValue; 

	// only replace values that have been set
	if((rval.m_flags1 & k_Diplomacy_WantMapTurns_Bit) != 0) 
		m_WantMapTurnsValue = rval.m_WantMapTurnsValue; 

	// replace struct elements of m_ProposalElement
	for (index = 0; index < m_numProposalElement; index++) 
	{ 
		// find matching struct element
		for (int obj_index = 0; obj_index < rval.m_numProposalElement; obj_index++) 
			if (m_ProposalElement[index] == rval.m_ProposalElement[obj_index]) {
				// replace struct element 
				m_ProposalElement[index] = rval.m_ProposalElement[obj_index]; 
				}
	} 
} 

/*
 * Data accessors
 * (DO NOT EDIT!  Automatically generated file)
 */
sint32 DiplomacyRecord::GetInheritIndex(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return m_Inherit[index];
}

const DiplomacyRecord *DiplomacyRecord::GetInherit(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numInherit);
    if((index < 0) || (index >= m_numInherit)) {
        return 0;
    }
    return g_theDiplomacyDB->Get(m_Inherit[index]);
}

const DiplomacyRecord::ProposalElement *DiplomacyRecord::GetProposalElement(sint32 index) const
{
    Assert(index >= 0);
    Assert(index < m_numProposalElement);
    if((index < 0) || (index >= m_numProposalElement)) {
        return 0;
    }
    return &m_ProposalElement[index];
}

const DiplomacyProposalRecord *DiplomacyRecord::ProposalElement::GetProposal() const
{
    return g_theDiplomacyProposalDB->Get(m_Proposal);
}

