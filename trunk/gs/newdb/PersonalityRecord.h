
/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */
#ifndef __Personality_RECORD_H__
#define __Personality_RECORD_H__

/*
 * Personality description
 */
#include "CTPRecord.h"
//
// m_Exploration bit group
#define k_Personality_Exploration_Wide_Bit       0x00000001
#define k_Personality_Exploration_Medium_Bit     0x00000002
#define k_Personality_Exploration_Minimal_Bit    0x00000004
//
// m_Expansion bit group
#define k_Personality_Expansion_Maximum_Bit      0x00000001
#define k_Personality_Expansion_Average_Bit      0x00000002
#define k_Personality_Expansion_Minimum_Bit      0x00000004
//
// m_Discovery bit group
#define k_Personality_Discovery_Scientist_Bit    0x00000001
#define k_Personality_Discovery_Military_Bit     0x00000002
#define k_Personality_Discovery_Economic_Bit     0x00000004
#define k_Personality_Discovery_Ecotopian_Bit    0x00000008
#define k_Personality_Discovery_Diplomatic_Bit   0x00000010
//
// m_Conquest bit group
#define k_Personality_Conquest_Agressive_Bit     0x00000001
#define k_Personality_Conquest_Neutral_Bit       0x00000002
#define k_Personality_Conquest_Passive_Bit       0x00000004
//
// m_Trustworthiness bit group
#define k_Personality_Trustworthiness_Chaotic_Bit 0x00000001
#define k_Personality_Trustworthiness_Neutral_Bit 0x00000002
#define k_Personality_Trustworthiness_Lawful_Bit 0x00000004
//
// m_Alignment bit group
#define k_Personality_Alignment_Evil_Bit         0x00000001
#define k_Personality_Alignment_Neutral_Bit      0x00000002
#define k_Personality_Alignment_Good_Bit         0x00000004
//
// Range definitions

/*
 * DO NOT EDIT THIS FILE!
 * It is generated automatically by ctpdb
 */

class PersonalityRecord : public CTPRecord
{
public:
    typedef sint32 (PersonalityRecord::*IntAccessor)() const;
    typedef bool (PersonalityRecord::*BoolAccessor)() const;
    typedef double (PersonalityRecord::*FloatAccessor)() const ;
    typedef bool (PersonalityRecord::*BitIntAccessor)(sint32 &val) const;
    typedef bool (PersonalityRecord::*BitFloatAccessor)(double &val) const;
private:
    uint32            m_Exploration;
    uint32            m_Expansion;
    uint32            m_Discovery;
    uint32            m_Conquest;
    uint32            m_Trustworthiness;
    uint32            m_Alignment;
    sint32            m_StrongGreeting;
    sint32            m_WeakGreeting;
    double            m_ThreatFollowThrough;
    sint32            m_Description;

public:
    PersonalityRecord() { Init(); };
    ~PersonalityRecord();
    Init();
    // These methods are needed for records to conform to
    // 'Orthodox Cannonical Form' and work with resizing STL vectors. 
    PersonalityRecord(const PersonalityRecord &rval) { Init(); *this = rval; }
    void operator=(const PersonalityRecord &rval);

    void CheckRequiredFields(DBLexer *lex);
    sint32 Parse(DBLexer *lex);

    void ResolveDBReferences();
    void Merge(const PersonalityRecord & rval);
    sint32 ParseExplorationBit(DBLexer *lex);
    sint32 ParseExpansionBit(DBLexer *lex);
    sint32 ParseDiscoveryBit(DBLexer *lex);
    sint32 ParseConquestBit(DBLexer *lex);
    sint32 ParseTrustworthinessBit(DBLexer *lex);
    sint32 ParseAlignmentBit(DBLexer *lex);
    //
    // Accessors
    //

    //
    // Exploration flag group
    uint32           GetExploration() const { return m_Exploration; }
    bool             GetExplorationWide() const { return (m_Exploration & k_Personality_Exploration_Wide_Bit) != 0; }
    bool             GetExplorationMedium() const { return (m_Exploration & k_Personality_Exploration_Medium_Bit) != 0; }
    bool             GetExplorationMinimal() const { return (m_Exploration & k_Personality_Exploration_Minimal_Bit) != 0; }
    // End Exploration flag group
    //

    //
    // Expansion flag group
    uint32           GetExpansion() const { return m_Expansion; }
    bool             GetExpansionMaximum() const { return (m_Expansion & k_Personality_Expansion_Maximum_Bit) != 0; }
    bool             GetExpansionAverage() const { return (m_Expansion & k_Personality_Expansion_Average_Bit) != 0; }
    bool             GetExpansionMinimum() const { return (m_Expansion & k_Personality_Expansion_Minimum_Bit) != 0; }
    // End Expansion flag group
    //

    //
    // Discovery flag group
    uint32           GetDiscovery() const { return m_Discovery; }
    bool             GetDiscoveryScientist() const { return (m_Discovery & k_Personality_Discovery_Scientist_Bit) != 0; }
    bool             GetDiscoveryMilitary() const { return (m_Discovery & k_Personality_Discovery_Military_Bit) != 0; }
    bool             GetDiscoveryEconomic() const { return (m_Discovery & k_Personality_Discovery_Economic_Bit) != 0; }
    bool             GetDiscoveryEcotopian() const { return (m_Discovery & k_Personality_Discovery_Ecotopian_Bit) != 0; }
    bool             GetDiscoveryDiplomatic() const { return (m_Discovery & k_Personality_Discovery_Diplomatic_Bit) != 0; }
    // End Discovery flag group
    //

    //
    // Conquest flag group
    uint32           GetConquest() const { return m_Conquest; }
    bool             GetConquestAgressive() const { return (m_Conquest & k_Personality_Conquest_Agressive_Bit) != 0; }
    bool             GetConquestNeutral() const { return (m_Conquest & k_Personality_Conquest_Neutral_Bit) != 0; }
    bool             GetConquestPassive() const { return (m_Conquest & k_Personality_Conquest_Passive_Bit) != 0; }
    // End Conquest flag group
    //

    //
    // Trustworthiness flag group
    uint32           GetTrustworthiness() const { return m_Trustworthiness; }
    bool             GetTrustworthinessChaotic() const { return (m_Trustworthiness & k_Personality_Trustworthiness_Chaotic_Bit) != 0; }
    bool             GetTrustworthinessNeutral() const { return (m_Trustworthiness & k_Personality_Trustworthiness_Neutral_Bit) != 0; }
    bool             GetTrustworthinessLawful() const { return (m_Trustworthiness & k_Personality_Trustworthiness_Lawful_Bit) != 0; }
    // End Trustworthiness flag group
    //

    //
    // Alignment flag group
    uint32           GetAlignment() const { return m_Alignment; }
    bool             GetAlignmentEvil() const { return (m_Alignment & k_Personality_Alignment_Evil_Bit) != 0; }
    bool             GetAlignmentNeutral() const { return (m_Alignment & k_Personality_Alignment_Neutral_Bit) != 0; }
    bool             GetAlignmentGood() const { return (m_Alignment & k_Personality_Alignment_Good_Bit) != 0; }
    // End Alignment flag group
    //
    sint32           GetStrongGreeting() const { return m_StrongGreeting; }
    sint32           GetWeakGreeting() const { return m_WeakGreeting; }
    double           GetThreatFollowThrough() const { return m_ThreatFollowThrough; }
    sint32           GetDescription() const { return m_Description; }
}; /* PersonalityRecord */

struct PersonalityRecordAccessorInfo {
    PersonalityRecord::IntAccessor m_intAccessor;
    PersonalityRecord::BoolAccessor m_boolAccessor;
    PersonalityRecord::FloatAccessor m_floatAccessor;
    PersonalityRecord::BitIntAccessor m_bitIntAccessor;
    PersonalityRecord::BitFloatAccessor m_bitFloatAccessor;
};
extern PersonalityRecordAccessorInfo g_PersonalityRecord_Accessors[];
extern char *g_Personality_Tokens[];
#define k_Num_PersonalityRecord_Tokens 10

template <class T> class CTPDatabase;
extern CTPDatabase<PersonalityRecord> *g_thePersonalityDB;

#endif /* ifndef __Personality_RECORD_H__ */
